<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MacOS10.15应用安装问题]]></title>
    <url>%2Fmacos10-15%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[程序安装之后，运行程序提示： is damaged and can’t be opened. You should move it to the Trash. 首先切换到，允许所有开发者1sudo spctl --master-disable 然后打开终端运行： 1xattr -rc /Applications/你的应用.app 例如XMind ZEN 1xattr -rc /Applications/XMind\ ZEN.app 应用就可以打开了]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免密登陆anyConnect]]></title>
    <url>%2F%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86anyconnect%2F</url>
    <content type="text"><![CDATA[抵抗疫情在家办公，科学上网 公司的 VPN 需要使用 Cisco Anyconnect 作为客户端来连接，这个客户端在每次连接的时候需都要输入 LDAP 密码来登录。密码很复杂很是麻烦。可以通过 Anyconnect 提供的命令行工具来实现免密登录。经过网上一番搜集，根据https://hiberabyss.github.io/2017/11/27/no-password-anyconnect/整理。 安装安装过程不再赘述， 官网自行查看。 下载地址 通过命令行连接 VPN执行命令 /opt/cisco/anyconnect/bin/vpn -s 12345678910$ /opt/cisco/anyconnect/bin/vpn -sCisco AnyConnect Secure Mobility Client (version 4.7.01076) .Copyright (c) 2004 - 2019 Cisco Systems, Inc. All Rights Reserved. &gt;&gt; state: Connected &gt;&gt; state: Connected &gt;&gt; registered with local VPN subsystem.VPN&gt; 执行VPN&gt; connect your.vpn.host:port 12345VPN&gt; connect your.vpn.host:portconnect your.vpn.host:port &gt;&gt; state: Connected &gt;&gt; notice: Connected to vpn.ushareit.me. &gt;&gt; contacting host (your.vpn.host:port) for login information... 按照提示输入你的用户名和密码即可连接 VPN . 利用脚本连接 VPN（Mac 为例）VPN 需要知道三个信息：VPN 地址、用户名和密码。 密码是比较私密的信息，不适合放在脚本文件里，我们可以利用 macOS 里的 Keychain 工具来保存密码。 创建一个 Keychain password item打开 Keychain Access 工具，创建一个 VPN_NAME 条目: 当这个条目创建完成，我们便可以利用下面的命令获取密码： security find-generic-password -wl VPN_NAME 创建连接 VPN 的脚本文件下面的 shell 脚本文件会从 Keychain Access 工具里获取 VPN 的密码，然后利用 vpn 命令行工具连接 VPN ，最后打开 Anyconnect 客户端的 UI 界面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/bin/bashKEYCHAIN_LABEL="VPN_NAME"USERNAME= "UserName"PASSWORD=$(security find-generic-password -wl $KEYCHAIN_LABEL)VPN_URL="your.vpn.url"VPN_BIN="/opt/cisco/anyconnect/bin/vpn"ANYCONNECT_PATH="/Applications/Cisco/Cisco AnyConnect Secure Mobility Client.app"get_anyclient_ui_pid() &#123; local pid=$(ps -ef | grep "$ANYCONNECT_PATH" | grep -v 'grep' | awk '&#123;print $2&#125;') echo $pid if [[ -z "$pid" ]]; then return 1 else return 0 fi&#125;kill_anyconnect_ui() &#123; $VPN_BIN disconnect local pid=$(get_anyclient_ui_pid) # echo "PID: $pid" if [[ -n "$pid" ]]; then kill -9 $pid fi&#125;open_client_ui() &#123; if ! get_anyclient_ui_pid &amp;&gt; /dev/zero; then open "$ANYCONNECT_PATH" fi&#125;connect() &#123; # sudo /opt/cisco/anyconnect/bin/vpnagentd kill_anyconnect_ui$VPN_BIN -s &lt;&lt; EOFconnect $VPN_URL$USERNAME$PASSWORDyEOF open_client_ui&#125;main() &#123; if [[ -z "$USERNAME" || -z "$PASSWORD" || -z "$VPN_URL" ]]; then echo "Error: empty user info" exit 1 fi case "$1" in stop|s ) kill_anyconnect_ui ;; * ) connect esac&#125;main "$*" 把上面的内容保存到anyconnect文件中， 给文件加上执行权限 chmod +x anyconnect。现在直接执行 anyconnect 就可以连上 VPN 了。 建议文件路径为: $HOME/bin/anyconnect。（后面结合 Alfred Workflow 优化效率）。 如果有多个 URL，可以在 main 函数里面的 case 语句进行参数过滤，在此对 VPN_URL 赋值。实现连接任意的 VPN URL。 1234params ) VPN_URL="vpn.url.2" connect ;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162$HOME/bin/anyconnectCisco AnyConnect Secure Mobility Client (version 4.7.01076) .Copyright (c) 2004 - 2019 Cisco Systems, Inc. All Rights Reserved. &gt;&gt; state: Disconnected &gt;&gt; state: Disconnected &gt;&gt; notice: Ready to connect. &gt;&gt; registered with local VPN subsystem. &gt;&gt; The VPN client is not connected.Cisco AnyConnect Secure Mobility Client (version 4.7.01076) .Copyright (c) 2004 - 2019 Cisco Systems, Inc. All Rights Reserved. &gt;&gt; state: Disconnected &gt;&gt; state: Disconnected &gt;&gt; notice: Ready to connect. &gt;&gt; registered with local VPN subsystem.VPN&gt; connect your.vpn.url &gt;&gt; contacting host (your.vpn.url) for login information... &gt;&gt; notice: Contacting your.vpn.url. &gt;&gt; Please enter your username.Username: [your.name] your.name &gt;&gt; Please enter your password.Password: &gt;&gt; state: Connecting &gt;&gt; notice: Establishing VPN session... &gt;&gt; notice: The AnyConnect Downloader is performing update checks... &gt;&gt; notice: Checking for profile updates... &gt;&gt; notice: Checking for product updates... &gt;&gt; notice: Checking for customization updates... &gt;&gt; notice: Performing any required updates... &gt;&gt; notice: The AnyConnect Downloader updates have been completed. &gt;&gt; state: Connecting &gt;&gt; notice: Establishing VPN session... &gt;&gt; notice: Establishing VPN - Initiating connection... &gt;&gt; notice: Establishing VPN - Examining system... &gt;&gt; notice: Establishing VPN - Activating VPN adapter... &gt;&gt; notice: Establishing VPN - Configuring system... &gt;&gt; notice: Establishing VPN... &gt;&gt; state: ConnectedVPN&gt;[ VPN Connection commands ] connect disconnect hosts stats state block cancel[ Misc commands ] help version exit For help with a specific command, try: help &lt;command&gt; &gt;&gt; notice: Connected to your.vpn.url. &gt;&gt; state: ConnectedVPN&gt; goodbye... &gt;&gt; note: VPN Connection is still active. VPN 就已经连接成功了。 通过 Alfred Workflow 插件来连接安装这个 Alfred Workflow 即可直接通过 Alfred 来直接打开或者断开 VPN 连接： 没有任何参数时会连接 VPN ，输入参数 s|stop 就会断开 VPN 连接。]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>VPN</tag>
        <tag>anyConnect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git子模块的管理和使用]]></title>
    <url>%2Fgit%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[备忘速查git 子模块的管理和使用 添加子模块1git submodule add https://github.com/webkong/baby.git baby 查看子模块1git submodule 更新子模块更新项目内子模块到最新版本1git submodule update 更新子模块为远程项目的最新版本1$ git submodule update --remote 克隆包含子模块的项目克隆包含子模块的项目有二种方法：一种是先克隆父项目，再更新子模块；另一种是直接递归克隆整个项目。 克隆父项目1git clone https://github.com/webkong/baby.git baby 查看子模块12$ git submodule -e33f854d3f51f5ebd771a68da05ad0371a3c0570 baby 子模块前面有一个-，说明子模块文件还未检入（空文件夹）。 初始化子模块12$ git submodule initSubmodule 'baby' (https://github.com/webkong/baby.git) registered for path 'baby' 初始化模块只需在克隆父项目后运行一次。 更新子模块123456789$ git submodule updateCloning into 'baby'...remote: Counting objects: 151, done.remote: Compressing objects: 100% (80/80), done.remote: Total 151 (delta 18), reused 0 (delta 0), pack-reused 70Receiving objects: 100% (151/151), 1.34 MiB | 569.00 KiB/s, done.Resolving deltas: 100% (36/36), done.Checking connectivity... done.Submodule path 'baby': checked out 'e33f854d3f51f5ebd771a68da05ad0371a3c0570' 递归克隆整个项目1git clone https://github.com/webkong/baby.git baby --recursive 递归克隆整个项目，子模块已经同时更新了，一步到位。 修改子模块在子模块中修改文件后，直接提交到远程项目分支。 123$ git add .$ git ci -m "commit"$ git push origin HEAD:master 删除子模块删除子模块比较麻烦，需要手动删除相关的文件，否则在添加子模块时有可能出现错误同样以删除 baby 文件夹为例 删除子模块文件夹12$ git rm --cached baby$ rm -rf baby 删除.gitmodules 文件中相关子模块信息123[submodule "baby"] path = baby url = https://github.com/webkong/baby.git 删除.git/config 中的相关子模块信息12[submodule "baby"] url = https://github.com/webkong/baby.git 删除.git 文件夹中的相关子模块文件1$ rm -rf .git/modules/baby]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git子模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KaiOS Permissions Table]]></title>
    <url>%2Fkaios-permissions-table%2F</url>
    <content type="text"><![CDATA[KaiOS 权限列表 Name type:web type:privileged type:certified geolocation ! ! ! geolocation-noprompt ✕ ✕ ✓ mmi-test ✕ ✕ ✓ camera ✕ ! ✓ alarms ✓ ✓ ✓ tcp-socket ✕ ✓ ✓ udp-socket ✕ ✓ ✓ network-events ✕ ✕ ✓ contacts ✕ ✓ ✓ device-storage:apps ✕ ✕ ✓ device-storage:apps-storage ✕ ✕ ✓ device-storage:crashes ✕ ✕ ✓ device-storage:pictures ✕ ! ✓ device-storage:videos ✕ ! ✓ device-storage:music ✕ ! ✓ device-storage:sdcard ✕ ! ✓ sms ✕ ✕ ✓ speech-recognition ✕ ✓ ✓ telephony ✕ ✕ ✓ browser ✕ ✓ ✓ browser:universalxss ✕ ✓ ✓ browser:embedded-system-app ✕ ✕ ✓ bluetooth ✕ ✓ ✓ mobileconnection ✕ ✕ ✓ mobilenetwork ✕ ✓ ✓ power ✕ ✕ ✓ push ✓ ✓ ✓ serviceworker ✓ ✓ ✓ settings ✕ ✕ ✓ settings-clear ✕ ✕ ✕ softkey ✕ ✕ ✓ permissions ✕ ✕ ✓ phonenumberservice ✕ ✕ ✓ fmradio ✕ ✓ ✓ attention ✕ ✕ ✓ global-clickthrough-overlay ✕ ✓ ✓ moz-attention ✕ ✓ ✓ webapps-manage ✕ ✕ ✓ homescreen-webapps-manage ✕ ✓ ✓ backgroundservice ✕ ✕ ✓ desktop-notification ! ! ! networkstats-manage ✕ ✕ ✓ resourcestats-manage ✕ ✕ ✓ wifi-manage ✕ ✕ ✓ systemXHR ✕ ✓ ✓ voicemail ✕ ✕ ✓ idle ✕ ✕ ✓ time ✕ ✕ ✓ embed-apps ✕ ✕ ✓ embed-widgets ✕ ✓ ✓ storage ✓ ✓ ✓ background-sensors ✕ ✕ ✓ cellbroadcast ✕ ✕ ✓ audio-channel-normal ✓ ✓ ✓ audio-channel-content ✓ ✓ ✓ audio-channel-notification ✕ ✓ ✓ audio-channel-alarm ✕ ✓ ✓ audio-channel-system ✕ ✓ ✓ audio-channel-telephony ✕ ✕ ✓ moz-audio-channel-telephony ✕ ✓ ✓ audio-channel-ringer ✕ ✕ ✓ moz-audio-channel-ringer ✕ ✓ ✓ audio-channel-publicnotification ✕ ✕ ✓ volumemanager ✕ ✓ ✓ open-remote-window ✕ ✕ ✓ input ✕ ✓ ✓ input-manage ✕ ✕ ✓ wappush ✕ ✕ ✓ audio-capture ! ! ✓ audio-capture:3gpp ✕ ✓ ✓ audio-capture:3gpp2 ✕ ✓ ✓ nfc ✕ ✓ ✓ nfc-share ✕ ✕ ✓ nfc-manager ✕ ✕ ✓ nfc-hci-events ✕ ✓ ✓ speaker-control ✕ ✓ ✓ downloads ✕ ✕ ✓ video-capture ! ! ✓ feature-detection ✕ ✓ ✓ mobileid ✕ ! ! test-permission ! ! ✓ kaios-accounts ✕ ✕ ✓ kaios-accounts:service ✕ ! ✓ themeable ✕ ✕ ✓ settings:wallpaper.image ✕ ✓ ✓ engineering-mode ✕ ✕ ✓ tv ✕ ✕ ✓ before-after-keyboard-event ✕ ✕ ✓ presentation-device-manage ✕ ✕ ✓ requestsync-manager ✕ ✕ ✓ secureelement-manage ✕ ✓ ✓ inputport ✕ ✕ ✓ system-update ✕ ✕ ✓ presentation ✕ ✓ ✓ open-hidden-window ✕ ✕ ✓ moz-extremely-unstable-and-will-change-webcomponents ✕ ✓ ✓ system-app-only-audio-channels-in-app ✕ ✕ ✓ killswitch ✕ ✕ ✓ flip ✕ ✕ ✓ flashlight ✕ ✕ ✓ datacall ✕ ✕ ✓ keyboard-event-generator ✕ ✕ ✓ customization ✕ ✕ ✓ external-api ✕ ✓ ✓ engmode-extension ✕ ✕ ✓ cloud-authorization ✕ ✕ ✓ spatialnavigation-app-manage ✕ ✓ ✓ sandboxed-cookies ✓ ✓ ✓ MDN Link https://developer.mozilla.org/en-US/docs/Archive/B2G_OS/Firefox_OS_apps/App_permissions]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>KaiOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原来你是这样的[else if]]]></title>
    <url>%2F%E5%8E%9F%E6%9D%A5%E4%BD%A0%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84-else-if%2F</url>
    <content type="text"><![CDATA[前言最近几年一直以JavaScript最为第一语言开发，所以死扣JavaScript，突然发现else if原来不是我想象中的else if。并对自己之前的无知感到羞愧。 写过JavaScript的知道在写if条件语句的时候都会写成else if,而不是写成elseif。为啥中间要有空格呢？ 比如Python会写成elif、PHP写成elseif、Lua写成elseif。 经常在代码中出现的个人认为if条件语句是每个人的代码中都会出现。他们大概是这样的 12345678910function testNum(a) &#123; if (a &gt; 0) &#123; return "positive"; &#125; else &#123; return "NOT positive"; &#125;&#125;console.log(testNum(-5));// expected output: "NOT positive" 或者是这样的 123456789if (x &gt; 5) &#123; /* do the right thing */&#125; else if (x &gt; 50) &#123; /* do the right thing */&#125; else if (x &gt; 100) &#123; /* do the right thing */&#125; else &#123; /* do the right thing */&#125; 那么重点来了，JavaScript是没有 else if语句的。 啥 ？ 那我用的到底是什么。。。 不得不说的代码块我们有时候会这么写if 1if(a) dosomething(a) 很多JavaScript代码检查工具会建议应该加上{...} 1if(a) &#123;dosomething(a)&#125; 同样对于else，在只包含单条语句的时候可以省略代码块。 所以实际上，上面的else if代码实际是这样的 12345678910111213if (x &gt; 5) &#123; /* do the right thing */&#125; else &#123; if (x &gt; 50) &#123; /* do the right thing */ &#125; else &#123; if(x &gt; 100 )&#123; /* do the right thing */ &#125;else&#123; /* do the right thing */ &#125; &#125;&#125; 当我们去掉else 的 {...}去掉 1234567891011if (x &gt; 5) &#123; /* do the right thing */&#125; else if (x &gt; 50) &#123; /* do the right thing */ &#125; else if(x &gt; 100 )&#123; /* do the right thing */ &#125;else&#123; /* do the right thing */ &#125; 然后再把 else 和 if 弄到一行。 123456789if (x &gt; 5) &#123; /* do the right thing */&#125; else if (x &gt; 50) &#123; /* do the right thing */&#125; else if(x &gt; 100 )&#123; /* do the right thing */&#125;else&#123; /* do the right thing */&#125; 就是我们经常写的else if。 所以换句话说，else if其实只是else里面单独的if语句，去掉了{}，省略了一层代码缩进。 我们自己发明的用法，而这并不是JavaScript语法的范畴。 多说两句{...}大括号，不仅仅只是大括号。我们在很单纯的使用大括号的时候，大概是： 定义一个对象字面量1234var foo = &#123; key: 1, value: bar()&#125; 我们把大括号赋值给了一个变量foo,所以现在{...}是一个值。 打上一个label当我把var foo =去掉，单纯的剩下一个{...} 123&#123; foo:bar()&#125; 这种写法在JavaScript多见，但他又是完全合法的。{...}在这里只是一个普通的代码块。那么里面的foo:bar()为啥也是合法的呢？ 这种写法是不提倡的写法，也是JavaScript不常用的特性，“标签语法”。换句话说，给一条语句加上标签，可以配合break / continue来实现goto的效果。 1234567891011foo: &#123; console.log('face'); break foo; console.log('this will not be executed');&#125;console.log('swap');// this will log:// "face"// "swap" 有兴趣的同学可以去MDN查阅https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label other 当{...}与let一起使用的时候就特别有用，可以强制劫持块的作用域。 123456&#123; console.log(bar); //ReferenceError: bar is not defined let bar = 'webkong' console.log(bar); // webkong&#125;console.log(bar) //ReferenceError: bar is not defined 最后JavaScript是一本优秀的语言，只学其中一部分很容易，全面掌握规则却很难。她有简单易用的语法，同时语言机制又十分复杂和微妙。回顾这几年，后悔的是没有给JavaScript足够的耐心和时间，把她当成一门真正的变成语言来探索和学习。很多人可能跟我一样，最开始使用她，用的多了，才开始的回过头来学习。ES标准的不断演进，概念语法上面的不断发展，让我们期待JavaScript的未来会更有作为。 有人会说，java也是写else if呢…，go好像也是呢？ 那我不管，我只想写JS。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何优雅的使用mock server]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8mock-server%2F</url>
    <content type="text"><![CDATA[事出有因昨天跟同事讨论我们在用的rap2(一个集接口编写和mock server的开源项目)和刚上线了一个easy-mock的server，到底哪个好用。 我们主要讨论的点有个两个： 接口的一致性、 编码的无侵入性。 背景自从前后端分离后，完成前后端的分工之后，大家就可以各司其职，并行开发。前后端的协议标准就是接口文档。前端的所有逻辑和展现全部依赖接口文档中规定的数据结构。所以接口文档就变成了开发过程的重中之重。 当然有一份文档也是不够的，前端开发页面逻辑调试、测试同学测试接口、接口文档不断的更新、接口复杂的返回情况等诸多问题，这就需要有一个Mock Server来帮忙。 更多的关于Mock内容的请大家自行Google了解不再赘述。 接口的一致性接口文档，是整个开发过程中的约定和依据，所以同步更新文档也成为关键一环。 之前的办法使用markdown维护一个文档，放到wiki来管理，每次更新到wiki上面，大家来阅读。如果要Mock数据（easy-mock或者其他mock server），相关人员修改mock字段，更新完毕。 优雅的做法在线编辑接口，实时保存，同步更新。例如采用Rap2（支持JSON复制，支持接口的移动复制），保存后就是接口文档，所有人实时更新，同时Mock数据自动更新。 编码的无侵入性 Mock 对代码的侵入越小，我们维护和开发的成本也越低。以 Vue-cli2.x生成的项目为例： 在工程中的config目录dev.env.js，配置开发环境下API数据来源地址 1234567...module.exports = merge(prodEnv, &#123; NODE_ENV: '"development"', ENV_CONFIG: '"dev"', // BASE_API: '"dev server"', BASE_API: '"http://rap2.taobao.org:8080/app/mock/39"', // mock server&#125;) 这样我们在开发过程中，用到axios，只需要根据不同环境编写一次代码即可 1234const service = axios.create(&#123; baseURL: process.env.NODE_ENV === 'production' ? process.env.BASE_API : '/api', ...&#125;); 从Mock数据切换到Dev Server的API只需要注释一行配置文件代码，无需修改项目源代码。非常友好。 这时候我们再看easy-mock 跟rap2生成的Mock Url：12345http://easy-mock.com/mock/5c08e554bd9f9c3a01c5abf6/api/info=&gt; host/mock/projectId/:pathhttp://rap2.taobao.org:8080/app/mock/45/GET/api/info=&gt; host/app/mock/:repositoryId/:method/:path ps:后来发现rap2的url可以不带method，但是就是不能使用restful API这种根据method区分的接口了。 从生成的url来看，rap2中有:method的变量，若是要无缝切换需要更多的工作。无法直接替换BASE_API。如果在代码里拼接会有很大的代码侵入性。 所以考虑在工程层面进行优化： 在工程目录config目录中index.js中，可以设置代理来统一处理:method变量。在proxyTable对象中加入bypass方法，对每个通过代理的接口，处理request url成为一个合格的rap2 mock的url。 12345678910111213141516171819module.exports = &#123; dev: &#123; ... proxyTable: &#123; '/api': &#123; target: config.BASE_API.substring(1, config.BASE_API.length - 1), changeOrigin: true, pathRewrite: &#123; '^/api': '/' &#125;, bypass: function (req, res, proxyOptions) &#123; if (proxyOptions.target.indexOf('mock') !== -1) &#123; const path = req.url.replace(proxyOptions.context, proxyOptions.context + '/' + req.method); // path =&gt; /api/GET/path req.url = path; &#125; &#125; &#125; &#125;, 这样就能无侵入性的使用rap2了。 结论从接口文档的一致性和编码的无侵入性来看，rap2可能更优一点，但是rap2毕竟是一个年轻的开源项目，很多机制并不完善。从去年年初使用rap2，最近升级到新版本数据库表结构还要做映射调整，适合喜欢折腾的人。这样easy-mock的稳定性优势就值得考虑。 在我看来，未来的Mock Server不单单只是一个Mock，肯定是集 接口编写 + 自动Mock于一身的，还有一些类似接口字段校验的辅助功能。 个人还是很看好rap2的，毕竟从rap1重构的项目，有一定的使用背景，重构应该能出更好的开源项目。 再次感谢开源项目对开发者带来的便利。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>mock</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Understanding PWA]]></title>
    <url>%2Funderstanding-pwa%2F</url>
    <content type="text"><![CDATA[What is pwa?Progressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。 PWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。 技术依赖: Service Worker Web storage（IndexedDB, Caches） Fetch Promises PWA advantagesPWA 应用应该是： discoverable 可发现, 可以被识别为应用程序，通过搜索引擎容易找到 installable 可安装，可用于移动设备，添加到用户主屏幕 linkable 可连接 通过 URL 共享，无需复杂安装 network independent 网络独立 可工作在离线或者低速的网络环境 progressive 渐进增强 适用于所有用户，支持的浏览器可以体验更好，不支持的浏览器访问不会邮到影响 re-engageable 再参与 通过提醒，让用户容易进行参与 responsive 响应式 适合任何形式的设备 safe 安全 内容传递机制可以防止监听，并保证内容不被篡改 Progressive web app advantages. To find out how to implement PWAs, consult the guides listed in the below section. Progressive(渐进性)强调是渐进式的，改造过程中可以逐步进行，降低站点的改造成本，新技术支持程度不完整，跟着新技术逐步进化。PWA 涉及到从安全、性能和体验等方面的优化，可以考虑以下步骤： 第一步，应该是安全，将全站 HTTPS 化，因为这是 PWA 的基础，没有 HTTPS，就没有 Service Worker 第二步，应该是 Service Worker 来提升基础性能，离线提供静态文件，把用户首屏体验提升上来 第三步，App Manifest，这一步可以和第二步同时进行 后续，再考虑其他的特性，离线消息推送等 支持程度/覆盖率 Service WorkerService Worker，是一个浏览器和 network 之间的代理，解决的是如何缓存页面的资产和如果在脱机状态下仍然正常工作的问题。独立于当前网页进程，有自己独立的 worker context，没有对于 DOM 的访问权限，与传统的 API 不同，它是非阻塞的，并基于 promise 方法在就绪时返回结果。它不但只是离线能力，还有消息通知、添加桌面图标等功能。 前提条件 HTTPS， 由于 Service Worker 要求 HTTPS 的环境，我们可以借助 github page 进行学习调试。一般浏览器允许调试 Service Worker 的时候 host 为 localhost。 Service Worker 的缓存机制是依赖 Cache API实现的 依赖 HTML5 fetch API 依赖 Promise 实现 LifecycleA more detailed introduction to The Service Worker Lifecycle A service worker goes through three steps in its lifecycle: Registration 注册 Installation 安装 Activation 激活 1. 注册在 install Server Worker 之前，要在主进程 JavaScript 代码里面注册它，注册是为了告诉浏览器我们的 Servic e Worker 文件是哪个，然后在后台，Service Worker 就开始安装激活。 注册代码可以放到 html 文件的&lt;script&gt;&lt;/script&gt;标签中，也可以单独放到main.js文件在引入 html 文件中。 123456789if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('/service-worker.js') .then(function(registration) &#123; console.log('Registration successful, scope is:', registration.scope); &#125;) .catch(function(error) &#123; console.log('Service worker registration failed, error:', error); &#125;);&#125; 代码中，先检测是浏览器是不是支持 Service Worker，如果支持，就用navigator.serviceWorker.register注册，如果成功，就会在 promise 的 .then 里面得到registration. service-worker.js 文件就是我们要编写 Service Worker 功能的文件。 注册时，还可以指定可选参数 scope，scope 是 Service Worker 可以以访问到的作用域，或者说是目录。 123navigator.serviceWorker.register('/service-worker.js', &#123; scope: '/app/'&#125;); 代码中指定作用域是/app/,意思就是说，Service Workder 可以控制的 path 是类似于app /app/home/ /app/abbout/等内部目录，而不能访问 / ‘/images’等 /app更上一次层的 path。 如果 Service Worker 已经安装了，再次注册会返回当前活动的 registration 对象。 chrome 浏览器已经很好的支持了 Service Worker 的 debug 功能，可在浏览器输入chrome://inspect/#service-workers查看是否注册成功了。或者在控制台的 application 选项查看。 2.安装install 事件绑定在 Service Worker 文件中，当安装成功后，install 事件就会被触发。一般我们会在 install 事件里面进行缓存的处理，用到之前提到的Cahce API,它是一个 Service Worker 上的全局对象[5],可以缓存网络相应的资源，并根据他们的请求生成 key，这个 API 和浏览器标准的缓存工作原理相似，但是只是针对自己的 scope 域的，缓存会一直存在，知道手动清楚或者刷新。 12345678910111213141516var cacheName = 'cachev1'self.addEventListener('install', function(event) &#123; event.waitUntil( caches.open(cacheName).then(function(cache) &#123; return cache.addAll( [ '/css/bootstrap.css', '/css/main.css', '/js/bootstrap.min.js', '/js/jquery.min.js', '/offline.html' ] ); &#125;) );&#125;); 新增 install 的监听器，并用event.waitUntil()来确保，Service Worker 不会在waitUntil()执行完成之前安装完成。 使用caches.open()创建一个 cachev1 的新缓存，返回一个缓存的 promise 对象，当它 resolved 时候，我们在 then 方法里面用caches.addAll来添加想要缓存的列表，列表是一个数组，里面的 URL 是相对于 origin 的。 如果 promise 被 rejected，安装失败，我们并没有 catch，所以并不会做任何事情，也可以修改代码，加上重新注册的代码。 当安装完成时，Service Worker 就会激活成功。 3. 激活当 Service Worker 安装完成后并进入激活状态，会触发 activate 事件。通过监听 activate 事件你可以做一些预处理，如对旧版本的更新、对无用缓存的清理等。 Service Worker 如何更新呢？service-worker.js控制着页面资源和请求的缓存，如果 js 内容有更新，当访问网站页面时浏览器获取了新的文件，逐字节比对 js 文件发现不同时它会认为有更新启动 更新算法，于是会安装新的文件并触发 install 事件。但是此时已经处于激活状态的旧的 Service Worker 还在运行，新的 Service Worker 完成安装后会进入 waiting 状态。直到所有已打开的页面都关闭，旧的 Service Worker 自动停止，新的 Service Worker 才会在接下来重新打开的页面里生效。 如果希望在有了新版本时，所有的页面都得到及时自动更新怎么办呢？可以在 install 事件中执行 self.skipWaiting() 方法跳过 waiting 状态，然后会直接进入 activate 阶段。接着在 activate 事件发生时，通过执行 self.clients.claim() 方法，更新所有客户端上的 Service Worker。 123456789101112131415161718192021222324// 安装阶段跳过等待，直接进入 activeself.addEventListener('install', function (event) &#123; event.waitUntil(self.skipWaiting());&#125;);self.addEventListener('activate', function (event) &#123; event.waitUntil( Promise.all([ // 更新客户端 self.clients.claim(), // 清理旧版本 caches.keys().then(function (cacheList) &#123; return Promise.all( cacheList.map(function (cacheName) &#123; if (cacheName !== 'cachev1') &#123; return caches.delete(cacheName); &#125; &#125;) ); &#125;) ]) );&#125;); 当 js 文件可能会因为浏览器缓存问题，当文件有了变化时，浏览器里还是旧的文件。这会导致更新得不到响应。如遇到该问题，可尝试这么做：在 Web Server 上添加对该文件的过滤规则，不缓存或设置较短的有效期。 或者手动调用update()来更新 1234navigator.serviceWorker.register('/service-worker.js').then(reg =&gt; &#123; // sometime later… reg.update();&#125;); 可以结合 localStorage 来使用，不必每次加载更新 123456789var version = 'v1';navigator.serviceWorker.register('/service-worker.js').then(function (reg) &#123; if (localStorage.getItem('sw_version') !== version) &#123; reg.update().then(function () &#123; localStorage.setItem('sw_version', version) &#125;); &#125;&#125;); 示意图 每个状态都会有ing,进行态。 Web Storage选择正确的存储机制对于本地设备存储和基于云的服务器存储都非常重要。 良好的存储引擎可确保以可靠的方式保存信息，并减少带宽和提升响应能力。正确的存储缓存策略是实现离线移动网页体验的核心构建基块。 存储的类别，存储的持久化，浏览器支持情况等原因，如何更高效的存储是我们讨论的重点。 资料Web Storage Overview Using Cache API Offine Storage for PWA Best Practices for Using IndexedDB Inspect and Manage Storage, Databases, and Caches cache API 和 IndexedDB针对于离线存储数据,建议可以有: 对于网址可寻址的资源，使用Cache API (Service Worker 的一部分) 对于所有其他数据，使用[IndexedDB}(https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) (就有一个 promise 包装器) 基本原理 上面的两个 API 都是异步的（IndexedDB 是基于事件的，而 Cache API 是基于 Promise 的）。他们可以与web Workers windows service workers一起使用。IndexedDB 基本可以在所有浏览器环境使用（参看上面的 CanIUse），Service Wokers 和 Cahce API 的支持情况，可以通过上面的图看到，已经支持 Chrome，Firefox，Opera。IndexedDB 的 Promise 包装器隐藏了 IndexedDB 库自带的一些强大但同时非常复杂的 machinery（例如：事务处理 transactions，架构版本 schema versioning）。IndexedDB 将支持 observers，这个特性可以轻松实现标签之间的同步。 对于 PWA，我们可以缓存静态资源，从而使用 Cache API 编写的应用 Application Shell（JS/CSS/HTML 文件），并从 IndexedDB 填充离线页面数据。 对于 Web Storage（LocalStorage/SessionStorage）是同步的，不支持 Web worker 线程，并且有大小和类型（仅限字符串）的限制。 添加到桌面允许将站点添加至主屏幕，是 PWA 提供的一项重要功能。虽然目前部分浏览器已经支持向主屏幕添加网页快捷方式以方便用户快速打开站点，但是 PWA 添加到主屏幕的不仅仅是一个网页快捷方式，它将提供更多的功能，让 PWA 具有更加原生的体验。 PWA 添加至桌面的功能实现依赖于 manifest.json。 为了实现 PWA 应用添加至桌面的功能，除了要求站点支持 HTTPS 之外，还需要准备 manifest.json 文件去配置应用的图标、名称等信息。举个例子，一个基本的 manifest.json 应包含如下信息： 1234567891011121314151617&#123; "name": "Easyify Docs", "short_name": "Easyify Docs", "start_url": "/", "theme_color": "#FFDF00", "background_color": "#FFDF00", "display":"standalone", "description": "A compilation tools for FE, built with webpack4.x, compile faster and smart, make work easier.", "icons": [ &#123; "src": "./_assets/icons/32.png", "sizes": "32x32", "type": "image/png" &#125; ], ... &#125; 使用 link 标签将 manifest.json 部署到 PWA 站点 HTML 页面的头部，如下所示： 1&lt;link rel="manifest" href="path-to-manifest/manifest.json"&gt; 参数解释： 1234567891011121314151617181920212223242526272829303132333435name: &#123;string&#125; 应用名称，用于安装横幅、启动画面显示short_name: &#123;string&#125; 应用短名称，用于主屏幕显示icons: &#123;Array.&lt;ImageObject&gt;&#125; 应用图标列表 src: &#123;string&#125; 图标 url type &#123;string=&#125; 图标的 mime 类型，非必填项，该字段可让浏览器快速忽略掉不支持的图标类型 sizes &#123;string&#125; 图标尺寸，格式为widthxheight，宽高数值以 css 的 px 为单位。如果需要填写多个尺寸，则使用空格进行间隔，如"48x48 96x96 128x128"start_url: &#123;string=&#125; 应用启动地址scope: &#123;string&#125; 作用域 // scope 应遵循如下规则： //如果没有在 manifest 中设置 scope，则默认的作用域为 manifest.json 所在文件夹； //scope 可以设置为 ../ 或者更高层级的路径来扩大PWA的作用域； //start_url 必须在作用域范围内； //如果 start_url 为相对地址，其根路径受 scope 所影响； //如果 start_url 为绝对地址（以 / 开头），则该地址将永远以 / 作为根地址；background_color: &#123;Color&#125; css色值 可以指定启动画面的背景颜色。display: &#123;string&#125; 显示类型 //fullscreen 应用的显示界面将占满整个屏幕 //standalone 浏览器相关UI（如导航栏、工具栏等）将会被隐藏 //minimal-ui 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同 //browser 浏览器模式，与普通网页在浏览器中打开的显示一致orientation: string 应用显示方向 //orientation属性的值有以下几种： //landscape-primary //landscape-secondary //landscape //portrait-primary //portrait-secondary //portrait //natural //anytheme_color: &#123;Color&#125; // css色值theme_color 属性可以指定 PWA 的主题颜色。可以通过该属性来控制浏览器 UI 的颜色。比如 PWA 启动画面上状态栏、内容页中状态栏、地址栏的颜色，会被 theme_color 所影响。related_applications: Array.&lt;AppInfo&gt; 关联应用列表 可以引导用户下载原生应用 platform: &#123;string&#125; 应用平台 id: &#123;string&#125; 应用id Push Notifications我们都是通知就是在我们设备上弹出的消息。通知可以是本地触发的，也可以是服务器推送的，而且我们的应用当时并没有运行。消息推送可以使 App 的更新提醒，也可能是我们感兴趣的内容。 当我们的 web 可以实现 push 的时候，web 的体验就里 Native APP 更近一步了。 Push Notifications 由两个 API 构成： Notifications API 用来显示系统的通知 Push API 用来处理 Server 下发的 push 消息 这两个 API 都是建立在在 Service Worker API 基础上的，Service Worker 在后台响应推送消息时间，并把他们传递给应用。 Notification 获取许可在创建通知之前，应该先获取用户的许可： 12345// main.jsNotification.requestPermission(function(status) &#123; console.log('Notification permission status:', status); //status 会有三个取值default granted denied 分别代表： 默认值（每次访问页面都询问）、 允许、拒绝&#125;); 添加通知获取到用户的许可之后，就可以通过 showNotification()方法来限制主应用程序的通知。 12345678// main.jsfunction displayNotification() &#123; if (Notification.permission == 'granted') &#123; navigator.serviceWorker.getRegistration().then(function(reg) &#123; reg.showNotification('Hello world!'); &#125;); &#125;&#125; 要注意showNotification，在 Service Woker 注册对象上调用该方法。将在活动 Service Worker 上创建通知，以便监听与通知交互触发的事件。 showNotification方法有可选项参数options，用于配置通知。 1234567891011121314151617181920212223// main.jsfunction displayNotification() &#123; if (Notification.permission == 'granted') &#123; navigator.serviceWorker.getRegistration().then(function(reg) &#123; var options = &#123; body: 'Here is a notification body!', // 对通知添加描述 icon: 'images/example.png', // 添加一个icon图像 vibrate: [100, 50, 100], // 指定通知的电话振动模式，手机将振动100ms，暂停50ms，再次振动100ms data: &#123; dateOfArrival: Date.now(), primaryKey: 1 &#125;, // 给通知添加自定义数据，当监听到通知的时候，可以捕获到这些数据，方便使用。 actions: [ &#123;action: 'explore', title: 'Explore this new world', icon: 'images/checkmark.png'&#125;, &#123;action: 'close', title: 'Close notification', icon: 'images/xmark.png'&#125;, ] // 自定义的操作 &#125;; reg.showNotification('Hello world!', options); &#125;); &#125;&#125; 监听事件用户收到通知之后，通过对通知的操作，就会触发监听的 Notifications 的相关事件，比如在关闭通知的时候就会有notificationclose事件。 12345678910111213// service-worker.jsself.addEventListener('notificationclick', function(e) &#123; var notification = e.notification; var primaryKey = notification.data.primaryKey; var action = e.action; if (action === 'close') &#123; notification.close(); &#125; else &#123; clients.openWindow('http://www.example.com'); notification.close(); &#125;&#125;); Push 通知操作要结合 push，才能实现与用户的交互，主动通知、提醒用户 Push service每个浏览器都有一个push service(推送服务),当用户授权当前网站的 push 权限的时候，就可以将当前网站订阅到浏览器的push service。这就会创建一个订约对象，其中包含推送服务的 endpoint 和公钥（keys）。当下发 push 消息的时候，就会发送到 endpoint 这个 URL，并用公钥进行加密，push service就会发送到正确的客户端。 推送服务如何知道将消息发送到哪个客户端？端点 URL 包含唯一标识符。此标识符用于路由您发送到正确设备的消息，并在浏览器处理时标识应处理请求的 Service Worker。 推送通知和 Service Worker 是匹配工作的，所以要求推送通知也必须是 HTTPS，这就确保了服务器和 push service 之间通信是安全的，并且从 push service 到用户也是安全的。 但是，HTTPS 不能确保 push service 本身是安全的。我们必须确保从服务器发送到客户端的数据不会被任何第三方篡改或直接检查。所以必须加密服务器上的消息。 整个发送接收展示的过程 在客户端: 1.订阅推送服务 2.将订阅对象发送到服务器 在服务器: 1.生成给用户下发的数据 2.使用用户的公钥加密数据 3.使用加密数据的有效负载将数据发送的 endpoint URL 消息将路由到用户的设备。唤醒浏览器，找到正确的 Service Worker 并调用推送事件。 1.在推送事件中接收消息数据(如果有) 2.在推送事件中执行自定义逻辑 3.显示通知 处理推送事件当支持推送消息的浏览器收到消息时，它会向 Service Worker 发送一个push事件。我们可以在 Service Worker 中创建一个 push事件监听器来处理消息： 12345678910111213141516171819202122// service-worker.jsself.addEventListener('push', function(e) &#123; var options = &#123; body: 'This notification was generated from a push!', icon: 'images/example.png', vibrate: [100, 50, 100], data: &#123; dateOfArrival: Date.now(), primaryKey: '2' &#125;, actions: [ &#123;action: 'explore', title: 'Explore this new world', icon: 'images/checkmark.png'&#125;, &#123;action: 'close', title: 'Close', icon: 'images/xmark.png'&#125;, ] &#125;; e.waitUntil( self.registration.showNotification('Hello world!', options) );&#125;); 与之前不同的地方就是，这里监听的是 push 事件，之前是 notification 事件，并且，这里用了 event.waitUntil 方法来延长 push 事件的生命周期，到 showNotification 异步操作执行完成。 订阅推送通知在发送推送消息之前，我们必须首先订阅推送服务。订阅返回订阅对象或者是一个subscription。它是整个过程中很关键一个部分，我们才能知道 push 发送到哪里。 123456789101112131415161718192021222324252627282930313233343536373839// main.js//检查是否订阅了 if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('sw.js').then(function (reg) &#123; console.log('Service Worker Registered!', reg); reg.pushManager.getSubscription().then(function (sub) &#123; if (sub === null) &#123; // Update UI to ask user to register for Push console.log('Not subscribed to push service!'); &#125; else &#123; // We have a subscription, update the database console.log('Subscription object: ', sub); &#125; &#125;); &#125;) .catch(function (err) &#123; console.log('Service Worker registration failed: ', err); &#125;); &#125; function subscribeUser() &#123; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.ready.then(function (reg) &#123; reg.pushManager.subscribe(&#123; userVisibleOnly: true &#125;).then(function (sub) &#123; console.log('Endpoint URL: ', sub.endpoint); &#125;).catch(function (e) &#123; if (Notification.permission === 'denied') &#123; console.warn('Permission for notifications was denied'); &#125; else &#123; console.error('Unable to subscribe to push', e); &#125; &#125;); &#125;) &#125; &#125; Web 推送协议Web Push 协议是发送发往浏览器的推送消息的正式标准。它描述了如何创建推送消息，加密推送消息并将其发送到推送消息传递平台的结构和流程。该协议抽象出用户具有哪个消息传递平台和浏览器的细节。 Web Push 协议很复杂，但我们不需要了解所有细节。浏览器自动负责使用推送服务订阅用户。作为开发人员，我们的工作是获取订阅令牌，提取 URL 并向那里发送消息。 123456&#123;"endpoint":"https://fcm.googleapis.com/fcm/send/dpH5lCsTSSM:APA91bHqjZxM0VImWWqDRN7U0a3AycjUf4O-byuxb_wJsKRaKvV_iKw56s16ekq6FUqoCF7k2nICUpd8fHPxVTgqLunFeVeB9lLCQZyohyAztTH8ZQL9WCxKpA6dvTG_TUIhQUFq_n","keys": &#123; "p256dh":"BLQELIDm-6b9Bl07YrEuXJ4BL_YBVQ0dvt9NQGGJxIQidJWHPNa9YrouvcQ9d7_MqzvGS9Alz60SZNCG3qfpk=", "auth":"4vQK-SvRAN5eo-8ASlrwA==" &#125;&#125; 通常用 VSPID 身份验证来识别身份。直接上一个例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//main.js var endpoint; var key; var authSecret; // We need to convert the VAPID key to a base64 string when we subscribe function urlBase64ToUint8Array(base64String) &#123; const padding = '='.repeat((4 - base64String.length % 4) % 4); const base64 = (base64String + padding) .replace(/\-/g, '+') .replace(/_/g, '/'); const rawData = window.atob(base64); const outputArray = new Uint8Array(rawData.length); for (let i = 0; i &lt; rawData.length; ++i) &#123; outputArray[i] = rawData.charCodeAt(i); &#125; return outputArray; &#125; function determineAppServerKey() &#123; var vapidPublicKey = 'BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY'; return urlBase64ToUint8Array(vapidPublicKey); &#125; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('sw.js').then(function (registration) &#123; return registration.pushManager.getSubscription() .then(function (subscription) &#123; if (subscription) &#123; // We already have a subscription, let's not add them again return; &#125; return registration.pushManager.subscribe(&#123; userVisibleOnly: true, applicationServerKey: determineAppServerKey() &#125;) .then(function (subscription) &#123; var rawKey = subscription.getKey ? subscription.getKey('p256dh') : ''; key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : ''; var rawAuthSecret = subscription.getKey ? subscription.getKey('auth') : ''; authSecret = rawAuthSecret ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : ''; endpoint = subscription.endpoint; return fetch('http://localhost:3111/register', &#123; method: 'post', headers: new Headers(&#123; 'content-type': 'application/json' &#125;), body: JSON.stringify(&#123; endpoint: subscription.endpoint, key: key, authSecret: authSecret, &#125;), &#125;) &#125;); &#125;); &#125;).catch(function (err) &#123; // registration failed :( console.log('ServiceWorker registration failed: ', err); &#125;); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// server.jsconst webpush = require('web-push');const express = require('express');var bodyParser = require('body-parser');var path = require('path');const app = express();// Express setupapp.use(express.static('public'));app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; // to support URL-encoded bodies extended: true&#125;));function saveRegistrationDetails(endpoint, key, authSecret) &#123; // Save the users details in a DB&#125;webpush.setVapidDetails( 'mailto:contact@deanhume.com', 'BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY', 'p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0');// Send a messageapp.post('/sendMessage', function (req, res) &#123; var endpoint = req.body.endpoint; var authSecret = req.body.authSecret; var key = req.body.key; const pushSubscription = &#123; endpoint: req.body.endpoint, keys: &#123; auth: authSecret, p256dh: key &#125; &#125;; var body = 'Breaking News: Nose picking ban for Manila police'; var iconUrl = 'https://raw.githubusercontent.com/deanhume/progressive-web-apps-book/master/chapter-6/push-notifications/public/images/homescreen.png'; webpush.sendNotification(pushSubscription, JSON.stringify(&#123; msg: body, url: 'http://localhost:3111/article?id=1', icon: iconUrl, type: 'actionMessage' &#125;)) .then(result =&gt; &#123; console.log(result); res.sendStatus(201); &#125;) .catch(err =&gt; &#123; console.log(err); &#125;);&#125;);// Register the userapp.post('/register', function (req, res) &#123; var endpoint = req.body.endpoint; var authSecret = req.body.authSecret; var key = req.body.key; // Store the users registration details saveRegistrationDetails(endpoint, key, authSecret); const pushSubscription = &#123; endpoint: req.body.endpoint, keys: &#123; auth: authSecret, p256dh: key &#125; &#125;; var body = 'Thank you for registering'; var iconUrl = '/images/homescreen.png'; webpush.sendNotification(pushSubscription, JSON.stringify(&#123; msg: body, url: 'https://localhost:3111', icon: iconUrl, type: 'register' &#125;)) .then(result =&gt; &#123; console.log(result); res.sendStatus(201); &#125;) .catch(err =&gt; &#123; console.log(err); &#125;);&#125;);// The serverapp.listen(3111, function () &#123; console.log('Example app listening on port 3111!')&#125;); 后面再详细说整个 push 过程。也可以看先 Google 给出的教程描述https://developers.google.com/web/ilt/pwa/introduction-to-push-notifications#push_api 参考Progressive Web Apps Training App Shell Service Workers: an Introduction MDN Progressive web apps MDN WorkerGlobalScope [1] The Service Worker Lifecycle W3C IndexedDB API 3.0 Introduction to Push Notifications]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>PWA</tag>
        <tag>渐进式Web应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18.04 grub error]]></title>
    <url>%2Fubuntu18-04-grub-error%2F</url>
    <content type="text"><![CDATA[场景 1： 单 Ubuntu 系统安装， 整个磁盘已经格式化， 安装到最后的时候，会出现无法安装引导到/target/,导致安装失败场景 2： 安装成功，但是重启进入 grub rescue场景 3： 安装成功，重启进去黑屏光标界面，无法正常重启 解决经历 使用 boot-repair 进行引导修复，未成功 在 grub rescue 模式情况下手动 set 12345grub rescue&gt;lsgrub rescue&gt;ls (hd0,gpt2)/boot/grubgrub rescue&gt;set root=(hd0,gpt2)grub rescue&gt;set prefix=(hd0,gpt2)/boot/grubgrub rescue&gt;insmod /boot/grub/normal.mod 报错，仍未成功 尝试重新安装，选择抹掉整个磁盘自动安装，重启仍然失败 尝试手动分区 12345/ 10G/tmp 10G/home 400G/boot 200MSWAP 4G 自动安装后仍然失败grub-efi-amd64-signed package failed to install into /target/ 5.]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>grub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fetch新鲜的Ajax]]></title>
    <url>%2Ffetch%E6%96%B0%E9%B2%9C%E7%9A%84ajax%2F</url>
    <content type="text"><![CDATA[老骥伏枥，志在千里 Fetch 是一个现代的概念, 等同于 XMLHttpRequest。它提供了许多与XMLHttpRequest相同的功能,但被设计成更具可扩展性和高效性。 简而言之Fetch 的核心在于对 HTTP 接口的抽象，包括 Request，Response，Headers，Body，以及用于初始化异步请求的 global fetch。得益于 JavaScript 实现的这些抽象好的 HTTP 模块，其他接口能够很方便的使用这些功能。 除此之外，Fetch 还利用到了请求的异步特性——它是基于 Promise 的。 说白了，Fetch是从后台获取数据的一种更优的解决方案，甚至可以说是XMLHttpRequest的替代方案。 但是fetch与ajax或者axios库有不同的点：1.当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 这个特点对于restfulAPI具有很好的交互。 2.默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。 支持程度目前只有谷歌和火狐浏览器的最新版本支持 demo1234567fetch('http://example.com/example.json') .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); &#125;); 1234567891011121314fetch(url, &#123; body: JSON.stringify(data), // must match 'Content-Type' header cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached credentials: 'same-origin', // include, same-origin, *omit headers: &#123; 'user-agent': 'Mozilla/4.0 MDN Example', 'content-type': 'application/json' &#125;, method: 'POST', // *GET, POST, PUT, DELETE, etc. mode: 'cors', // no-cors, cors, *same-origin redirect: 'follow', // manual, *follow, error referrer: 'no-referrer', // *client, no-referrer &#125;) .then(response =&gt; response.json()) // parses response to JSON 发送带凭据的请求为了让浏览器发送包含凭据的请求（即使是跨域源），要将credentials: ‘include’添加到传递给 fetch()方法的init对象。123fetch('https://example.com', &#123; credentials: 'include' &#125;) 如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加credentials: ‘same-origin’。 // The calling script is on the origin ‘https://example.com‘123fetch('https://example.com', &#123; credentials: 'same-origin' &#125;) 要改为确保浏览器不在请求中包含凭据，请使用credentials: ‘omit’。123fetch('https://example.com', &#123; credentials: 'omit' &#125;) https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>Fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript常用数学方法]]></title>
    <url>%2Fjavascript%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&gt; floor()1234// 向下取整Math.floor(2.1) // 2Math.floor(2.6) // 2Math.floor(-2.6) // -3 ceil()1234// 向上取整Math.ceil(2.1) // 3Math.ceil(2.6) // 3Math.ceil(-2.1) // -2 round()1234Math.round(3.14) //3Math.round(3.5) //4Math.round(-3.14) //-3Math.round(-3.5) //-3]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用规范]]></title>
    <url>%2Fgit%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[针对 git 提交，做出如下规范，避免出现提交描述不清楚，回溯困难。 1.必须先拉取代码再提交代码1234git pull#或者git fetchgit rebase 避免出现不必要的自动merge，和冲突代码 2.提交代码原则(粒度)项目代码稳定之后(总体架构完成)，每次提交都要考虑提交的粒度问题，尽量做到 baby step 没有关联的代码不能一次 commit 提交 关联代码一次提交；若内容很多，可内部分层，依次提交 可以根据当前代码模块情况处理。 3.必须提交 Commit Message 没有 Commit Message 不允许提交 不在 git commit 上增加 -m &lt;msg&gt; 或 --message=&lt;msg&gt; 参数，而单独写提交信息 不允许 1git commit -m "Fix login bug" 推荐 angular 的 GitHub 的 Commit 123456Fix(filterFilter): fix filtering using an object expression when the ……filter value is undefinedFixes #10419Closes #10424 段落 Commit MessageCommit Message 分三个部分， header, body, footer. 其中，header 是必需的，body 和 footer 可以省略。不管是哪一个部分，任何一行都不得超过 100 个字符，以免影响阅读性。 12345[&lt;team&gt;]&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;body&gt;&lt;footer&gt; 123[FE]Fix(card): fix card edit support to unuse item在card修改里面，添加设置item未使用的功能 headerHeader 部分只有一行，包括三个字段：type（必需）、scope（可选）、team（可选）和 subject（必需）。 type用于说明 commit 的类别，只允许使用下面 7 个标识。 Add：新加功能 Fix：修补bug Modify：移除无用代码 Remove：移除第三方模块或者移除文件 Update：更新第三方模块 Style： 格式（不影响代码运行的变动） Chore：构建过程或辅助工具的变动 scopescope 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 例如在 shrezone，可以是 file, card, image, short_video 等。 如果你的修改影响了不止一个 scope，你可以使用*代替。 team当不同的 team 一起编写代码的时候，带 team 以区分工作区域 subjectsubject 是 commit 目的的简短描述，不超过 50 个字符。 其他注意事项： 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） BodyBody 部分是对本次 commit 的详细描述，可以分成多行。 比如 react 的提交 12345Sync out another jsx transform test.We added this test internally and it never got added here. We haven't broken itwith any transforms *yet* but it's still good to actually run all of our testshere too. 注意点: 使用第一人称现在时，比如使用change而不是changed或changes。 要和header之间有一个空行 应该说明代码变动的动机，以及与以前行为的对比。 FooterFooter 部分只用于以下两种情况： 不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。 关闭 Issue如果当前 commit 针对某个 issue，那么可以在 Footer 部分关闭这个 issue 。 Revert一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以 revert:开头，后面跟着被撤销 Commit 的 Header。 123revert: feat(pencil): add ‘graphiteWidth‘ optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn Koa2 Step By Step]]></title>
    <url>%2Flearn-koa2-step-by-step%2F</url>
    <content type="text"><![CDATA[适合入门 Koa2, 一步一步认识和使用 Koa2 这里有详细的源代码，git 地址： https://github.com/webkong/Koa2-learn-steps.git 针对每一步都有文档， 地址： https://webkong.github.io/Koa2-learn-steps/]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node版本管理工具nvm]]></title>
    <url>%2Fnode%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7nvm%2F</url>
    <content type="text"><![CDATA[NVM Github地址linux ：https://github.com/creationix/nvm windows: https://github.com/coreybutler/nvm-windows 官方github有详细的安装和使用方法 卸载已安装到全局的 node/npm如果之前是官网下载安装，或者是brew安装建议，先删除node和全局模块 12345npm ls -g --depth=0 #查看已经安装在全局的模块，以便删除这些全局模块后再按照不同的 node 版本重新进行全局安装sudo rm -rf /usr/local/lib/node_modules #删除全局 node_modules 目录sudo rm /usr/local/bin/node #删除 nodecd /usr/local/bin &amp;&amp; ls -l | grep "../lib/node_modules/" | awk '&#123;print $9&#125;'| xargs rm #删除全局 node 模块注册的软链 安装（linux）通过curl或wget 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 1wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 添加.bashrc或.bash_profile或.zshrc 123export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion 查看安装成功 1nvm --version 如果没有输出，执行 1source ~/.bashrc 或 ~/.bash_profile 或 ~/.zshrc 安装node1nvm install 6.11.3 使用nvm12345678910111213nvm ls-remote #所有可以安装的版本nvm install 版本号 #安装某个版本的nodenvm use 版本号 #切换到某个版本的nodenvm current # 查看当前使用的版本nvm ls #系统已安装的版本nvm alias default node #给node加别名nvm run 6.10.3 app.js 使用6.10.3版本运行js 使用 .nvmrc 文件配置项目所使用的 node 版本如果默认的版本和要使用的版本不同，但是又不想切换版本，可以使用.nvmrc来指定node 123$ echo "5.9" &gt; .nvmrc$ echo "lts/*" &gt; .nvmrc # to default to the latest LTS version 123$ nvm useFound '/path/to/project/.nvmrc' with version &lt;5.9&gt;Now using node v5.9.1 (npm v3.7.3) 最后在成功安装之后， node 的真是安装位置是在 1/Users/&lt;username&gt;/.nvm/versions/node 会有安装的所有版本， 每个版本中都有自己的npm方便管理和使用 就可以像以往一样使用node了。 1npm install -g cnpm --registry=https://registry.npm.taobao.org ####其他 如果 nvm ls-remote 返回 N/A，可以使用非HTTPS的源 12345export NVM_NODEJS_ORG_MIRROR=https://nodejs.org/dist或者export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node 如果还是不行可修改nvm.sh文件，在curl加上-k以非加密形式请求。 12345nvm_download() &#123; if nvm_has "curl"; then curl -k $* elif nvm_has "wget"; then # Emulate curl with wget 1nvm alias @8 8.9.1 命令行内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Usage: nvm --help Show this message nvm --version Print out the installed version of nvm nvm install [-s] &lt;version&gt; Download and install a &lt;version&gt;, [-s] from source. Uses .nvmrc if available --reinstall-packages-from=&lt;version&gt; When installing, reinstall packages installed in &lt;node|iojs|node version number&gt; --lts When installing, only select from LTS (long-term support) versions --lts=&lt;LTS name&gt; When installing, only select from versions for a specific LTS line --skip-default-packages When installing, skip the default-packages file if it exists --latest-npm After installing, attempt to upgrade to the latest working npm on the given node version nvm uninstall &lt;version&gt; Uninstall a version nvm uninstall --lts Uninstall using automatic LTS (long-term support) alias `lts/*`, if available. nvm uninstall --lts=&lt;LTS name&gt; Uninstall using automatic alias for provided LTS line, if available. nvm use [--silent] &lt;version&gt; Modify PATH to use &lt;version&gt;. Uses .nvmrc if available --lts Uses automatic LTS (long-term support) alias `lts/*`, if available. --lts=&lt;LTS name&gt; Uses automatic alias for provided LTS line, if available. nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] Run &lt;command&gt; on &lt;version&gt;. Uses .nvmrc if available --lts Uses automatic LTS (long-term support) alias `lts/*`, if available. --lts=&lt;LTS name&gt; Uses automatic alias for provided LTS line, if available. nvm run [--silent] &lt;version&gt; [&lt;args&gt;] Run `node` on &lt;version&gt; with &lt;args&gt; as arguments. Uses .nvmrc if available --lts Uses automatic LTS (long-term support) alias `lts/*`, if available. --lts=&lt;LTS name&gt; Uses automatic alias for provided LTS line, if available. nvm current Display currently activated version nvm ls List installed versions nvm ls &lt;version&gt; List versions matching a given &lt;version&gt; nvm ls-remote List remote versions available for install --lts When listing, only show LTS (long-term support) versions nvm ls-remote &lt;version&gt; List remote versions available for install, matching a given &lt;version&gt; --lts When listing, only show LTS (long-term support) versions --lts=&lt;LTS name&gt; When listing, only show versions for a specific LTS line nvm version &lt;version&gt; Resolve the given description to a single local version nvm version-remote &lt;version&gt; Resolve the given description to a single remote version --lts When listing, only select from LTS (long-term support) versions --lts=&lt;LTS name&gt; When listing, only select from versions for a specific LTS line nvm deactivate Undo effects of `nvm` on current shell nvm alias [&lt;pattern&gt;] Show all aliases beginning with &lt;pattern&gt; nvm alias &lt;name&gt; &lt;version&gt; Set an alias named &lt;name&gt; pointing to &lt;version&gt; nvm unalias &lt;name&gt; Deletes the alias named &lt;name&gt; nvm install-latest-npm Attempt to upgrade to the latest working `npm` on the current node version nvm reinstall-packages &lt;version&gt; Reinstall global `npm` packages contained in &lt;version&gt; to current version nvm unload Unload `nvm` from shell nvm which [&lt;version&gt;] Display path to installed node version. Uses .nvmrc if available nvm cache dir Display path to the cache directory for nvm nvm cache clear Empty cache directory for nvmExample: nvm install 8.0.0 Install a specific version number nvm use 8.0 Use the latest available 8.0.x release nvm run 6.10.3 app.js Run app.js using node 6.10.3 nvm exec 4.8.3 node app.js Run `node app.js` with the PATH pointing to node 4.8.3 nvm alias default 8.1.0 Set default node version on a shell nvm alias default node Always default to the latest available node version on a shellNote: to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`)]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>NVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift集合]]></title>
    <url>%2Fswift%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[参考:https://developer.apple.com/ 集合中存储相同类型的不同值, 集合中没有定义的顺序。当项目的顺序不重要时，或者当您需要确保某个项目只显示一次时，可以使用集合而不是数组。set中的值是unique的。 创建一个空set123var letters = Set&lt;Character&gt;()print("letters is of type Set&lt;Character&gt; with \(letters.count) items.")// Prints "letters is of type Set&lt;Character&gt; with 0 items." 创建一个数组文字的集合1var favoriteGenres: Set&lt;String&gt; = ["Rock", "Classical", "Hip hop"] 访问和修改setinsert1favoriteGenres.insert("Jazz") remove1favoriteGenres.remove("Rock") // 返回remove的item， 如果没有相应的item，返回nil removeAll1favoriteGenres.removeAll() contains1234567//是否set中包含特定的itemif favoriteGenres.contains("Funk") &#123; print("I get up on the good foot.")&#125; else &#123; print("It's too funky in here.")&#125;// Prints "It's too funky in here." 遍历set123456789101112131415for genre in favoriteGenres &#123; print("\(genre)")&#125;// Jazz// Hip hop// Classical//set是无序的，如果要按照某中order， 可以使用sorted()， 返回一个排序的arrayfor genre in favoriteGenres.sorted() &#123; print("\(genre)")&#125;// Classical// Hip hop// Jazz set 属性count1print("I have \(favoriteGenres.count) favorite music genres.") isEmpty12345if favoriteGenres.isEmpty &#123; print("As far as music goes, I'm not picky.")&#125; else &#123; print("I have particular music preferences.")&#125; set 操作可以高效地完成Set的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。 intersection两个集合的交集(common values) symmetricDifference不包含两个集合交集的部分的集合 union两个集合的并集 subtracting根据不在该集合中的值创建一个新的集合 12345678910111213let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sorted()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(evenDigits).sorted()// []oddDigits.subtracting(singleDigitPrimeNumbers).sorted()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()// [1, 2, 9] 集合的关系(成员、相等)下面的图描述了三个集合-a,b和c,以及通过重叠区域表述集合间共享的元素。集合a是集合b的父集合，因为a包含了b中所有的元素，相反的，集合b是集合a的子集合，因为属于b的元素也被a包含。集合b和集合c彼此不关联，因为它们之间没有共同的元素。 是否相等通过==来判断两个集合是否包含完全相同的值。 子集关系isSubset(of:) 判断是不是某个集合的子集 父集关系isSuperset(of:) 判断是不是某个集合的父集 真子集isStrictSubset(of:) 判断是不是一个集合的子集，并且两个集合不相同 真父级isStrictSuperset(of:) 判断是不是一个集合的父集，并且两个集合不相同 没有交集isDisjoint(with:)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift字典]]></title>
    <url>%2Fswift%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[原文： http://www.runoob.com/swift/swift-dictionaries.htmlhttps://developer.apple.com/ Swift 字典用来存储无序的相同类型数据的集合，Swift 字典会强制检测元素的类型，如果类型不同则会报错。Swift 字典每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。Swift 字典的key没有类型限制可以是整型或字符串，但必须是唯一的。如果创建一个字典，并赋值给一个变量，则创建的字典就是可以修改的。这意味着在创建字典后，可以通过添加、删除、修改的方式改变字典里的项目。如果将一个字典赋值给常量，字典就不可修改，并且字典的大小和内容都不可以修改。 创建空字典1234567 var namesOfIntegers = [Int: String]()// namesOfIntegers is an empty [Int: String] dictionarynamesOfIntegers[16] = "sixteen"// namesOfIntegers now contains 1 key-value pairnamesOfIntegers = [:]// namesOfIntegers is once again an empty dictionary of type [Int: String] 创建一个字典123var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]//也可以var airports = ["YYZ": "Toronto Pearson", "DUB": "Dublin"] 访问和修改字典123456789101112131415//addairports["LHR"] = "London"// the airports dictionary now contains 3 items//accessingairports["YYZ"] // 如果没有返回nil//remove for keyremovedValue = airports.removeValue(forKey: "DUB")//modify/updateairports["LHR"] = "London Heathrow"//updateairports.updateValue("Dublin Airport", forKey: "DUB") 遍历字典12345678910111213141516171819202122232425for (airportCode, airportName) in airports &#123; print("\(airportCode): \(airportName)")&#125;//只遍历值或者keyfor airportCode in airports.keys &#123; print("Airport code: \(airportCode)")&#125;// Airport code: YYZ// Airport code: LHRfor airportName in airports.values &#123; print("Airport name: \(airportName)")&#125;// Airport name: Toronto Pearson// Airport name: London Heathrow还可以单独使用keys和values来获取对应的arraylet airportCodes = [String](airports.keys)// airportCodes is ["YYZ", "LHR"]let airportNames = [String](airports.values)// airportNames is ["Toronto Pearson", "London Heathrow"]]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift数组]]></title>
    <url>%2Fswift%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[参考： http://www.runoob.com/swift/swift-arrays.htmlhttps://developer.apple.com/ Swift 数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。Swift 数组会强制检测元素的类型，如果类型不同则会报错，Swift 数组应该遵循像Array这样的形式，其中Element是这个数组中唯一允许存在的数据类型。如果创建一个数组，并赋值给一个变量，则创建的集合就是可以修改的。这意味着在创建数组后，可以通过添加、删除、修改的方式改变数组里的项目。如果将一个数组赋值给常量，数组就不可更改，并且数组的大小和内容都不可以修改。 创建数组1234567891011var someArray = [SomeType]()//以下是创建一个初始化大小数组的语法：var someArray = [SomeType](repeating: InitialValue, count: NumbeOfElements)//以下实例创建了一个类型为 Int ，数量为 3，初始值为 0 的空数组：var someInts = [Int](repeating: 0, count: 3)var someInts:[Int] = [10, 20, 30]var arr:[Any] = [1,2,3, "3"] 访问数组我们可以根据数组的索引来访问数组的元素，语法如下： 1var someVar = someArray[index] 修改数组可以使用 append() 方法或者赋值运算符+=在数组末尾添加元素 123456789101112131415161718192021222324var someInts = [Int]()someInts.append(20)someInts.append(30)someInts += [40]var someVar = someInts[0]print( "第一个元素的值 \(someVar)" )print( "第二个元素的值 \(someInts[1])" )print( "第三个元素的值 \(someInts[2])" )someInts[2] = 50print( "第三个元素的值 \(someInts[2])" )//一次性更改范围值shoppingList[4...6] = ["Bananas", "Apples"]//在特定的位置插入itemshoppingList.insert("Maple Syrup", at: 0) //移除特定位置的item let mapleSyrup = shoppingList.remove(at: 0) // item移除后， subscript会自动去掉空隙，所以，如果删除 0 ， 那么之前的1 就会变成 0 。//移除最后一个item let apples = shoppingList.removeLast() 遍历数组（Iterating Over an Array）123456789101112131415161718192021var someStrs = [String]()someStrs.append("Apple")someStrs.append("Amazon")someStrs.append("Runoob")someStrs += ["Google"]for item in someStrs &#123; print(item)&#125;//如果我们同时需要每个数据项的值和索引值，可以使用 String 的 enumerate() 方法来进行数组遍历for (index, item) in someStrs.enumerated() &#123; print("在 index = \(index) 位置上的值为 \(item)")&#125;在 index = 0 位置上的值为 Apple在 index = 1 位置上的值为 Amazon在 index = 2 位置上的值为 Runoob在 index = 3 位置上的值为 Google 其他： https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID121 合并数组我们可以使用加法操作符（+）来合并两种已存在的相同类型数组。新数组的数据类型会从两个数组的数据类型中推断出来 12345678var intsA = [Int](repeating: 2, count:2)var intsB = [Int](repeating: 1, count:3)var intsC = intsA + intsBfor item in intsC &#123; print(item)&#125; 数组属性count属性使用 count 属性来计算数组元素个数 1print(arr.count) isEmpty属性1print(arr.isEmpty) true/false]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli使用自定义模板]]></title>
    <url>%2Fvue-cli%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[Vue，越来越流行，因为它的易用性和良好的性能，随之而来的是vue-cli初始化项目，没有适用所有场景的模板，根据自己的业务场景初始化项目，才是最酷的。 官方模板 前提安装 Vue-cli 1$ npm install -g vue-cli 初始化方式 1$ vue init &lt;template-name&gt; &lt;project-name&gt; 例如： 1$ vue init webpack test 创建一个 webpack 为模板的 名为 test 的项目 查看官方的模板 1$ vue list 会输出 123456★ browserify - A full-featured Browserify + vueify setup with hot-reload, linting &amp; unit testing.★ browserify-simple - A simple Browserify + vueify setup for quick prototyping.★ pwa - PWA template for vue-cli based on the webpack template★ simple - The simplest possible Vue setup in a single HTML file★ webpack - A full-featured Webpack + vue-loader setup with hot reload, linting, testing &amp; css extraction.★ webpack-simple - A simple Webpack + vue-loader setup for quick prototyping. 这就是官方提供给我们的几种模板， 拿webpack为例， 默认初始化是没有sass相关包的， 当然也没有http请求的包，那么就需要一个适合自己的模板来初始化项目。 自定义模板并使用 以MAC为例 vue-cli 默认的模板存放在 ~/.vue-templates目录下面， 我们可以根据官方的webpack来自定义自己的模板 webpack2。 用自定义模板的时候 1vue init ~/.vue-templates/webpack2 test 参考https://github.com/vuejs/vue-cli]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue-cli</tag>
        <tag>自定义模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-内建的一些函数]]></title>
    <url>%2Fpython-%E5%86%85%E5%BB%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[特权，往往掌握在一部分群体中，内建函数就是有特权的一部分。享受着编译器和虚拟机 (运行时) 深度支持。 any()any(iterable) -&gt; bool Return True if bool(x) is True for any x in the iterable.If the iterable is empty, return False. 当迭代对象中任意一个不为False，则返回True。只有当所有x为False，结果才是False。 可用于检测所有的值是不是False，如果有一个是True,则返回True,如果所有的都是False,才返回False。 有点类似于 或 。 12345data = (0, 0.0, None, "", list(), tuple(), dict(), set(), frozenset())any(map(bool, data))False all()all(iterable) -&gt; bool Return True if bool(x) is True for all values x in the iterable.If the iterable is empty, return True.` 当迭代对象所有的值为True, 则返回True,任意一个不为True,则返回False 有点类似 与 1234567all([1,2,3,4,5,6])Trueall([0,1,2,3,4,5])False]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>内建函数</tag>
        <tag>any()</tag>
        <tag>all()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWS-Rekognition图像识别监管]]></title>
    <url>%2Faws-rekognition%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%9B%91%E7%AE%A1%2F</url>
    <content type="text"><![CDATA[搬运此文， 通过深度学习还检测图像中明显或者暗示性成人内容的 AWS 出品工具。 图像审核 问：什么是图像审核？ Amazon Rekognition 的图像审核是一种基于深度学习并且易于使用的 API，用于检测图像中的明显或暗示性成人内容。开发人员可以根据自己的业务需求，使用这种额外的元数据来筛选不当内容。除了根据存在的成人内容对图像进行标记之外，图像审核功能还会返回一个带有置信度的分级标签列表。这些标签会指明成人内容的具体类型，从而让开发人员能够进行更细化的控制，以便筛选和管理大量用户生成的内容 (UGC)。这一 API 可以用于社交和交友网站、相片分享平台、博客和论坛、儿童应用程序、电子商务网站、娱乐和在线广告服务等应用场景。 问：Amazon Rekognition 可以检测哪些类型的明显或暗示性成人内容？ Amazon Rekognition 可以检测图像中以下类型的明显或暗示性成人内容： 明显的裸露 裸露 男性裸体图形 女性裸体图形 性活动 部分裸露 暗示性 女性泳装或内衣 男性泳装或内衣 暴露的衣服Amazon Rekognition 的图像审核 API 可以返回一个分级标签列表，并附带检测到的每个标签的置信度。例如，对于一张不当图像，Rekognition 可能会返回最高级别的标签“明显的裸露”及其置信度。开发人员可以利用这一功能来标记内容。同时，Rekognition 还会提供“男性裸体图形”等更多信息及其置信度，从而返回细化到第二级别的信息。开发人员可以利用这一信息来构建更为复杂的筛选逻辑。 请注意，图像审核 API 并不能筛选出所有明显或暗示性成人内容。此外，图像审核 API 无法检测出某个图像是否包含违法内容(例如儿童色情内容) 或不正常成人内容。 问：除了明显和暗示性成人内容以外，Amazon Rekognition 的图像审核 API 能否检测其他不当内容？ Rekognition 目前只支持上文所述的标签。我们会根据客户反馈继续添加并完善各种标签。 如果您需要检测图片中其他类型的不当内容，请通过下文介绍的反馈流程联系我们。问：怎样确保 Rekognition 符合我的成人图像审核案例的要求？ Rekognition 的图像审核模型已经经过调整和大规模测试，但我们不建议您用自己的数据集来测量准确性和衡量性能。 您可以在 API 请求中使用“MinConfidence”参数，以便在内容检测 (灵敏度) 和检测准确性 (精度) 之间实现平衡。如果降低“MinConfidence”，您可能会检测出大多数不当内容，但也有可能检测出事实上不属于明显或暗示性成人内容的内容。如果提高“MinConfidence”，您可能能够确保检测出的所有内容事实上都是明显或暗示性成人内容，但可能会没有标记出某些不当内容。有关如何使用“MinConfidence”的示例，请参阅此处的文档。 https://aws.amazon.com/cn/rekognition/faqs/]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>Rekognition</tag>
        <tag>图像监管</tag>
        <tag>图像审核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概念-空间复杂度]]></title>
    <url>%2F%E6%A6%82%E5%BF%B5-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[想要深入往往是要从概念开始的。 定义一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。 描述一个算法在计算机存储器上所占用的存储空间，包括（存储算法本身所占用的存储空间）+（算法的输入输出数据所占用的存储空间）+（算法在运行过程中临时占用的存储空间）这三个方面。 算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。 存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。 算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小n而改变，我们称这种算法是“就地（原地）”进行的，是节省存储的算法。这种通常空间复杂度就是O(1)，有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，就是通常所说的O(n)。 算法原地工作是指算法所需辅助空间是常量，即O(1)。 例列举一下排序算法的时间复杂度和空间复杂度 排序法 最差时间分析 平均时间复杂度 稳定度 空间复杂度 冒泡排序 O(n2) O(n2) 稳定 O(1) 快速排序 O(n2) O(n*log2n) 不稳定 O(log2n)~O(n) 选择排序 O(n2) O(n2) 稳定 O(1) 二叉树排序 O(n2) O(n*log2n) 不稳定 O(n) 插入排序 O(n2) O(n2) 稳定 O(1) 堆排序 O(n*log2n) O(n*log2n) 不稳定 O(1) 希尔排序 O(n*log2n) O(n*log2n) 不稳定 O(1) 参考https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95#.E5.A4.8D.E6.9D.82.E5.BA.A6 计算复杂性理论 https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95#.E7.A9.BA.E9.97.B4.E5.A4.8D.E6.9D.82.E5.BA.A6]]></content>
      <categories>
        <category>概念</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>概念</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概念-时间复杂度]]></title>
    <url>%2F%E6%A6%82%E5%BF%B5-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[想要深入往往是要从概念开始的。 定义在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数（f(n)）。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。 例如，如果一个算法对于任何大小为 n （必须比 n0大）的输入，它至多需要 5n3+ 3n 的时间运行完毕，那么它的渐近时间复杂度是 O(n3)。 描述时间复杂度是指程序运行从开始到结束所需要的时间。 一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 只是时间复杂度，只有在程序真正执行或者测试的时候才能看到，所以通常的做法就是，从算法中选取一个基础操作或者称为原操作，以基础操作的重复执行次数作为算法的时间度量。 算法的执行次数还要随输入集有关，此时要考虑所有可能输入数据的期望值，此时的算法时间复杂度叫平均时间复杂度。 算法的基本操作重复执行的次数是模块n的某一个函数f(n)，因此，算法的时间复杂度记做：T(n)=O(n）。随着模块n的增大，算法执行的时间的增长率和f(n)的增长率成正比，所以f(n)越小，算法的时间复杂度越低，算法的效率越高。 大多数情况下，基础操作是最深层循环内的语句中的操作。 按数量级递增排列，常见的时间复杂度有：常数阶O(1), 对数阶O(log2n), 线性阶O(n), 线性对数阶O(nlog2n), 平方阶O(n2)， 立方阶O(n3),…， k次方阶O(nk), 指数阶O(2n) 。 例常数阶12345let a=0, n =100;a = (1+n)*n/2;console.log(a); 算法的时间复杂度为O(1)。这个算法的运行次数函数是f(n) = 1+1+1 = 3, 把常数项改为1，所以时间复杂度是O(1)。 线性阶1234for(let i = 0 ; i&lt; n ; i++)&#123; let sum += i; console.log(sum);&#125; 算法的时间复杂度是O(n)。这个的算法的运行次数函数f(n) = n+n = 2n , 把常数改为1， 所以时间复杂度是O(n)。 平方阶1234567let x = 0;for(let i = 0 ; i&lt;n ;i++)&#123; for(let j = 1; j&lt;=i; j++)&#123; ++x; &#125;&#125; 在上面这个双重for循环中，基础操作++x执行了1+2+3+ ... +n-1次，即n*(n-1)/2 = （n2-2n）/2，所以时间复杂度是 O(n2)； 对数阶123456let n = 100;let i = 1;while (i &lt; n) &#123; i = i*2; console.log(i);&#125; 算法的时间复杂度是O(log2n)。当每次i乘以2之后，i的值渐进于n，也就是说，有多少个2相乘之后会大于n,就会退出循环。 2x = n, x就是运行的次数， x = log2n 。 更多的时间复杂度列表参见 维基百科-时间复杂度[2]。 参考[1]百度百科-时间复杂度 [2]维基百科-时间复杂度 [3]http://blog.csdn.net/firefly_2002/article/details/8008987]]></content>
      <categories>
        <category>概念</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>概念</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟dom(virtual dom)diff算法]]></title>
    <url>%2F%E8%99%9A%E6%8B%9Fdom-virtual-dom-diff%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[适用的解往往不是最好的，但是肯定是最平衡的。 目录 Diff算法 虚拟Dom 虚拟Dom的Diff算法 Diff算法用过版本控制的同学都见过diff文件，在两个不同的文件之间找差异，在删掉的地方用’-‘标识，在新增加的地方用’+’标识(并不是所以的都是-+，但是都有标识新增和删掉的符号)。例如最流行的Git的diff文件(点击查看大图)： 如图所示，很明确的就知道两个文件的差异是什么，本次的修改又有哪些。那么diff的原理又是什么呢？ LCSLCS (最长公共子序列, Longest common subsequence problem)。 diff操作，就是基于解决LCS问题， 也就是说，假设给出两个序列： 123a b c d f g h j q z //Aa b c d e f g i j k r x y z //B 我们的目的是，在这两个序列当中，找到相同顺序的最长序列（we want to find a longest sequence of items that is present in both original sequences in the same order）。注意是相同顺序的序列而不是连续的序列。 那么对于上面的两个序列(A、B)来说，他们的最长公共子序列是： 1a b c d f g j z 那么， A对于B序列的差异就可以表示成： 12e h i q k r x y+ - + - + + + + 上面， +表示新增的字符， -表示要删除的字符。 也就是说，如果A序列要变成B序列，要在相应的位置上进行增加和删除操作。 当然我们在平时比较文件的diff时候，会把文件转化成两个列表， 列表的每一个元素就是文件的某一行，所以在上面git的diff文件中会显示每一行的 - 和 + 。 用js简单实现一个算法： 1234567891011121314151617181920212223242526272829let a1 = ['a', 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'q', 'z', 'k'];let b1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'i', 'j', 'k', 'r', 'x', 'y', 'z'];let clsQuence = [];function lcs(a, b) &#123; if (a.length &gt; 0 &amp;&amp; b.length &gt; 0) &#123; if (a[0] === b[0]) &#123; clsQuence.push(a[0]); a1.shift(); b1.shift(); &#125; else &#123; let index = b.indexOf(a[0]); if (index &gt; -1) &#123; clsQuence.push(a[0]); a1.shift(); b1 = b.slice(index); &#125; else &#123; a1.shift(); &#125; &#125; lcs(a1, b1) &#125; else &#123; return; &#125;&#125;lcs(a1, b1);console.log(clsQuence); 虚拟dom完善中… 参考https://en.wikipedia.org/wiki/Diff_utility https://en.wikipedia.org/wiki/Longest_common_subsequence_problem https://en.wikipedia.org/wiki/Dynamic_programming 全面理解虚拟DOM，实现虚拟DOM]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>虚拟dom</tag>
        <tag>virtual dom</tag>
        <tag>diff算法</tag>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Class的继承]]></title>
    <url>%2Fes6-class%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[他们问我坚持了这么久是为了什么 ?我说我没有坚持因为喜欢所以快乐很多人一辈子忙忙碌碌不会懂得：有个被嘲笑的梦想万一有天实现了呢？ 类：就是对象的抽象。对象：就是类的实例。子类：继承自父类，又各有特长。龙生九子，各不成龙。 extends关键词被用在类声明或者类表达式上，以创建一个类是另一个类的子类。实现继承，比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 使用extends12345678910111213141516class Square extends Polygon &#123; constructor(length) &#123; // 这里把length传参给父类的构造方法 // 作为父类Polygon的宽和高 super(length, length); // 备注：在衍生类中使用this前必须先调用super()方法 // 忽视这一点将会导致一个引用错误 this.name = 'Square'; &#125; get area() &#123; return this.height * this.width; &#125; set area(value) &#123; this.area = value; &#125;&#125; 根据Polygon类创建一个名为Square的类，也就是说，Square继承自Polygon。super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 使用extends扩展内建对象12345678910class myDate extends Date &#123; constructor() &#123;| super(); &#125; getFormattedDate() &#123; var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']; return this.getDate() + "-" + months[this.getMonth()] + "-" + this.getFullYear(); &#125;&#125; 这个myDate继承自Date，并新增getFormattedDate方法。 注：只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 获取父类Object.getPrototypeOf方法可以用来从子类上获取父类。可以使用这个方法判断，一个类是否继承了另一个类。 super关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次super函数。 super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。 123456789101112class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() // Anew B() // B 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B(); 上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。 这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 1234567891011121314class A &#123; constructor() &#123; this.p = 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p; &#125;&#125;let b = new B();b.m // undefined 上面代码中，p是父类A实例的属性，super.p就引用不到它。 如果属性定义在父类的原型对象上，super就可以取到。 1234567891011class A &#123;&#125;A.prototype.x = 2;class B extends A &#123; constructor() &#123; super(); console.log(super.x) // 2 &#125;&#125;let b = new B(); 上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。 ES6 规定，通过super调用父类的方法时，super会绑定子类的this。 123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print(); &#125;&#125;let b = new B();b.m() // 2 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 1234567891011121314151617class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125;&#125;let b = new B(); 上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。 123456789101112131415161718192021222324class Parent &#123; static myMethod(msg) &#123; console.log('static', msg); &#125; myMethod(msg) &#123; console.log('instance', msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 2 上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/extends http://es6.ruanyifeng.com/#docs/class-extends]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>class类</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-call和apply方法]]></title>
    <url>%2Fjavascript-call%E5%92%8Capply%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[诗三百，一言以蔽之，思无邪。曲千奏，一朝为闻之，念起灵。戏千吟，一舞为倾之，葬语花。棋百枚，一泣为终之，焚墨目。 使用别人的方法，拿来主义的实现者，call()和apply()。 Function.prototype.call()语法： fun.call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 参数： thisObj : 在fun函数运行时指定的this值。 arg1,arg2… : 参数列表 说明：让call()中的对象，调用当前对象(fun) 所拥有的function。 call()方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 示例123456789101112function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; Product.call(this, name, price); this.category = 'food';&#125;var f = new Food('webkong', 1999);console.log(f.name,f.price); 123456789function add(a, b) &#123; console.log(a + b);&#125;function sub(a, b) &#123; console.log(a - b);&#125;add.call(sub, 3, 1); //4 Function.prototype.apply()语法： fun.apply([thisObj[,argArray]]) 参数： thisObj : 在fun函数运行时指定的this值。 argArray: 参数数组 说明：apply()方法和 call() 方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。 如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原创</tag>
        <tag>函数</tag>
        <tag>call</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Class基本语法]]></title>
    <url>%2Fes6-class%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[身为一个以JavaScript作为主语言的码农，怎能不更新… 在ES6中，引入了Class类的概念，更接近于传统语言的写法，通过关键字class关键字来定义。简述基本语法和注意的点。 主要内容和demo来自 阮一峰老师的这篇 Class 的基本语法 ES5模拟的类JavaScript定义class的三种方法 在ES5没有类概念的时候，模拟类的几种常用的办法，其中构造函数法是最经典也是必会方法。通过在构造函数的Prototype对象上添加属性和方法来构造类。 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 其他就不再赘述。 ES6中的”类”（Class）基础语法基本上， ES6的class可以看做一个语法糖，它的绝大部分功能，ES5都能做到，新的class只是让对象原型的写法更清晰、更想面向对象的编程的语法而已。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面定义了一个类，可以看到有一个constructor方法，这就是构造方法，而this关键字代表实例对象。还定义了一个toString的方法。 ES6的类，完全可以看做构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // "function"Point === Point.prototype.constructor // true 这说明，类的数据类型是函数，类本身就是只想构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法一致。 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 12345678910111213141516171819202122232425class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;;let p = new Point(1,2);p.constructor === Point.prototype.constructor // true p是Point类的实例，它的constructor方法就是B类原型上的constructor方法。 由于类的方法都定义在prototype对象上面，所以类的新的方法可以添加在prototype对象上面。 Object.assign方法可以一次向类添加多个方法。 所以，可以看出，ES6的class只是对ES5模拟类的一个语法糖。 但是， 这样定义的类的内部的方法，是不可枚举的，与ES5的行为不一致。 还有一点，类的属性名可以采用表达式。 1234567891011let methodName = 'getArea';class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; 严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类必须使用new调用，否则会报错。 类的实例对象通过new命令来生成实例对象。 与ES5一样，实例的属性除非显式定义在其本身(即定义在this对象上)，否则都是定义在原型上（即定义在class上）。 12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。 与 ES5 一样，类的所有实例共享一个原型对象。 12345var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。 这也意味着，可以通过实例的proto属性为“类”添加方法。 12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // "Oops"p2.printName() // "Oops"var p3 = new Point(4,2);p3.printName() // "Oops" 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 class表达式与函数一样，类也可以使用表达式的形式定义。 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。 123let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 所以，可以看出，Me只在Class内部有定义。 如果类的内部没有用到，可以省略Me，也就是： 1const MyClass = class &#123; /* ... */ &#125;; 采用 Class 表达式，可以写出立即执行的 Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // "张三" person是一个立即执行的类的实例。 没有变量提升(hoist)类不存在变量提升（hoist），这一点与 ES5 完全不同。 1234567891011121314let f = new Foo();class Foo &#123;&#125;ReferenceError: Foo is not defined at Object.&lt;anonymous&gt; (/Users/xxx/www/node/ES6/class.js:1:75) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.runMain (module.js:604:10) at run (bootstrap_node.js:394:7) at startup (bootstrap_node.js:149:9) at bootstrap_node.js:509:3 Foo类使用在前，定义在后，这样就会报错，应为ES6不会把类的声明提升到代码头部。这种规定的原因和继承有关，必须保证子类在父类之后定义。 123let Foo = class &#123;&#125;;class Bar extends Foo &#123;&#125; 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 所以是不能有变量提升的。 私有方法私有方法是类的常见需求，但 ES6 没有提供，只能通过模拟实现。 一种做法是在命名上加以区别。 1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的. 1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 1234567891011121314151617const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 私有属性与私有方法一样，ES6 不支持私有属性。目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。 12345678910class Point &#123; #x; constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125; get x() &#123; return #x &#125; set x(value) &#123; #x = +value &#125;&#125; 上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。 私有属性可以指定初始值，在构造函数执行时进行初始化。 123456class Point &#123; #x = 0; constructor() &#123; #x; // 0 &#125;&#125; 之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。 该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。 1234567 class Foo &#123; #a; #b; #sum() &#123; return #a + #b; &#125; printSum() &#123; console.log(#sum()); &#125; constructor(a, b) &#123; #a = a; #b = b; &#125;&#125; this的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 12345678910111213class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。因为箭头函数this指向定义的对象。 123456789class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。 12345678910111213141516171819function selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== 'function') &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); class的getter和setter与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。 存值函数和取值函数是设置在属性的 Descriptor 对象上的。 1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, "html");"get" in descriptor // true"set" in descriptor // true 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。 class的Generater如果某个方法之前加上星号（\*），就表示该方法是一个 Generator 函数。 12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo('hello', 'world')) &#123; console.log(x);&#125;// hello// world 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。 class静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 父类的静态方法，可以被子类继承。 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // 'hello' 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。 静态方法也是可以从super对象上调用的。 12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod() // "hello, too" class静态属性和示例属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。 12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined 提案不在赘述 new.target 不再赘述 来源和参考https://curiosity-driven.org/private-properties-in-javascript https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>类class</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-常用高阶函数]]></title>
    <url>%2Fpython-%E5%B8%B8%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[温故而知新，可以为师矣。 什么是高阶函数， 在数学和计算机的定义里面，高阶函数至少要满足一下一个条件： 接受一个或者多个函数作为输入 输出一个函数 越是高级的语言，越贴近计算，抽象度越高。这里不得不说函数式编程，函数式编程的一个特点就是，允许把函数本身作为一个参数传递给另一个函数，还允许返回一个函数。像JavaScript等 map()函数map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 123def f(x): return x*xprint map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 输出结果 1[1, 4, 9, 10, 25, 36, 49, 64, 81] reduce()函数reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。例如，编写一个f函数，接收x和y，返回x和y的和： 12def f(x, y): return x + y 调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算： 12345先计算头两个元素：f(1, 3)，结果为4；再把结果和第3个元素计算：f(4, 5)，结果为9；再把结果和第4个元素计算：f(9, 7)，结果为16；再把结果和第5个元素计算：f(16, 9)，结果为25；由于没有更多的元素了，计算结束，返回结果25。 上述计算实际上是对 list 的所有元素求和。虽然Python内置了求和函数sum()，但是，利用reduce()求和也很简单。reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算： 1reduce(f, [1, 3, 5, 7, 9], 100) 结果将变为125，因为第一轮计算是：计算初始值和第一个元素：f(100, 1)，结果为101。 filter()函数filter()函数是 Python 内置高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数： 12def is_odd(x): return x % 2 == 1 然后，利用filter()过滤掉偶数： 1filter(is_odd, [1, 4, 6, 7, 9, 12, 17]) 结果：[1, 7, 9, 17]利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串： 123def is_not_empty(s): return s and len(s.strip()) &gt; 0filter(is_not_empty, ['test', None, '', 'str', ' ', 'END']) 结果：[‘test’, ‘str’, ‘END’]注意: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下： 12a = ' 123'a.strip() 结果： ‘123’ 12a='\t\t123\r\n'a.strip() 结果：’123’ 自定义排序函数Python内置的 sorted()函数可对list进行排序：12&gt;&gt;&gt;sorted([36, 5, 12, 9, 21])[5, 9, 12, 21, 36] 但 sorted()也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。因此，如果我们要实现倒序排序，只需要编写一个reversed_cmp函数： 123456def reversed_cmp(x, y): if x &gt; y: return -1 if x &lt; y: return 1 return 0 这样，调用 sorted() 并传入 reversed_cmp 就可以实现倒序排序： 12&gt;&gt;&gt; sorted([36, 5, 12, 9, 21], reversed_cmp)[36, 21, 12, 9, 5] sorted()也可以对字符串进行排序，字符串默认按照ASCII大小来比较： 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoe', 'Credit'])['Credit', 'Zoe', 'about', 'bob'] ‘Zoe’排在’about’之前是因为’Z’的ASCII码比’a’小。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>高阶函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-字典的常用操作]]></title>
    <url>%2Fpython-%E5%AD%97%E5%85%B8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[罗列字典的常用操作，遵循艾宾浩斯记忆遗忘曲线，让知识固化，方便查询和使用。 创建dictdict函数dict函数可以通过其他映射，比如字典或者(key,value)遮这样的序列对建立字典。 1234&gt;&gt;&gt; items = [('name','webkong'),('age',18)]&gt;&gt;&gt; d = dict(items)&gt;&gt;&gt; d&#123;'age': 18, 'name': 'webkong'&#125; 或者通过关键字参数来创建 123&gt;&gt;&gt; d = dict(name='webkong',age=18)&gt;&gt;&gt; d&#123;'age': 18, 'name': 'webkong'&#125; 如果不带参数，就会返回空字典. 和 list, tuple, str函数一样。 123&gt;&gt;&gt; a = dict()&gt;&gt;&gt; a&#123;&#125; 也可以直接用字面量 123&gt;&gt;&gt; c = &#123;'name':'webkong','age':19&#125;&gt;&gt;&gt; c&#123;'age': 19, 'name': 'webkong'&#125; 基本字典操作len()返回键值对的数量 deldel a[‘name’] #删除键为name的值 in‘name’ in a 返回 True 检查字典中是否含有键为name的项 赋值a[‘name’] = ‘wsw’ 键的类型： 字典的键是不可变类型，有可能是整型、浮点型（实型）、字符串或元组。添加：键不存在，也可以赋值，这样字典就会建立新的项。 字典格式化字符串1234&gt;&gt;&gt; info&#123;'age': 19, 'name': 'webkong'&#125;&gt;&gt;&gt; "%(name)s's age is %(age)s." % info"webkong's age is 19." 只要给出的键可以在字典中找到，就可以使用任意数量的转换说明符。在模板系统中非常有用。 字典方法clear原地操作， 清除字典中的所有项， 无返回值（或者说返回None）。 copy返回一个具有相同键值对的新字典。这种方法实现的是浅复制，因为值本身是相同的，而不是副本。 123456789101112131415&gt;&gt;&gt; info&#123;'skills': ['html', 'css', 'js'], 'age': 19, 'name': 'webkong'&#125;&gt;&gt;&gt; a = info.copy()&gt;&gt;&gt; a&#123;'skills': ['html', 'css', 'js'], 'age': 19, 'name': 'webkong'&#125;&gt;&gt;&gt; a['name'] = 'webkong1'&gt;&gt;&gt; a&#123;'skills': ['html', 'css', 'js'], 'age': 19, 'name': 'webkong1'&#125;&gt;&gt;&gt; info&#123;'skills': ['html', 'css', 'js'], 'age': 19, 'name': 'webkong'&#125;&gt;&gt;&gt; a['skills'].remove('html')&gt;&gt;&gt; a&#123;'skills': ['css', 'js'], 'age': 19, 'name': 'webkong1'&#125;&gt;&gt;&gt; info&#123;'skills': ['css', 'js'], 'age': 19, 'name': 'webkong'&#125; 在替换值得时候，原字典不受影响， 但是如果用原地操作修改了某个值，原字典也会改变。 避免这种问题的一种方式就是深复制(deep copy) 12345678910&gt;&gt;&gt; from copy import deepcopy&gt;&gt;&gt; info&#123;'skills': ['css', 'js'], 'age': 19, 'name': 'webkong'&#125;&gt;&gt;&gt; i = deepcopy(info)&gt;&gt;&gt; f = info.copy()&gt;&gt;&gt; f['skills'].append('js')&gt;&gt;&gt; f&#123;'skills': ['css', 'js', 'js'], 'age': 19, 'name': 'webkong'&#125;&gt;&gt;&gt; i&#123;'skills': ['css', 'js'], 'age': 19, 'name': 'webkong'&#125; fromkeys使用给定的键建立新的字典，每一个键默认的值是None. 123&gt;&gt;&gt; a = &#123;&#125;.fromkeys(['name','age'])&gt;&gt;&gt; a&#123;'age': None, 'name': None&#125; get访问字典项的方法，在访问不存在的项时，返回None。也可以自己定义“默认值” 1234&gt;&gt;&gt; a&#123;'age': None, 'name': None&#125;&gt;&gt;&gt; a.get('kk','NNN')'NNN' has_key检查字典中是否又给出的键。 1a.has_key('name') 相当于 k in d items &amp; iteritemsitems 方法将所有的字典项以列表的方式返回，list中的每一个项来自(key, value)，返回时没有次序。 1234 info&#123;'skills': ['css', 'js', 'js'], 'age': 19, 'name': 'webkong'&#125;&gt;&gt;&gt; info.items()[('skills', ['css', 'js', 'js']), ('age', 19), ('name', 'webkong')] iteritems 方法和items大致相同，但是会返回一个迭代器对象。 keys &amp; iterkeyskeys方法将字典中的键以列表的形式返回， iterkeys返回迭代器对象。 1234&gt;&gt;&gt; info&#123;'skills': ['css', 'js', 'js'], 'age': 19, 'name': 'webkong'&#125;&gt;&gt;&gt; info.keys()['skills', 'age', 'name'] poppop方法用来获取对应键的值，然后将这个键值对从字典中移除。 1234567&gt;&gt;&gt; info&#123;'skills': ['css', 'js', 'js'], 'age': 19, 'name': 'webkong'&#125;&gt;&gt;&gt; d = info.pop('name')&gt;&gt;&gt; d'webkong'&gt;&gt;&gt; info&#123;'skills': ['css', 'js', 'js'], 'age': 19&#125; popitempopitem 类似于list.pop，但不同的是，popitem弹出的是随机项，因为字典没有最后项的概念。 若想一个接一个地移除并处理项，这个方法就很适合，不用首先获取键的列表。 1a.popitem() setdefaultsetdefault可以在字典不包含给定键值对的情况下设置相应的键值。123456789101112&gt;&gt;&gt; b = &#123;&#125;&gt;&gt;&gt; b.setdefault('name','N/A')'N/A'&gt;&gt;&gt; b&#123;'name': 'N/A'&#125;&gt;&gt;&gt; b['name'] = 'webkong'&gt;&gt;&gt; b&#123;'name': 'webkong'&#125;&gt;&gt;&gt; b.setdefault('name','N/A')'webkong'&gt;&gt;&gt; b&#123;'name': 'webkong'&#125; updateupdate 方法可以利用一个字典项更新另外一个字典。 12345678910&gt;&gt;&gt; a&#123;'skills': ['css', 'js', 'js'], 'age': 19, 'name': 'webkong'&#125;&gt;&gt;&gt; x = &#123;'age':18&#125;&gt;&gt;&gt; a.update(x)&gt;&gt;&gt; a&#123;'skills': ['css', 'js', 'js'], 'age': 18, 'name': 'webkong'&#125;&gt;&gt;&gt; y = &#123;'kk':'kkkk'&#125;&gt;&gt;&gt; a.update(y)&gt;&gt;&gt; a&#123;'skills': ['css', 'js', 'js'], 'kk': 'kkkk', 'age': 18, 'name': 'webkong'&#125; values &amp; itervaluesvalues 方法以列表的形式返回字典的值， 返回的值可以包含重复的元素。 itervalues 返回一个迭代对象。 1234&gt;&gt;&gt; a&#123;'skills': ['css', 'js', 'js'], 'kk': 'kkkk', 'age': 18, 'name': 'webkong'&#125;&gt;&gt;&gt; a.values()[['css', 'js', 'js'], 'kkkk', 18, 'webkong']]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>dict</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-列表常用操作]]></title>
    <url>%2Fpython-%E5%88%97%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[时光如水，滴沥万物。语言太多，方法更甚，一不注意就忘记了。遂整理写下备忘，以避之。 list,Python最常用的数据结构，也是其内建的最常用的序列之一。list可以修改，是较之于tuple不同的地方。 list的元素可以包含所有的数据类型，甚至是另一个list。 123这就是一个listplist = [1, 'a', [1,2,3], 12.5]array = [1,2,3,4,5,6,7,8,9] 通用序列操作索引（index）序列中的所有元素都有编号，从0开始递增。元素可以通过编号进行访问，这就常说的索引，或者称之为下标。如果是用负索引，会从右边最后一个元素开始。最后一个元素的编号是 -1 。123plist[0] #1plist[1] #'a'plist[-1] #12.5 分片(:)list[index:last-index:step]通过分片操作来访问一定范围的元素。分片通过冒号:相隔的两个索引来实现。第一个索引值是需要提取部分的第一个元素的编号，最后的索引值是分片之后剩下部分的第一个元素的编号。可以理解成左闭右开。 1234567891011121314plist[0:2] #[1,'a']arr[1:4] #[2,3,4]#便捷用法array[5:] -- [6,7,8,9]array[-3:] -- [7,8,9]array[:3] -- [1,2,3]array[:] -- [1,2,3,4,5,6,7,8,9] #复制整个list还可以设置步长array[1:6:2] -- [2,4,6]array[::4] -- [1,5,9] #步长是4array[10:0:-2] -- [9, 7, 5, 3] #步长是负数，从右向左提取数据 序列相加（连接操作 + ）只有相同类型的序列才可以进行连接操作 123array + plist就会得到[1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 'a', [1, 2, 3], 12.5] 乘法(*)用数字x乘以一个序列，会生成一个新的序列，在新的序列中，原来的序列会被重复x次。 1234[12]*10[12, 12, 12, 12, 12, 12, 12, 12, 12, 12][None]*10 初始化长度为10的列表 成员资格（in）检查一个值是否在序列里面。用关键词 in 1'P' in 'Python' # True 长度（len()）最大值（max()）最小值（min()）Python的内建函数123len(array) # 10max(array) # 9min(array) # 1 list的基本操作元素赋值1array[1] = 10 删除元素(del)1del array[2] 分片赋值123456789101112131415161718192021&gt;&gt;&gt; name = list('webapp')&gt;&gt;&gt; name['w', 'e', 'b', 'a', 'p', 'p']# 不等长赋值（替换）&gt;&gt;&gt; name[3:] = list('kong')&gt;&gt;&gt; name['w', 'e', 'b', 'k', 'o', 'n', 'g']#在不替换任何原有的元素情况下插入新的元素&gt;&gt;&gt; number = [1,5]&gt;&gt;&gt; number[1:1] = [2,3,4]&gt;&gt;&gt; number[1, 2, 3, 4, 5]#通过分片赋值来删除元素&gt;&gt;&gt; number[1, 2, 3, 4, 5]&gt;&gt;&gt; number[1:4] = []&gt;&gt;&gt; number[1, 5] list的方法append 追加在列表末尾追加新的对象 12array.append(10)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] count 某元素计数统计某个元素在列表中出现的次数。 返回： 元素次数 12&gt;&gt;&gt; [1,2,3,1,2,1,1,1,].count(1)5 extend 扩展原地操作， 在列表的末尾一次性追加列一个list中的多个值。可以理解成为扩展。 12345&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6] index 查找索引位置在列表中找出某个值第一个匹配的索引位置， 如果没有就会发现一个异常。返回：索引位置 1234&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; a.index(4)3 insert 在索引位插入insert(index, value)， 在index 位置插入一个value 123&gt;&gt;&gt; a.insert(3,'a')&gt;&gt;&gt; a[1, 2, 3, 'a', 4, 5, 6] pop 移除元素移除list中的一个元素（默认是最后一个），并返回该元素的值。 12345678910&gt;&gt;&gt; a[1, 2, 3, 'a', 4, 5, 6]&gt;&gt;&gt; a.pop()6&gt;&gt;&gt; a[1, 2, 3, 'a', 4, 5]&gt;&gt;&gt; a.pop(1)2&gt;&gt;&gt; a[1, 3, 'a', 4, 5] remove 移除第一个匹配项用于移除list中第一个匹配项 12345&gt;&gt;&gt; a[1, 3, 'a', 4, 5]&gt;&gt;&gt; a.remove('a')&gt;&gt;&gt; a[1, 3, 4, 5] reverse 反转将list中的元素反向存放 12345&gt;&gt;&gt; a[1, 3, 4, 5]&gt;&gt;&gt; a.reverse()&gt;&gt;&gt; a[5, 4, 3, 1] sort 排序原地操作， 不返回值12345&gt;&gt;&gt; a[5, 4, 3, 1]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 3, 4, 5] sorted 排序非原地操作， 返回一个list 12345&gt;&gt;&gt; a[5, 4, 3, 1]&gt;&gt;&gt; b = sorted(a)&gt;&gt;&gt; b[1, 3, 4, 5] 高级排序sort有两个可选的参数： key 和 reverse 1234567891011&gt;&gt;&gt; a['aa', 'aaaaa', 'aaa', 'bbbbbbbb']&gt;&gt;&gt; a.sort(key=len)&gt;&gt;&gt; a['aa', 'aaa', 'aaaaa', 'bbbbbbbb']&gt;&gt;&gt; a['aa', 'aaa', 'aaaaa', 'bbbbbbbb']&gt;&gt;&gt; a.sort(reverse=True)&gt;&gt;&gt; a['bbbbbbbb', 'aaaaa', 'aaa', 'aa'] list()将序列转换成list 1234&gt;&gt;&gt; ls = 'webong blog'&gt;&gt;&gt; lst = list(ls)&gt;&gt;&gt; lst['w', 'e', 'b', 'o', 'n', 'g', ' ', 'b', 'l', 'o', 'g']]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 错误代码]]></title>
    <url>%2Fmysql-%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[原文地址 http://www.cnblogs.com/skillCoding/archive/2011/09/07/2169932.html 本章列出了当你用任何主机语言调用 MySQL 时可能出现的错误。首先列出了服务器错误消息。其次列出了客户端程序消息。B.1. 服务器错误代码和消息服务器错误信息来自下述源文件： 错误消息信息列在 share/errmsg.txt 文件中。“%d”和“%s”分别代表编号和字符串，显示时，它们将被消息值取代。 错误值列在 share/errmsg.txt 文件中，用于生成 include/mysqld_error.h 和 include/mysqld_ername.h MySQL 源文件中的定义。 SQLSTATE 值列在 share/errmsg.txt 文件中，用于生成 include/sql_state.h MySQL 源文件中的定义。 由于更新很频繁，这些文件中可能包含这里未列出的额外错误消息。 错误：1000 SQLSTATE: HY000 (ER_HASHCHK) 消息：hashchk 错误：1001 SQLSTATE: HY000 (ER_NISAMCHK) 消息：isamchk 错误：1002 SQLSTATE: HY000 (ER_NO) 消息：NO 错误：1003 SQLSTATE: HY000 (ER_YES) 消息：YES 错误：1004 SQLSTATE: HY000 (ER_CANT_CREATE_FILE) 消息：无法创建文件&#39;%s&#39; (errno: %d) 错误：1005 SQLSTATE: HY000 (ER_CANT_CREATE_TABLE) 消息：无法创建表&#39;%s&#39; (errno: %d) 错误：1006 SQLSTATE: HY000 (ER_CANT_CREATE_DB) 消息：无法创建数据库&#39;%s&#39; (errno: %d) 错误：1007 SQLSTATE: HY000 (ER_DB_CREATE_EXISTS) 消息：无法创建数据库&#39;%s&#39;，数据库已存在。 错误：1008 SQLSTATE: HY000 (ER_DB_DROP_EXISTS) 消息：无法撤销数据库&#39;%s&#39;，数据库不存在。 错误：1009 SQLSTATE: HY000 (ER_DB_DROP_DELETE) 消息：撤销数据库时出错（无法删除&#39;%s&#39;，errno: %d） 错误：1010 SQLSTATE: HY000 (ER_DB_DROP_RMDIR) 消息：撤销数据库时出错（can&#39;t rmdir &#39;%s&#39;, errno: %d） 错误：1011 SQLSTATE: HY000 (ER_CANT_DELETE_FILE) 消息：删除&#39;%s&#39;时出错 (errno: %d) 错误：1012 SQLSTATE: HY000 (ER_CANT_FIND_SYSTEM_REC) 消息：无法读取系统表中的记录。 错误：1013 SQLSTATE: HY000 (ER_CANT_GET_STAT) 消息：无法获取&#39;%s&#39;的状态(errno: %d) 错误：1014 SQLSTATE: HY000 (ER_CANT_GET_WD) 消息：无法获得工作目录(errno: %d) 错误：1015 SQLSTATE: HY000 (ER_CANT_LOCK) 消息：无法锁定文件(errno: %d) 错误：1016 SQLSTATE: HY000 (ER_CANT_OPEN_FILE) 消息：无法打开文件：&#39;%s&#39; (errno: %d) 错误：1017 SQLSTATE: HY000 (ER_FILE_NOT_FOUND) 消息：无法找到文件： &#39;%s&#39; (errno: %d) 错误：1018 SQLSTATE: HY000 (ER_CANT_READ_DIR) 消息：无法读取&#39;%s&#39;的目录 (errno: %d) 错误：1019 SQLSTATE: HY000 (ER_CANT_SET_WD) 消息：无法为&#39;%s&#39;更改目录 (errno: %d) 错误：1020 SQLSTATE: HY000 (ER_CHECKREAD) 消息：自上次读取以来表&#39;%s&#39;中的记录已改变。 错误：1021 SQLSTATE: HY000 (ER_DISK_FULL) 消息：磁盘满(%s)；等待某人释放一些空间... 错误：1022 SQLSTATE: 23000 (ER_DUP_KEY) 消息：无法写入；复制表&#39;%s&#39;的 键。 错误：1023 SQLSTATE: HY000 (ER_ERROR_ON_CLOSE) 消息：关闭&#39;%s&#39;时出错 (errno: %d) 错误：1024 SQLSTATE: HY000 (ER_ERROR_ON_READ) 消息：读取文件&#39;%s&#39;时出错 (errno: %d) 错误：1025 SQLSTATE: HY000 (ER_ERROR_ON_RENAME) 消息：将&#39;%s&#39;重命名为&#39;%s&#39;时出错 (errno: %d) 错误：1026 SQLSTATE: HY000 (ER_ERROR_ON_WRITE) 消息：写入文件&#39;%s&#39;时出错 (errno: %d) 错误：1027 SQLSTATE: HY000 (ER_FILE_USED) 消息：&#39;%s&#39;已锁定，拒绝更改。 错误：1028 SQLSTATE: HY000 (ER_FILSORT_ABORT) 消息：分类失败 错误：1029 SQLSTATE: HY000 (ER_FORM_NOT_FOUND) 消息：对于&#39;%s&#39;，视图&#39;%s&#39;不存在。 错误：1030 SQLSTATE: HY000 (ER_GET_ERRNO) 消息：从存储引擎中获得错误%d。 错误：1031 SQLSTATE: HY000 (ER_ILLEGAL_HA) 消息：关于&#39;%s&#39;的表存储引擎不含该选项。 错误：1032 SQLSTATE: HY000 (ER_KEY_NOT_FOUND) 消息：无法在&#39;%s&#39;中找到记录。 错误：1033 SQLSTATE: HY000 (ER_NOT_FORM_FILE) 消息：文件中的不正确信息：&#39;%s&#39; 错误：1034 SQLSTATE: HY000 (ER_NOT_KEYFILE) 消息：对于表&#39;%s&#39;， 键文件不正确，请尝试修复。 错误：1035 SQLSTATE: HY000 (ER_OLD_KEYFILE) 消息：旧的键文件，对于表&#39;%s&#39;，请修复之！ 错误：1036 SQLSTATE: HY000 (ER_OPEN_AS_READONLY) 消息：表&#39;%s&#39;是只读的。 错误：1037 SQLSTATE: HY001 (ER_OUTOFMEMORY) 消息：内存溢出，重启服务器并再次尝试（需要%d字节）。 错误：1038 SQLSTATE: HY001 (ER_OUT_OF_SORTMEMORY) 消息：分类内存溢出，增加服务器的分类缓冲区大小。 错误：1039 SQLSTATE: HY000 (ER_UNEXPECTED_EOF) 消息：读取文件&#39;%s&#39;时出现意外EOF (errno: %d) 错误：1040 SQLSTATE: 08004 (ER_CON_COUNT_ERROR) 消息：连接过多。 错误：1041 SQLSTATE: HY000 (ER_OUT_OF_RESOURCES) 消息：内存溢出，请检查是否mysqld或其他进程使用了所有可用内存，如不然，或许应使用&#39;ulimit&#39;允许mysqld使用更多内存，或增加交换空间的大小。 错误：1042 SQLSTATE: 08S01 (ER_BAD_HOST_ERROR) 消息：无法获得该地址给出的主机名。 错误：1043 SQLSTATE: 08S01 (ER_HANDSHAKE_ERROR) 消息：不良握手 错误：1044 SQLSTATE: 42000 (ER_DBACCESS_DENIED_ERROR) 消息：拒绝用户&#39;%s&#39;@&#39;%s&#39;访问数据库&#39;%s&#39;。 错误：1045 SQLSTATE: 28000 (ER_ACCESS_DENIED_ERROR) 消息：拒绝用户&#39;%s&#39;@&#39;%s&#39;的访问（使用密码：%s） 错误：1046 SQLSTATE: 3D000 (ER_NO_DB_ERROR) 消息：未选择数据库。 错误：1047 SQLSTATE: 08S01 (ER_UNKNOWN_COM_ERROR) 消息：未知命令。 错误：1048 SQLSTATE: 23000 (ER_BAD_NULL_ERROR) 消息：列&#39;%s&#39;不能为空。 错误：1049 SQLSTATE: 42000 (ER_BAD_DB_ERROR) 消息：未知数据库&#39;%s&#39;。 错误：1050 SQLSTATE: 42S01 (ER_TABLE_EXISTS_ERROR) 消息：表&#39;%s&#39;已存在。 错误：1051 SQLSTATE: 42S02 (ER_BAD_TABLE_ERROR) 消息：未知表&#39;%s&#39;。 错误：1052 SQLSTATE: 23000 (ER_NON_UNIQ_ERROR) 消息：%s中的列&#39;%s&#39;不明确。 错误：1053 SQLSTATE: 08S01 (ER_SERVER_SHUTDOWN) 消息：在操作过程中服务器关闭。 错误：1054 SQLSTATE: 42S22 (ER_BAD_FIELD_ERROR) 消息：&#39;%s&#39;中的未知列&#39;%s&#39;。 错误：1055 SQLSTATE: 42000 (ER_WRONG_FIELD_WITH_GROUP) 消息：&#39;%s&#39;不在GROUP BY中。 错误：1056 SQLSTATE: 42000 (ER_WRONG_GROUP_FIELD) 消息：无法在&#39;%s&#39;上创建组。 错误：1057 SQLSTATE: 42000 (ER_WRONG_SUM_SELECT) 消息：语句中有sum函数和相同语句中的列。 错误：1058 SQLSTATE: 21S01 (ER_WRONG_VALUE_COUNT) 消息：列计数不匹配值计数。 错误：1059 SQLSTATE: 42000 (ER_TOO_LONG_IDENT) 消息：ID名称&#39;%s&#39;过长。 错误：1060 SQLSTATE: 42S21 (ER_DUP_FIELDNAME) 消息：重复列名&#39;%s&#39;。 错误：1061 SQLSTATE: 42000 (ER_DUP_KEYNAME) 消息：重复键名称&#39;%s&#39;。 错误：1062 SQLSTATE: 23000 (ER_DUP_ENTRY) 消息：键%d的重复条目&#39;%s&#39;。 错误：1063 SQLSTATE: 42000 (ER_WRONG_FIELD_SPEC) 消息：对于列&#39;%s&#39;，列分类符不正确。 错误：1064 SQLSTATE: 42000 (ER_PARSE_ERROR) 消息：在行%d上，%s靠近&#39;%s&#39;。 错误：1065 SQLSTATE: 42000 (ER_EMPTY_QUERY) 消息：查询为空。 错误：1066 SQLSTATE: 42000 (ER_NONUNIQ_TABLE) 消息：非唯一的表/别名：&#39;%s&#39; 错误：1067 SQLSTATE: 42000 (ER_INVALID_DEFAULT) 消息：关于&#39;%s&#39;的无效默认值。 错误：1068 SQLSTATE: 42000 (ER_MULTIPLE_PRI_KEY) 消息：定义了多个主键。 错误：1069 SQLSTATE: 42000 (ER_TOO_MANY_KEYS) 消息：指定了过多键：允许的最大键数是%d。 错误：1070 SQLSTATE: 42000 (ER_TOO_MANY_KEY_PARTS) 消息：指定了过多键部分：允许的最大键部分是%d。 错误：1071 SQLSTATE: 42000 (ER_TOO_LONG_KEY) 消息：指定的键过长，最大键长度是%d字节。 错误：1072 SQLSTATE: 42000 (ER_KEY_COLUMN_DOES_NOT_EXITS) 消息：键列&#39;%s&#39;在表中不存在。 错误：1073 SQLSTATE: 42000 (ER_BLOB_USED_AS_KEY) 消息：BLOB列&#39;%s&#39;不能与已使用的表类型用在 键说明中。 错误：1074 SQLSTATE: 42000 (ER_TOO_BIG_FIELDLENGTH) 消息：对于列&#39;%s&#39;，列长度过大 (max = %d)，请使用BLOB或TEXT取而代之。 错误：1075 SQLSTATE: 42000 (ER_WRONG_AUTO_KEY) 消息：不正确的表定义，只能有1个auto列，而且必须将其定义为 键。 错误：1076 SQLSTATE: HY000 (ER_READY) 消息：%s，连接就绪。版本：&#39;%s&#39;，套接字：&#39;%s&#39;，端口：%d 错误：1077 SQLSTATE: HY000 (ER_NORMAL_SHUTDOWN) 消息：%s，正常关闭。 错误：1078 SQLSTATE: HY000 (ER_GOT_SIGNAL) 消息：%s，获得信号%d。放弃！ 错误：1079 SQLSTATE: HY000 (ER_SHUTDOWN_COMPLETE) 消息：%s，关闭完成 错误：1080 SQLSTATE: 08S01 (ER_FORCING_CLOSE) 消息：%s，强制关闭线程%ld，用户：&#39;%s&#39; 错误：1081 SQLSTATE: 08S01 (ER_IPSOCK_ERROR) 消息：无法创建IP套接字 错误：1082 SQLSTATE: 42S12 (ER_NO_SUCH_INDEX) 消息：表&#39;%s&#39;中没有与CREATE INDEX中索引类似的索引，重新创建表。 错误：1083 SQLSTATE: 42000 (ER_WRONG_FIELD_TERMINATORS) 消息：字段分隔符参量不是预期的，请参考手册。 错误：1084 SQLSTATE: 42000 (ER_BLOBS_AND_NO_TERMINATED) 消息：不能与BLOB一起使用固定行长度，请使用&#39;fields terminated by&#39;。 错误：1085 SQLSTATE: HY000 (ER_TEXTFILE_NOT_READABLE) 消息：文件&#39;%s&#39;必须在数据库目录下，或能被所有人读取。 错误：1086 SQLSTATE: HY000 (ER_FILE_EXISTS_ERROR) 消息：文件&#39;%s&#39;已存在。 错误：1087 SQLSTATE: HY000 (ER_LOAD_INFO) 消息：记录，%ld；已删除，%ld；已跳过，%ld；警告，%ld 错误：1088 SQLSTATE: HY000 (ER_ALTER_INFO) 消息：记录，%ld；重复，%ld 错误：1089 SQLSTATE: HY000 (ER_WRONG_SUB_KEY) 消息：不正确的子部分键，使用的键部分不是字符串，所用的长度长于键部分，或存储引擎不支持唯一子键。 错误：1090 SQLSTATE: 42000 (ER_CANT_REMOVE_ALL_FIELDS) 消息：不能用ALTER TABLE删除所有列，请使用DROP TABLE取而代之。 错误：1091 SQLSTATE: 42000 (ER_CANT_DROP_FIELD_OR_KEY) 消息：不能撤销&#39;%s&#39;，请检查列/键是否存在。 错误：1092 SQLSTATE: HY000 (ER_INSERT_INFO) 消息：记录，%ld；复制，%ld；告警，%ld 错误：1093 SQLSTATE: HY000 (ER_UPDATE_TABLE_USED) 消息：不能在FROM子句中制定要更新的目标表&#39;%s&#39;。 错误：1094 SQLSTATE: HY000 (ER_NO_SUCH_THREAD) 消息：未知线程ID：%lu 错误：1095 SQLSTATE: HY000 (ER_KILL_DENIED_ERROR) 消息：你不是线程%lu的所有者。 错误：1096 SQLSTATE: HY000 (ER_NO_TABLES_USED) 消息：未使用任何表。 错误：1097 SQLSTATE: HY000 (ER_TOO_BIG_SET) 消息：列%s和SET的字符串过多。 错误：1098 SQLSTATE: HY000 (ER_NO_UNIQUE_LOGFILE) 消息：不能生成唯一的日志文件名%s.(1-999) 错误：1099 SQLSTATE: HY000 (ER_TABLE_NOT_LOCKED_FOR_WRITE) 消息：表&#39;%s&#39;已用READ锁定，不能更新。 错误：1100 SQLSTATE: HY000 (ER_TABLE_NOT_LOCKED) 消息：未使用LOCK TABLES锁定表&#39;%s&#39;。 错误：1101 SQLSTATE: 42000 (ER_BLOB_CANT_HAVE_DEFAULT) 消息：BLOB/TEXT列&#39;%s&#39;不能有默认值。 错误：1102 SQLSTATE: 42000 (ER_WRONG_DB_NAME) 消息：不正确的数据库名&#39;%s&#39;。 错误：1103 SQLSTATE: 42000 (ER_WRONG_TABLE_NAME) 消息：不正确的表名&#39;%s&#39;。 错误：1104 SQLSTATE: 42000 (ER_TOO_BIG_SELECT) 消息：SELECT将检查超过MAX_JOIN_SIZE的行，如果SELECT正常，请检查WHERE，并使用SET SQL_BIG_SELECTS=1 或 SET SQL_MAX_JOIN_SIZE=#。 错误：1105 SQLSTATE: HY000 (ER_UNKNOWN_ERROR) 消息：未知错误。 错误：1106 SQLSTATE: 42000 (ER_UNKNOWN_PROCEDURE) 消息：未知过程&#39;%s&#39; 错误：1107 SQLSTATE: 42000 (ER_WRONG_PARAMCOUNT_TO_PROCEDURE) 消息：对于过程&#39;%s&#39;，参数计数不正确 错误：1108 SQLSTATE: HY000 (ER_WRONG_PARAMETERS_TO_PROCEDURE) 消息：对于过程&#39;%s&#39;，参数不正确 错误：1109 SQLSTATE: 42S02 (ER_UNKNOWN_TABLE) 消息：%s中的未知表%s 错误：1110 SQLSTATE: 42000 (ER_FIELD_SPECIFIED_TWICE) 消息：列&#39;%s&#39;被指定了两次。 错误：1111 SQLSTATE: HY000 (ER_INVALID_GROUP_FUNC_USE) 消息：无效的分组函数使用 错误：1112 SQLSTATE: 42000 (ER_UNSUPPORTED_EXTENSION) 消息：表&#39;%s&#39;使用了该MySQL版本中不存在的扩展。 错误：1113 SQLSTATE: 42000 (ER_TABLE_MUST_HAVE_COLUMNS) 消息：1个表至少要有1列。 错误：1114 SQLSTATE: HY000 (ER_RECORD_FILE_FULL) 消息：表&#39;%s&#39;已满。 错误：1115 SQLSTATE: 42000 (ER_UNKNOWN_CHARACTER_SET) 消息：未知字符集&#39;%s&#39;。 错误：1116 SQLSTATE: HY000 (ER_TOO_MANY_TABLES) 消息：表过多，MySQL在1个联合操作中只能使用%d个表。 错误：1117 SQLSTATE: HY000 (ER_TOO_MANY_FIELDS) 消息：列过多。 错误：1118 SQLSTATE: 42000 (ER_TOO_BIG_ROWSIZE) 消息：行的大小过大。对于所使用的表类型，不包括BLOB，最大行大小为%ld。必须将某些列更改为TEXT或BLOB。 错误：1119 SQLSTATE: HY000 (ER_STACK_OVERRUN) 消息：线程堆栈溢出，已使用，%ld堆栈的%ld。如果需要，请使用&#39;mysqld -O thread_stack=#&#39;指定较大的堆栈。 错误：1120 SQLSTATE: 42000 (ER_WRONG_OUTER_JOIN) 消息：在OUTER JOIN中发现交叉关联，请检查ON条件。 错误：1121 SQLSTATE: 42000 (ER_NULL_COLUMN_IN_INDEX) 消息：列&#39;%s&#39;与UNIQUE或INDEX一起使用，但未定义为NOT NULL。 错误：1122 SQLSTATE: HY000 (ER_CANT_FIND_UDF) 消息：无法加载函数&#39;%s&#39;。 错误：1123 SQLSTATE: HY000 (ER_CANT_INITIALIZE_UDF) 消息：无法初始化函数&#39;%s&#39;; %s 错误：1124 SQLSTATE: HY000 (ER_UDF_NO_PATHS) 消息：对于共享库，不允许任何路径。 错误：1125 SQLSTATE: HY000 (ER_UDF_EXISTS) 消息：函数&#39;%s&#39;已存在。 错误：1126 SQLSTATE: HY000 (ER_CANT_OPEN_LIBRARY) 消息：不能打开共享库&#39;%s&#39; (errno: %d %s) 错误：1127 SQLSTATE: HY000 (ER_CANT_FIND_DL_ENTRY) 消息：不能发现库中的符号&#39;%s&#39;。 错误：1128 SQLSTATE: HY000 (ER_FUNCTION_NOT_DEFINED) 消息：函数&#39;%s&#39;未定义。 错误：1129 SQLSTATE: HY000 (ER_HOST_IS_BLOCKED) 消息：由于存在很多连接错误，主机&#39;%s&#39;被屏蔽，请用&#39;mysqladmin flush-hosts&#39;解除屏蔽。 错误：1130 SQLSTATE: HY000 (ER_HOST_NOT_PRIVILEGED) 消息：不允许将主机&#39;%s&#39;连接到该MySQL服务器。 错误：1131 SQLSTATE: 42000 (ER_PASSWORD_ANONYMOUS_USER) 消息：你正在已匿名用户身份使用MySQL，不允许匿名用户更改密码。 错误：1132 SQLSTATE: 42000 (ER_PASSWORD_NOT_ALLOWED) 消息：必须有更新mysql数据库中表的权限才能更改密码。 错误：1133 SQLSTATE: 42000 (ER_PASSWORD_NO_MATCH) 消息：无法在用户表中找到匹配行。 错误：1134 SQLSTATE: HY000 (ER_UPDATE_INFO) 消息：行匹配，%ld；已更改，%ld；警告，%ld 错误：1135 SQLSTATE: HY000 (ER_CANT_CREATE_THREAD) 消息：无法创建新线程(errno %d)，如果未出现内存溢出，请参阅手册以了解可能的与操作系统有关的缺陷。 错误：1136 SQLSTATE: 21S01 (ER_WRONG_VALUE_COUNT_ON_ROW) 消息：列计数不匹配行%ld上的值计数。 错误：1137 SQLSTATE: HY000 (ER_CANT_REOPEN_TABLE) 消息：无法再次打开表&#39;%s&#39;。 错误：1138 SQLSTATE: 22004 (ER_INVALID_USE_OF_NULL) 消息：NULL值使用无效。 错误：1139 SQLSTATE: 42000 (ER_REGEXP_ERROR) 消息：获得来自regexp的错误&#39;%s&#39;。 错误：1140 SQLSTATE: 42000 (ER_MIX_OF_GROUP_FUNC_AND_FIELDS) 消息：如果没有GROUP BY子句，GROUP列 (MIN(),MAX(),COUNT(),...)与非GROUP列的混合不合法。 错误：1141 SQLSTATE: 42000 (ER_NONEXISTING_GRANT) 消息：没有为主机&#39;%s&#39;上的用户&#39;%s&#39;定义这类授权。 错误：1142 SQLSTATE: 42000 (ER_TABLEACCESS_DENIED_ERROR) 消息：拒绝用户&#39;%s&#39;@&#39;%s&#39;在表&#39;%s&#39;上使用%s命令。 错误：1143 SQLSTATE: 42000 (ER_COLUMNACCESS_DENIED_ERROR) 消息：拒绝用户&#39;%s&#39;@&#39;%s&#39;在表&#39;%s&#39;的&#39;%s&#39;上使用%s命令。 错误：1144 SQLSTATE: 42000 (ER_ILLEGAL_GRANT_FOR_TABLE) 消息：非法GRANT/REVOKE命令，请参阅手册以了解可使用那种权限。 错误：1145 SQLSTATE: 42000 (ER_GRANT_WRONG_HOST_OR_USER) 消息：GRANT的主机或用户参量过长。 错误：1146 SQLSTATE: 42S02 (ER_NO_SUCH_TABLE) 消息：表&#39;%s.%s&#39;不存在。 错误：1147 SQLSTATE: 42000 (ER_NONEXISTING_TABLE_GRANT) 消息：在表&#39;%s&#39;上没有为主机&#39;%s&#39;上的用户&#39;%s&#39;定义的这类授权。 错误：1148 SQLSTATE: 42000 (ER_NOT_ALLOWED_COMMAND) 消息：所使用的命令在该MySQL版本中不允许。 错误：1149 SQLSTATE: 42000 (ER_SYNTAX_ERROR) 消息：存在SQL语法错误，请参阅与你的MySQL版本对应的手册，以了解正确的语法。 错误：1150 SQLSTATE: HY000 (ER_DELAYED_CANT_CHANGE_LOCK) 消息：对于表%s，延迟的插入线程不能获得请求的锁定。 错误：1151 SQLSTATE: HY000 (ER_TOO_MANY_DELAYED_THREADS) 消息：使用的延迟线程过多。 错误：1152 SQLSTATE: 08S01 (ER_ABORTING_CONNECTION) 消息：与数据库&#39;%s&#39;和用户&#39;%s&#39;的连接%ld失败 (%s) 错误：1153 SQLSTATE: 08S01 (ER_NET_PACKET_TOO_LARGE) 消息：获得信息包大于&#39;max_allowed_packet&#39;字节。 错误：1154 SQLSTATE: 08S01 (ER_NET_READ_ERROR_FROM_PIPE) 消息：获得来自连接管道的读错误。 错误：1155 SQLSTATE: 08S01 (ER_NET_FCNTL_ERROR) 消息：获得来自fcntl()的错误。 错误：1156 SQLSTATE: 08S01 (ER_NET_PACKETS_OUT_OF_ORDER) 消息：获得信息包无序。 错误：1157 SQLSTATE: 08S01 (ER_NET_UNCOMPRESS_ERROR) 消息：无法解压缩通信信息包。 错误：1158 SQLSTATE: 08S01 (ER_NET_READ_ERROR) 消息：读取通信信息包时出错。 错误：1159 SQLSTATE: 08S01 (ER_NET_READ_INTERRUPTED) 消息：读取通信信息包时出现超时。 错误：1160 SQLSTATE: 08S01 (ER_NET_ERROR_ON_WRITE) 消息：写入通信信息包时出错。 错误：1161 SQLSTATE: 08S01 (ER_NET_WRITE_INTERRUPTED) 消息：写入通信信息包时出现超时。 错误：1162 SQLSTATE: 42000 (ER_TOO_LONG_STRING) 消息：结果字符串长于&#39;max_allowed_packet&#39;字节。 错误：1163 SQLSTATE: 42000 (ER_TABLE_CANT_HANDLE_BLOB) 消息：所使用的表类型不支持BLOB/TEXT列。 错误：1164 SQLSTATE: 42000 (ER_TABLE_CANT_HANDLE_AUTO_INCREMENT) 消息：所使用的表类型不支持AUTO_INCREMENT列。 错误：1165 SQLSTATE: HY000 (ER_DELAYED_INSERT_TABLE_LOCKED) 消息：由于用LOCK TABLES锁定了表，INSERT DELAYED不能与表&#39;%s&#39;一起使用。 错误：1166 SQLSTATE: 42000 (ER_WRONG_COLUMN_NAME) 消息：不正确的列名&#39;%s&#39;。 错误：1167 SQLSTATE: 42000 (ER_WRONG_KEY_COLUMN) 消息：所使用的存储引擎不能为列&#39;%s&#39;编制索引。 错误：1168 SQLSTATE: HY000 (ER_WRONG_MRG_TABLE) 消息：MERGE表中的所有表未同等定义。 错误：1169 SQLSTATE: 23000 (ER_DUP_UNIQUE) 消息：由于唯一性限制，不能写入到表&#39;%s&#39;。 错误：1170 SQLSTATE: 42000 (ER_BLOB_KEY_WITHOUT_LENGTH) 消息：在未指定键长度的键说明中使用了BLOB/TEXT列&#39;%s&#39;。 错误：1171 SQLSTATE: 42000 (ER_PRIMARY_CANT_HAVE_NULL) 消息：PRIMARY KEY的所有部分必须是NOT NULL，如果需要为NULL的关键字，请使用UNIQUE取而代之。 错误：1172 SQLSTATE: 42000 (ER_TOO_MANY_ROWS) 消息：结果有1个以上的行组成。 错误：1173 SQLSTATE: 42000 (ER_REQUIRES_PRIMARY_KEY) 消息：该表类型要求主键。 错误：1174 SQLSTATE: HY000 (ER_NO_RAID_COMPILED) 消息：该MySQL版本是未使用RAID支持而编译的。 错误：1175 SQLSTATE: HY000 (ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE) 消息：你正在使用安全更新模式，而且试图在不使用WHERE的情况下更新使用了KEY列的表。 错误：1176 SQLSTATE: HY000 (ER_KEY_DOES_NOT_EXITS) 消息：在表&#39;%s&#39;中，键&#39;%s&#39;不存在。 错误：1177 SQLSTATE: 42000 (ER_CHECK_NO_SUCH_TABLE) 消息：无法打开表。 错误：1178 SQLSTATE: 42000 (ER_CHECK_NOT_IMPLEMENTED) 消息：用于表的引擎不支持%s。 错误：1179 SQLSTATE: 25000 (ER_CANT_DO_THIS_DURING_AN_TRANSACTION) 消息：不允许在事务中执行该命令。 错误：1180 SQLSTATE: HY000 (ER_ERROR_DURING_COMMIT) 消息：在COMMIT期间出现错误%d。 错误：1181 SQLSTATE: HY000 (ER_ERROR_DURING_ROLLBACK) 消息：在ROLLBACK期间出现错误%d。 错误：1182 SQLSTATE: HY000 (ER_ERROR_DURING_FLUSH_LOGS) 消息：在FLUSH_LOGS期间出现错误%d。 错误：1183 SQLSTATE: HY000 (ER_ERROR_DURING_CHECKPOINT) 消息：在CHECKPOINT期间出现错误%d。 错误：1184 SQLSTATE: 08S01 (ER_NEW_ABORTING_CONNECTION) 消息：与数据库&#39;%s&#39;、用户&#39;%s&#39;和主机&#39;%s&#39;的连接%ld失败 (%s)。 错误：1185 SQLSTATE: HY000 (ER_DUMP_NOT_IMPLEMENTED) 消息：针对表的存储引擎不支持二进制表转储。 错误：1186 SQLSTATE: HY000 (ER_FLUSH_MASTER_BINLOG_CLOSED) 消息：Binlog已关闭，不能RESET MASTER。 错误：1187 SQLSTATE: HY000 (ER_INDEX_REBUILD) 消息：重新创建转储表&#39;%s&#39;的索引失败。 错误：1188 SQLSTATE: HY000 (ER_MASTER) 消息：来自主连接&#39;%s&#39;的错误。 错误：1189 SQLSTATE: 08S01 (ER_MASTER_NET_READ) 消息：读取主连接时出现网络错误。 错误：1190 SQLSTATE: 08S01 (ER_MASTER_NET_WRITE) 消息：写入主连接时出现网络错误。 错误：1191 SQLSTATE: HY000 (ER_FT_MATCHING_KEY_NOT_FOUND) 消息：无法找到与列列表匹配的FULLTEXT索引。 错误：1192 SQLSTATE: HY000 (ER_LOCK_OR_ACTIVE_TRANSACTION) 消息：由于存在活动的锁定表或活动的事务，不能执行给定的命令。 错误：1193 SQLSTATE: HY000 (ER_UNKNOWN_SYSTEM_VARIABLE) 消息：未知的系统变量&#39;%s&#39;。 错误：1194 SQLSTATE: HY000 (ER_CRASHED_ON_USAGE) 消息：表&#39;%s&#39;被标记为崩溃，应予以修复。 错误：1195 SQLSTATE: HY000 (ER_CRASHED_ON_REPAIR) 消息：表&#39;%s&#39;被标记为崩溃，而且上次修复失败（自动？） 错误：1196 SQLSTATE: HY000 (ER_WARNING_NOT_COMPLETE_ROLLBACK) 消息：不能回滚某些非事务性已变动表。 错误：1197 SQLSTATE: HY000 (ER_TRANS_CACHE_FULL) 消息：多语句事务要求更多的&#39;max_binlog_cache_size&#39;存储字节，增大mysqld变量，并再次尝试。 错误：1198 SQLSTATE: HY000 (ER_SLAVE_MUST_STOP) 消息：运行从实例时不能执行该操作，请首先运行STOP SLAVE。 错误：1199 SQLSTATE: HY000 (ER_SLAVE_NOT_RUNNING) 消息：该操作需要运行的从实例，请配置SLAVE并执行START SLAVE。 错误：1200 SQLSTATE: HY000 (ER_BAD_SLAVE) 消息：服务器未配置为从服务器，请更正config文件，或使用CHANGE MASTER TO。 错误：1201 SQLSTATE: HY000 (ER_MASTER_INFO) 消息：无法初始化主服务器信息结构，在MySQL错误日志中可找到更多错误消息。 错误：1202 SQLSTATE: HY000 (ER_SLAVE_THREAD) 消息：无法创建从线程，请检查系统资源。 错误：1203 SQLSTATE: 42000 (ER_TOO_MANY_USER_CONNECTIONS) 消息：用户%s已有了超过&#39;max_user_connections&#39;的活动连接。 错误：1204 SQLSTATE: HY000 (ER_SET_CONSTANTS_ONLY) 消息：或许仅应与SET一起使用常量表达式。 错误：1205 SQLSTATE: HY000 (ER_LOCK_WAIT_TIMEOUT) 消息：超过了锁定等待超时，请尝试重新启动事务。 错误：1206 SQLSTATE: HY000 (ER_LOCK_TABLE_FULL) 消息：总的锁定数超出了锁定表的大小。 错误：1207 SQLSTATE: 25000 (ER_READ_ONLY_TRANSACTION) 消息：在READ UNCOMMITTED事务期间，无法获得更新锁定。 错误：1208 SQLSTATE: HY000 (ER_DROP_DB_WITH_READ_LOCK) 消息：当线程保持为全局读锁定时，不允许DROP DATABASE。 错误：1209 SQLSTATE: HY000 (ER_CREATE_DB_WITH_READ_LOCK) 消息：当线程保持为全局读锁定时，不允许CREATE DATABASE。 错误：1210 SQLSTATE: HY000 (ER_WRONG_ARGUMENTS) 消息：为%s提供的参量不正确。 错误：1211 SQLSTATE: 42000 (ER_NO_PERMISSION_TO_CREATE_USER) 消息：不允许&#39;%s&#39;@&#39;%s&#39;创建新用户。 错误：1212 SQLSTATE: HY000 (ER_UNION_TABLES_IN_DIFFERENT_DIR) 消息：不正确的表定义，所有的MERGE表必须位于相同的数据库中。 错误：1213 SQLSTATE: 40001 (ER_LOCK_DEADLOCK) 消息：试图获取锁定时发现死锁，请尝试重新启动事务。 错误：1214 SQLSTATE: HY000 (ER_TABLE_CANT_HANDLE_FT) 消息：所使用的表类型不支持FULLTEXT索引。 错误：1215 SQLSTATE: HY000 (ER_CANNOT_ADD_FOREIGN) 消息：无法添加外键约束。 错误：1216 SQLSTATE: 23000 (ER_NO_REFERENCED_ROW) 消息：无法添加或更新子行，外键约束失败。 错误：1217 SQLSTATE: 23000 (ER_ROW_IS_REFERENCED) 消息：无法删除或更新父行，外键约束失败。 错误：1218 SQLSTATE: 08S01 (ER_CONNECT_TO_MASTER) 消息：连接至主服务器%s时出错。 错误：1219 SQLSTATE: HY000 (ER_QUERY_ON_MASTER) 消息：在主服务器%s上执行查询时出错。 错误：1220 SQLSTATE: HY000 (ER_ERROR_WHEN_EXECUTING_COMMAND) 消息：执行命令%s: %s时出错。 错误：1221 SQLSTATE: HY000 (ER_WRONG_USAGE) 消息：%s和%s的用法不正确。 错误：1222 SQLSTATE: 21000 (ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT) 消息：所使用的SELECT语句有不同的列数。 错误：1223 SQLSTATE: HY000 (ER_CANT_UPDATE_WITH_READLOCK) 消息：由于存在冲突的读锁定，无法执行查询。 错误：1224 SQLSTATE: HY000 (ER_MIXING_NOT_ALLOWED) 消息：禁止混合事务性表和非事务性表。 错误：1225 SQLSTATE: HY000 (ER_DUP_ARGUMENT) 消息：在语句中使用了两次选项&#39;%s&#39;。 错误：1226 SQLSTATE: 42000 (ER_USER_LIMIT_REACHED) 消息：用户&#39;%s&#39;超出了&#39;%s&#39;资源（当前值：%ld）。 错误：1227 SQLSTATE: 42000 (ER_SPECIFIC_ACCESS_DENIED_ERROR) 消息：拒绝访问，需要%s权限才能执行该操作。 错误：1228 SQLSTATE: HY000 (ER_LOCAL_VARIABLE) 消息：变量&#39;%s&#39;是1种SESSION变量，不能与SET GLOBAL一起使用。 错误：1229 SQLSTATE: HY000 (ER_GLOBAL_VARIABLE) 消息：变量&#39;%s&#39;是1种GLOBAL变量，应使用SET GLOBAL来设置它。 错误：1230 SQLSTATE: 42000 (ER_NO_DEFAULT) 消息：变量&#39;%s&#39;没有默认值。 错误：1231 SQLSTATE: 42000 (ER_WRONG_VALUE_FOR_VAR) 消息：变量&#39;%s&#39;不能设置为值&#39;%s&#39;。 错误：1232 SQLSTATE: 42000 (ER_WRONG_TYPE_FOR_VAR) 消息：变量&#39;%s&#39;的参量类型不正确。 错误：1233 SQLSTATE: HY000 (ER_VAR_CANT_BE_READ) 消息：变量&#39;%s&#39;只能被设置，不能被读取。 错误：1234 SQLSTATE: 42000 (ER_CANT_USE_OPTION_HERE) * 消息：不正确的&#39;%s&#39;用法/位置。 错误：1235 SQLSTATE: 42000 (ER_NOT_SUPPORTED_YET) 消息：该MySQL版本尚不支持&#39;%s&#39;。 错误：1236 SQLSTATE: HY000 (ER_MASTER_FATAL_ERROR_READING_BINLOG) 消息：从二进制日志读取数据时，获得来自主服务器的致命错误%d: &#39;%s&#39;。 错误：1237 SQLSTATE: HY000 (ER_SLAVE_IGNORED_TABLE) 消息：由于“replicate-*-table”规则，从SQL线程忽略了查询。。 错误：1238 SQLSTATE: HY000 (ER_INCORRECT_GLOBAL_LOCAL_VAR) 消息：变量&#39;%s&#39;是一种%s变量。 错误：1239 SQLSTATE: 42000 (ER_WRONG_FK_DEF) 消息：对于 &#39;%s&#39;: %s， 外键定义不正确。 错误：1240 SQLSTATE: HY000 (ER_KEY_REF_DO_NOT_MATCH_TABLE_REF) 消息：键引用和表引用不匹配。 错误：1241 SQLSTATE: 21000 (ER_OPERAND_COLUMNS) 消息：操作数应包含%d列。 错误：1242 SQLSTATE: 21000 (ER_SUBQUERY_NO_1_ROW) 消息：子查询返回1行以上。 错误：1243 SQLSTATE: HY000 (ER_UNKNOWN_STMT_HANDLER) 消息：指定给%s的未知预处理语句句柄。 错误：1244 SQLSTATE: HY000 (ER_CORRUPT_HELP_DB) 消息：帮助数据库崩溃或不存在。 错误：1245 SQLSTATE: HY000 (ER_CYCLIC_REFERENCE) 消息：对子查询的循环引用。 错误：1246 SQLSTATE: HY000 (ER_AUTO_CONVERT) 消息：将列&#39;%s&#39;从%s转换为%s。 错误：1247 SQLSTATE: 42S22 (ER_ILLEGAL_REFERENCE) 消息：引用&#39;%s&#39;不被支持 (%s)。 错误：1248 SQLSTATE: 42000 (ER_DERIVED_MUST_HAVE_ALIAS) 消息：所有的导出表必须有自己的别名。 错误：1249 SQLSTATE: 01000 (ER_SELECT_REDUCED) 消息：在优化期间简化了选择%u。 错误：1250 SQLSTATE: 42000 (ER_TABLENAME_NOT_ALLOWED_HERE) 消息：来自某一SELECT的表&#39;%s&#39;不能在%s中使用。 错误：1251 SQLSTATE: 08004 (ER_NOT_SUPPORTED_AUTH_MODE) 消息：客户端不支持服务器请求的鉴定协议，请考虑升级MySQL客户端。 错误：1252 SQLSTATE: 42000 (ER_SPATIAL_CANT_HAVE_NULL) 消息：SPATIAL索引的所有部分必须是NOT NULL。 错误：1253 SQLSTATE: 42000 (ER_COLLATION_CHARSET_MISMATCH) 消息：对于CHARACTER SET &#39;%s&#39;，COLLATION &#39;%s&#39;无效。 错误：1254 SQLSTATE: HY000 (ER_SLAVE_WAS_RUNNING) 消息：从服务器正在运行。 错误：1255 SQLSTATE: HY000 (ER_SLAVE_WAS_NOT_RUNNING) 消息：从服务器已停止。 错误：1256 SQLSTATE: HY000 (ER_TOO_BIG_FOR_UNCOMPRESS) 消息：解压的数据过大，最大大小为%d（也可能是，解压数据的长度已损坏）。 错误：1257 SQLSTATE: HY000 (ER_ZLIB_Z_MEM_ERROR) 消息：ZLIB，无足够内存。 错误：1258 SQLSTATE: HY000 (ER_ZLIB_Z_BUF_ERROR) 消息：ZLIB，输出缓冲区内无足够空间（也可能是，解压数据的长度已损坏）。 错误：1259 SQLSTATE: HY000 (ER_ZLIB_Z_DATA_ERROR) 消息：ZLIB，输入数据已损坏。 错误：1260 SQLSTATE: HY000 (ER_CUT_VALUE_GROUP_CONCAT) 消息：%d行被GROUP_CONCAT()截去。 错误：1261 SQLSTATE: 01000 (ER_WARN_TOO_FEW_RECORDS) 消息：行%ld不包含所有列的数据。 错误：1262 SQLSTATE: 01000 (ER_WARN_TOO_MANY_RECORDS) 消息：行%ld被解短，它包含的数据大于输入列中的数据。 错误：1263 SQLSTATE: 22004 (ER_WARN_NULL_TO_NOTNULL) 消息：列被设为默认值，在行%ld上将NULL提供给了NOT NULL列。 错误：1264 SQLSTATE: 22003 (ER_WARN_DATA_OUT_OF_RANGE) 消息：为行%ld上的列&#39;%s&#39;调整超出范围的值。 错误：1265 SQLSTATE: 01000 (WARN_DATA_TRUNCATED) 消息：为行%ld上的列&#39;%s&#39;截短数据。 错误：1266 SQLSTATE: HY000 (ER_WARN_USING_OTHER_HANDLER) 消息：为表%s使用存储引擎%s。 错误：1267 SQLSTATE: HY000 (ER_CANT_AGGREGATE_2COLLATIONS) 消息：对于操作&#39;%s&#39;，非法混合了校对(%s,%s)和(%s,%s)。 错误：1268 SQLSTATE: HY000 (ER_DROP_USER) 消息：无法撤销1个或多个请求的用户。 错误：1269 SQLSTATE: HY000 (ER_REVOKE_GRANTS) 消息：无法撤销所有权限，为1个或多个请求的用户授权。 错误：1270 SQLSTATE: HY000 (ER_CANT_AGGREGATE_3COLLATIONS) 消息：对于操作&#39;%s&#39;，非法混合了校对(%s,%s)、(%s,%s)和(%s,%s)。 错误：1271 SQLSTATE: HY000 (ER_CANT_AGGREGATE_NCOLLATIONS) 消息：对于操作&#39;%s&#39;，非法混合了校对。 错误：1272 SQLSTATE: HY000 (ER_VARIABLE_IS_NOT_STRUCT) 消息：变量&#39;%s&#39;不是变量组分（不能用作XXXX.variable_name）。 错误：1273 SQLSTATE: HY000 (ER_UNKNOWN_COLLATION) 消息：未知校对&#39;%s&#39;。 错误：1274 SQLSTATE: HY000 (ER_SLAVE_IGNORED_SSL_PARAMS) 消息：由于该MySQL从服务器是在不支持SSL的情况下编译的，CHANGE MASTER中的SSL参数被忽略，随后，如果启动了具备 SSL 功能的 MySQL，可使用这些参数。 错误：1275 SQLSTATE: HY000 (ER_SERVER_IS_IN_SECURE_AUTH_MODE) 消息：服务器正运行在“--secure-auth”模式下，但&#39;%s&#39;@&#39;%s&#39;有1个采用旧格式的密码，请将密码更改为新格式。 错误：1276 SQLSTATE: HY000 (ER_WARN_FIELD_RESOLVED) 消息：SELECT #%d的字段或引用&#39;%s%s%s%s%s&#39;是在SELECT #%d中确定的。 错误：1277 SQLSTATE: HY000 (ER_BAD_SLAVE_UNTIL_COND) 消息：对于START SLAVE UNTIL，不正确的参数或参数组合。 错误：1278 SQLSTATE: HY000 (ER_MISSING_SKIP_SLAVE) 消息：与START SLAVE UNTIL一起执行按步复制时，建议使用“--skip-slave-start”，否则，如果发生未预料的从服务器 mysqld 重启，间出现问题。 错误：1279 SQLSTATE: HY000 (ER_UNTIL_COND_IGNORED) 消息：SQL线程未启动，因而UNTIL选项被忽略。 错误：1280 SQLSTATE: 42000 (ER_WRONG_NAME_FOR_INDEX) 消息：不正确的索引名&#39;%s&#39;。 错误：1281 SQLSTATE: 42000 (ER_WRONG_NAME_FOR_CATALOG) 消息：不正确的目录名&#39;%s&#39;。 错误：1282 SQLSTATE: HY000 (ER_WARN_QC_RESIZE) 消息：查询高速缓冲设置大小%lu时失败，新的查询高速缓冲的大小是%lu。 错误：1283 SQLSTATE: HY000 (ER_BAD_FT_COLUMN) 消息：列&#39;%s&#39;不能是FULLTEXT索引的一部分。 错误：1284 SQLSTATE: HY000 (ER_UNKNOWN_KEY_CACHE) 消息：未知的键高速缓冲&#39;%s&#39;。 错误：1285 SQLSTATE: HY000 (ER_WARN_HOSTNAME_WONT_WORK) 消息：MySQL是在“--skip-name-resolve”模式下启动的，必须在不使用该开关的情况下重启它，以便该授权能起作用。 错误：1286 SQLSTATE: 42000 (ER_UNKNOWN_STORAGE_ENGINE) 消息：未知的表引擎&#39;%s&#39;。 错误：1287 SQLSTATE: HY000 (ER_WARN_DEPRECATED_SYNTAX) 消息：&#39;%s&#39;已过时，请使用&#39;%s&#39;取而代之。 错误：1288 SQLSTATE: HY000 (ER_NON_UPDATABLE_TABLE) 消息：%s的目标表%s不可更新。 错误：1289 SQLSTATE: HY000 (ER_FEATURE_DISABLED) 消息：&#39;%s&#39;特性已被禁止，要想使其工作，需要用&#39;%s&#39;创建MySQL。 错误：1290 SQLSTATE: HY000 (ER_OPTION_PREVENTS_STATEMENT) 消息：MySQL正使用%s选项运行，因此不能执行该语句。 错误：1291 SQLSTATE: HY000 (ER_DUPLICATED_VALUE_IN_TYPE) 消息：列&#39;%s&#39;在%s中有重复值&#39;%s&#39;。 错误：1292 SQLSTATE: 22007 (ER_TRUNCATED_WRONG_VALUE) 消息：截短了不正确的%s值: &#39;%s&#39; 错误：1293 SQLSTATE: HY000 (ER_TOO_MUCH_AUTO_TIMESTAMP_COLS) 消息：不正确的表定义，在DEFAULT或ON UPDATE子句中，对于CURRENT_TIMESTAMP，只能有一个TIMESTAMP列。 错误：1294 SQLSTATE: HY000 (ER_INVALID_ON_UPDATE) 消息：对于&#39;%s&#39;列，ON UPDATE子句无效。 错误：1295 SQLSTATE: HY000 (ER_UNSUPPORTED_PS) 消息：在预处理语句协议中，尚不支持该命令。 错误：1296 SQLSTATE: HY000 (ER_GET_ERRMSG) 消息：从%s获得错误%d &#39;%s&#39;。 错误：1297 SQLSTATE: HY000 (ER_GET_TEMPORARY_ERRMSG) 消息：从%s获得临时错误%d &#39;%s&#39;。 错误：1298 SQLSTATE: HY000 (ER_UNKNOWN_TIME_ZONE) 消息：未知或不正确的时区: &#39;%s&#39; 错误：1299 SQLSTATE: HY000 (ER_WARN_INVALID_TIMESTAMP) 消息：在行%ld的列&#39;%s&#39;中存在无效的TIMESTAMP值。 错误：1300 SQLSTATE: HY000 (ER_INVALID_CHARACTER_STRING) 消息：无效的%s字符串: &#39;%s&#39; 错误：1301 SQLSTATE: HY000 (ER_WARN_ALLOWED_PACKET_OVERFLOWED) 消息：%s()的结果大于max_allowed_packet (%ld)，已截短 错误：1302 SQLSTATE: HY000 (ER_CONFLICTING_DECLARATIONS) 消息：冲突声明：&#39;%s%s&#39;和&#39;%s%s&#39; 错误：1303 SQLSTATE: 2F003 (ER_SP_NO_RECURSIVE_CREATE) 消息：不能从另一个存储子程序中创建%s。 错误：1304 SQLSTATE: 42000 (ER_SP_ALREADY_EXISTS) 消息：%s %s已存在。 错误：1305 SQLSTATE: 42000 (ER_SP_DOES_NOT_EXIST) 消息：%s %s不存在。 错误：1306 SQLSTATE: HY000 (ER_SP_DROP_FAILED) 消息：DROP %s %s失败 错误：1307 SQLSTATE: HY000 (ER_SP_STORE_FAILED) 消息：CREATE %s %s失败。 错误：1308 SQLSTATE: 42000 (ER_SP_LILABEL_MISMATCH) 消息：%s无匹配标签: %s 错误：1309 SQLSTATE: 42000 (ER_SP_LABEL_REDEFINE) 消息：重新定义标签%s 错误：1310 SQLSTATE: 42000 (ER_SP_LABEL_MISMATCH) 消息：末端标签%s无匹配项 错误：1311 SQLSTATE: 01000 (ER_SP_UNINIT_VAR) 消息：正在引用未初始化的变量%s。 错误：1312 SQLSTATE: 0A000 (ER_SP_BADSELECT) 消息：PROCEDURE %s不能在给定场景下返回结果集。 错误：1313 SQLSTATE: 42000 (ER_SP_BADRETURN) 消息：仅在FUNCTION中允许RETURN。 错误：1314 SQLSTATE: 0A000 (ER_SP_BADSTATEMENT) 消息：在存储程序中不允许%s。 错误：1315 SQLSTATE: 42000 (ER_UPDATE_LOG_DEPRECATED_IGNORED) 消息：更新日志已被放弃，并用二进制日志取代，SET SQL_LOG_UPDATE被忽略。 错误：1316 SQLSTATE: 42000 (ER_UPDATE_LOG_DEPRECATED_TRANSLATED) 消息：更新日志已被放弃，并用二进制日志取代，SET SQL_LOG_UPDATE已被截短为SET SQL_LOG_BIN。 错误：1317 SQLSTATE: 70100 (ER_QUERY_INTERRUPTED) 消息：查询执行被中断。 错误：1318 SQLSTATE: 42000 (ER_SP_WRONG_NO_OF_ARGS) 消息：对于%s %s，参量数目不正确，预期为%u，但却是%u。 错误：1319 SQLSTATE: 42000 (ER_SP_COND_MISMATCH) 消息：未定义的CONDITION: %s 错误：1320 SQLSTATE: 42000 (ER_SP_NORETURN) 消息：在FUNCTION %s中未发现RETURN。 错误：1321 SQLSTATE: 2F005 (ER_SP_NORETURNEND) 消息：FUNCTION %s结束时缺少RETURN。 错误：1322 SQLSTATE: 42000 (ER_SP_BAD_CURSOR_QUERY) 消息：光标语句必须是SELECT。 错误：1323 SQLSTATE: 42000 (ER_SP_BAD_CURSOR_SELECT) 消息：光标SELECT不得有INTO。 错误：1324 SQLSTATE: 42000 (ER_SP_CURSOR_MISMATCH) 消息：未定义的CURSOR: %s 错误：1325 SQLSTATE: 24000 (ER_SP_CURSOR_ALREADY_OPEN) 消息：光标已打开 错误：1326 SQLSTATE: 24000 (ER_SP_CURSOR_NOT_OPEN) 消息：光标未打开 错误：1327 SQLSTATE: 42000 (ER_SP_UNDECLARED_VAR) 消息：未声明的变量：%s 错误：1328 SQLSTATE: HY000 (ER_SP_WRONG_NO_OF_FETCH_ARGS) 消息：不正确的FETCH变量数目。 错误：1329 SQLSTATE: 02000 (ER_SP_FETCH_NO_DATA) 消息：FETCH无数据。 错误：1330 SQLSTATE: 42000 (ER_SP_DUP_PARAM) 消息：重复参数: %s 错误：1331 SQLSTATE: 42000 (ER_SP_DUP_VAR) 消息：重复变量: %s 错误：1332 SQLSTATE: 42000 (ER_SP_DUP_COND) 消息：重复条件: %s 错误：1333 SQLSTATE: 42000 (ER_SP_DUP_CURS) 消息：重复光标: %s 错误：1334 SQLSTATE: HY000 (ER_SP_CANT_ALTER) 消息：ALTER %s %s失败。 错误：1335 SQLSTATE: 0A000 (ER_SP_SUBSELECT_NYI) 消息：不支持Subselect值。 错误：1336 SQLSTATE: 0A000 (ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG) 消息：在存储函数或触发程序中，不允许%s。 错误：1337 SQLSTATE: 42000 (ER_SP_VARCOND_AFTER_CURSHNDLR) 消息：光标或句柄声明后面的变量或条件声明。 错误：1338 SQLSTATE: 42000 (ER_SP_CURSOR_AFTER_HANDLER) 消息：句柄声明后面的光标声明。 错误：1339 SQLSTATE: 20000 (ER_SP_CASE_NOT_FOUND) 消息：对于CASE语句，未发现Case。 错误：1340 SQLSTATE: HY000 (ER_FPARSER_TOO_BIG_FILE) 消息：配置文件&#39;%s&#39;过大。 错误：1341 SQLSTATE: HY000 (ER_FPARSER_BAD_HEADER) 消息：文件&#39;%s&#39;中存在残缺的文件类型标题。 错误：1342 SQLSTATE: HY000 (ER_FPARSER_EOF_IN_COMMENT) 消息：解析&#39;%s&#39;时，文件意外结束。 错误：1343 SQLSTATE: HY000 (ER_FPARSER_ERROR_IN_PARAMETER) 消息：解析参数&#39;%s&#39;时出错（行：&#39;%s&#39;）。 错误：1344 SQLSTATE: HY000 (ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER) 消息：跳过未知参数&#39;%s&#39;时，文件意外结束。 错误：1345 SQLSTATE: HY000 (ER_VIEW_NO_EXPLAIN) 消息：EXPLAIN/SHOW无法发出，缺少对基本表的权限。 错误：1346 SQLSTATE: HY000 (ER_FRM_UNKNOWN_TYPE) 消息：文件&#39;%s&#39;在其题头中有未知的类型&#39;%s&#39;。 错误：1347 SQLSTATE: HY000 (ER_WRONG_OBJECT) 消息：&#39;%s.%s&#39;不是%s。 错误：1348 SQLSTATE: HY000 (ER_NONUPDATEABLE_COLUMN) 消息：列&#39;%s&#39;不可更新。 错误：1349 SQLSTATE: HY000 (ER_VIEW_SELECT_DERIVED) 消息：视图的SELECT在FROM子句中包含子查询。 错误：1350 SQLSTATE: HY000 (ER_VIEW_SELECT_CLAUSE) 消息：视图的SELECT包含&#39;%s&#39;子句。 错误：1351 SQLSTATE: HY000 (ER_VIEW_SELECT_VARIABLE) 消息：视图的SELECT包含1个变量或参数。 错误：1352 SQLSTATE: HY000 (ER_VIEW_SELECT_TMPTABLE) 消息：视图的SELECT引用了临时表&#39;%s&#39;。 错误：1353 SQLSTATE: HY000 (ER_VIEW_WRONG_LIST) 消息：视图的SELECT和视图的字段列表有不同的列计数。 错误：1354 SQLSTATE: HY000 (ER_WARN_VIEW_MERGE) 消息：此时，不能在这里使用视图合并算法（假定未定义算法）。 错误：1355 SQLSTATE: HY000 (ER_WARN_VIEW_WITHOUT_KEY) 消息：正在更新的视图没有其基本表的完整键。 错误：1356 SQLSTATE: HY000 (ER_VIEW_INVALID) 消息：视图&#39;%s.%s&#39;引用了无效的表、列、或函数，或视图的定义程序／调用程序缺少使用它们的权限。 错误：1357 SQLSTATE: HY000 (ER_SP_NO_DROP_SP) 消息：无法从另一个存储子程序中撤销或更改%s。 错误：1358 SQLSTATE: HY000 (ER_SP_GOTO_IN_HNDLR) 消息：在存储子程序句柄中不允许GOTO。 错误：1359 SQLSTATE: HY000 (ER_TRG_ALREADY_EXISTS) 消息：触发程序已存在。 错误：1360 SQLSTATE: HY000 (ER_TRG_DOES_NOT_EXIST) 消息：触发程序不存在。 错误：1361 SQLSTATE: HY000 (ER_TRG_ON_VIEW_OR_TEMP_TABLE) 消息：触发程序的&#39;%s&#39;是视图或临时表。 错误：1362 SQLSTATE: HY000 (ER_TRG_CANT_CHANGE_ROW) 消息：在%strigger中，不允许更新%s行。 错误：1363 SQLSTATE: HY000 (ER_TRG_NO_SUCH_ROW_IN_TRG) 消息：在%s触发程序中没有%s行。 错误：1364 SQLSTATE: HY000 (ER_NO_DEFAULT_FOR_FIELD) 消息：字段&#39;%s&#39;没有默认值。 错误：1365 SQLSTATE: 22012 (ER_DIVISION_BY_ZERO) 消息：被0除。 错误：1366 SQLSTATE: HY000 (ER_TRUNCATED_WRONG_VALUE_FOR_FIELD) 消息：不正确的%s值，&#39;%s&#39;，对于行%ld 上的列&#39;%s&#39;。 错误：1367 SQLSTATE: 22007 (ER_ILLEGAL_VALUE_FOR_TYPE) 消息：解析过程中发现非法%s &#39;%s&#39;值。 错误：1368 SQLSTATE: HY000 (ER_VIEW_NONUPD_CHECK) 消息：不可更新视图&#39;%s.%s&#39;上的CHECK OPTION。 错误：1369 SQLSTATE: HY000 (ER_VIEW_CHECK_FAILED) 消息：CHECK OPTION失败，&#39;%s.%s&#39; 错误：1370 SQLSTATE: 42000 (ER_PROCACCESS_DENIED_ERROR) 消息：对于子程序&#39;%s&#39;，拒绝用户&#39;%s&#39;@&#39;%s&#39;使用%s命令。 错误：1371 SQLSTATE: HY000 (ER_RELAY_LOG_FAIL) 消息：清除旧中继日志失败，%s 错误：1372 SQLSTATE: HY000 (ER_PASSWD_LENGTH) 消息：密码混编应是%d位的十六进制数。 错误：1373 SQLSTATE: HY000 (ER_UNKNOWN_TARGET_BINLOG) 消息：在binlog索引中未发现目标日志。 错误：1374 SQLSTATE: HY000 (ER_IO_ERR_LOG_INDEX_READ) 消息：读取日志索引文件时出现I/O错误。 错误：1375 SQLSTATE: HY000 (ER_BINLOG_PURGE_PROHIBITED) 消息：服务器配置不允许binlog清除。 错误：1376 SQLSTATE: HY000 (ER_FSEEK_FAIL) 消息：fseek()失败。 错误：1377 SQLSTATE: HY000 (ER_BINLOG_PURGE_FATAL_ERR) 消息：在日志清除过程中出现致命错误。 错误：1378 SQLSTATE: HY000 (ER_LOG_IN_USE) 消息：可清除的日志正在使用，不能清除。 错误：1379 SQLSTATE: HY000 (ER_LOG_PURGE_UNKNOWN_ERR) 消息：在日志清除过程中出现未知错误。 错误：1380 SQLSTATE: HY000 (ER_RELAY_LOG_INIT) 消息：初始化中继日志位置失败，%s 错误：1381 SQLSTATE: HY000 (ER_NO_BINARY_LOGGING) 消息：未使用二进制日志功能。 错误：1382 SQLSTATE: HY000 (ER_RESERVED_SYNTAX) 消息：&#39;%s&#39;语法保留给MySQL服务器内部使用。 错误：1383 SQLSTATE: HY000 (ER_WSAS_FAILED) 消息：WSAStartup失败。 错误：1384 SQLSTATE: HY000 (ER_DIFF_GROUPS_PROC) 消息：尚不能用不同的组处理过程。 错误：1385 SQLSTATE: HY000 (ER_NO_GROUP_FOR_PROC) 消息：对于该过程，SELECT必须有1个组。 错误：1386 SQLSTATE: HY000 (ER_ORDER_WITH_PROC) 消息：不能与该过程一起使用ORDER子句。 错误：1387 SQLSTATE: HY000 (ER_LOGGING_PROHIBIT_CHANGING_OF) 消息：二进制日志功能和复制功能禁止更改全局服务器%s。 错误：1388 SQLSTATE: HY000 (ER_NO_FILE_MAPPING) 消息：无法映射文件: %s, errno: %d 错误：1389 SQLSTATE: HY000 (ER_WRONG_MAGIC) 消息：%s中有错 错误：1390 SQLSTATE: HY000 (ER_PS_MANY_PARAM) 消息：预处理语句包含过多的占位符。 错误：1391 SQLSTATE: HY000 (ER_KEY_PART_0) 消息：键部分&#39;%s&#39;的长度不能为0。 错误：1392 SQLSTATE: HY000 (ER_VIEW_CHECKSUM) 消息：视图文本校验和失败。 错误：1393 SQLSTATE: HY000 (ER_VIEW_MULTIUPDATE) 消息：无法通过联合视图&#39;%s.%s&#39;更改1个以上的基本表。 错误：1394 SQLSTATE: HY000 (ER_VIEW_NO_INSERT_FIELD_LIST) 消息：不能在没有字段列表的情况下插入联合视图&#39;%s.%s&#39;。 错误：1395 SQLSTATE: HY000 (ER_VIEW_DELETE_MERGE_VIEW) 消息：不能从联合视图&#39;%s.%s&#39;中删除。 错误：1396 SQLSTATE: HY000 (ER_CANNOT_USER) 消息：对于%s的操作%s失败。 错误：1397 SQLSTATE: XAE04 (ER_XAER_NOTA) 消息：XAER_NOTA: 未知XID 错误：1398 SQLSTATE: XAE05 (ER_XAER_INVAL) 消息：XAER_INVAL: 无效参量（或不支持的命令） 错误：1399 SQLSTATE: XAE07 (ER_XAER_RMFAIL) 消息：XAER_RMFAIL: 当全局事务处于%s状态时，不能执行命令。 错误：1400 SQLSTATE: XAE09 (ER_XAER_OUTSIDE) 消息：XAER_OUTSIDE: 某些工作是在全局事务外完成的。 错误：1401 SQLSTATE: XAE03 (ER_XAER_RMERR) 消息：XAER_RMERR: 在事务分支中出现致命错误，请检查数据一致性。 错误：1402 SQLSTATE: XA100 (ER_XA_RBROLLBACK) 消息：XA_RBROLLBACK: 回滚了事务分支。 错误：1403 SQLSTATE: 42000 (ER_NONEXISTING_PROC_GRANT) 消息：在子程序&#39;%s&#39;上没有为主机&#39;%s&#39;上的用户&#39;%s&#39;定义的这类授权。 错误：1404 SQLSTATE: HY000 (ER_PROC_AUTO_GRANT_FAIL) 消息：无法授予EXECUTE和ALTER ROUTINE权限。 错误：1405 SQLSTATE: HY000 (ER_PROC_AUTO_REVOKE_FAIL) 消息：无法撤销已放弃子程序上的所有权限。 错误：1406 SQLSTATE: 22001 (ER_DATA_TOO_LONG) 消息：对于行%ld上的列&#39;%s&#39;来说，数据过长。 错误：1407 SQLSTATE: 42000 (ER_SP_BAD_SQLSTATE) 消息：不良SQLSTATE: &#39;%s&#39; 错误：1408 SQLSTATE: HY000 (ER_STARTUP) 消息：%s，连接就绪；版本，&#39;%s&#39;；套接字，&#39;%s&#39;；端口，%d %s 错误：1409 SQLSTATE: HY000 (ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR) 消息：不能从具有固定大小行的文件中将值加载到变量。 错误：1410 SQLSTATE: 42000 (ER_CANT_CREATE_USER_WITH_GRANT) 消息：不允许用GRANT创建用户。 错误：1411 SQLSTATE: HY000 (ER_WRONG_VALUE_FOR_TYPE) 消息：不正确的%s值，&#39;%s&#39;，对于函数%s 错误：1412 SQLSTATE: HY000 (ER_TABLE_DEF_CHANGED) 消息：表定义已更改，请再次尝试事务。 错误：1413 SQLSTATE: 42000 (ER_SP_DUP_HANDLER) 消息：在相同块中声明了重复句柄。 错误：1414 SQLSTATE: 42000 (ER_SP_NOT_VAR_ARG) 消息：子程序%s的OUT或INOUT参量不是变量。 错误：1415 SQLSTATE: 0A000 (ER_SP_NO_RETSET) 消息：不允许从%s返回结果集。 错误：1416 SQLSTATE: 22003 (ER_CANT_CREATE_GEOMETRY_OBJECT) 消息：不能从发送给GEOMETRY字段的数据中获取几何对象。 错误：1417 SQLSTATE: HY000 (ER_FAILED_ROUTINE_BREAK_BINLOG) 消息：1个子程序失败，在其声明没有NO SQL或READS SQL DATA，而且二进制日志功能已启用，如果更新了非事务性表，二进制日志将丢失其变化信息。 错误：1418 SQLSTATE: HY000 (ER_BINLOG_UNSAFE_ROUTINE) 消息：在该子程序的在其声明没有DETERMINISTIC、NO SQL或READS SQL DATA，而且二进制日志功能已启用（你或许打算使用不太安全的 log_bin_trust_routine_creators 变量）。 错误：1419 SQLSTATE: HY000 (ER_BINLOG_CREATE_ROUTINE_NEED_SUPER) 消息：你没有SUPER权限，而且二进制日志功能已启用（你或许打算使用不太安全的 log_bin_trust_routine_creators 变量）。 错误：1420 SQLSTATE: HY000 (ER_EXEC_STMT_WITH_OPEN_CURSOR) 消息：不能执行该预处理语句，该预处理语句有与之相关的打开光标。请复位语句并再次执行。 错误：1421 SQLSTATE: HY000 (ER_STMT_HAS_NO_OPEN_CURSOR) 消息：语句(%lu)没有打开的光标。 错误：1422 SQLSTATE: HY000 (ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG) 消息：在存储函数或触发程序中，不允许显式或隐式提交。 错误：1423 SQLSTATE: HY000 (ER_NO_DEFAULT_FOR_VIEW_FIELD) 消息：视图&#39;%s.%s&#39;基本表的字段没有默认值。 错误：1424 SQLSTATE: HY000 (ER_SP_NO_RECURSION) 消息：不允许递归存储子程序。 错误：1425 SQLSTATE: 42000 (ER_TOO_BIG_SCALE) 消息：为列&#39;%s&#39;指定了过大的标度%d。最大为%d。 错误：1426 SQLSTATE: 42000 (ER_TOO_BIG_PRECISION) 消息：为列&#39;%s&#39;指定了过高的精度%d。最大为%d。 错误：1427 SQLSTATE: 42000 (ER_M_BIGGER_THAN_D) 消息：对于float(M,D)、double(M,D)或decimal(M,D)，M必须&gt;= D (列&#39;%s&#39;)。 错误：1428 SQLSTATE: HY000 (ER_WRONG_LOCK_OF_SYSTEM_TABLE) 消息：不能将系统&#39;%s.%s&#39;表的写锁定与其他表结合起来。 错误：1429 SQLSTATE: HY000 (ER_CONNECT_TO_FOREIGN_DATA_SOURCE) 消息：无法连接到外部数据源，数据库&#39;%s&#39;！ 错误：1430 SQLSTATE: HY000 (ER_QUERY_ON_FOREIGN_DATA_SOURCE) 消息：处理作用在外部数据源上的查询时出现问题。数据源错误：&#39;%s&#39; 错误：1431 SQLSTATE: HY000 (ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST) 消息：你试图引用的外部数据源不存在。数据源错误：&#39;%s&#39; 错误：1432 SQLSTATE: HY000 (ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE) 消息：无法创建联合表。数据源连接字符串&#39;%s&#39;格式不正确。 错误：1433 SQLSTATE: HY000 (ER_FOREIGN_DATA_STRING_INVALID) 消息：数据源连接字符串&#39;%s&#39;格式不正确。 错误：1434 SQLSTATE: HY000 (ER_CANT_CREATE_FEDERATED_TABLE) 消息：无法创建联合表。外部数据源错误：&#39;%s&#39; 错误：1435 SQLSTATE: HY000 (ER_TRG_IN_WRONG_SCHEMA) 消息：触发程序位于错误的方案中。 错误：1436 SQLSTATE: HY000 (ER_STACK_OVERRUN_NEED_MORE) 消息：线程堆栈溢出，%ld字节堆栈用了%ld字节，并需要%ld字节。请使用&#39;mysqld -O thread_stack=#&#39;指定更大的堆栈。 错误：1437 SQLSTATE: 42000 (ER_TOO_LONG_BODY) 消息：&#39;%s&#39;的子程序主体过长。 错误：1438 SQLSTATE: HY000 (ER_WARN_CANT_DROP_DEFAULT_KEYCACHE) 消息：无法撤销默认的keycache。 错误：1439 SQLSTATE: 42000 (ER_TOO_BIG_DISPLAYWIDTH) 消息：对于列&#39;%s&#39;，显示宽度超出范围(max = %d) 错误：1440 SQLSTATE: XAE08 (ER_XAER_DUPID) 消息：XAER_DUPID: XID已存在 错误：1441 SQLSTATE: 22008 (ER_DATETIME_FUNCTION_OVERFLOW) 消息：日期时间函数，%s字段溢出。 错误：1442 SQLSTATE: HY000 (ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG) 消息：由于它已被调用了该存储函数／触发程序的语句使用，不能在存储函数／触发程序中更新表&#39;%s&#39;。 错误：1443 SQLSTATE: HY000 (ER_VIEW_PREVENT_UPDATE) 消息：表&#39;%s&#39;的定义不允许在表&#39;%s上执行操作%s。 错误：1444 SQLSTATE: HY000 (ER_PS_NO_RECURSION) 消息：预处理语句包含引用了相同语句的存储子程序调用。不允许以这类递归方式执行预处理语句。 错误：1445 SQLSTATE: HY000 (ER_SP_CANT_SET_AUTOCOMMIT) 消息：不允许从存储函数或触发程序设置autocommit。 错误：1446 SQLSTATE: HY000 (ER_NO_VIEW_USER) 消息：视图定义人不完全合格。 错误：1447 SQLSTATE: HY000 (ER_VIEW_FRM_NO_USER) 消息：视图%s.%s没有定义人信息（旧的表格式）。当前用户将被当作定义人。请重新创建视图！ 错误：1448 SQLSTATE: HY000 (ER_VIEW_OTHER_USER) 消息：需要SUPER权限才能创建具有%s@%s定义器的视图。 错误：1449 SQLSTATE: HY000 (ER_NO_SUCH_USER) 消息：没有注册的%s@%s。 错误：1450 SQLSTATE: HY000 (ER_FORBID_SCHEMA_CHANGE) 消息：不允许将方案从&#39;%s&#39;变为&#39;%s&#39;。 错误：1451 SQLSTATE: 23000 (ER_ROW_IS_REFERENCED_2) 消息：不能删除或更新父行，外键约束失败(%s)。 错误：1452 SQLSTATE: 23000 (ER_NO_REFERENCED_ROW_2) 消息：不能添加或更新子行，外键约束失败(%s)。 错误：1453 SQLSTATE: 42000 (ER_SP_BAD_VAR_SHADOW) 消息：必须用…引用变量，或重新命名变量。 错误：1454 SQLSTATE: HY000 (ER_PARTITION_REQUIRES_VALUES_ERROR) 消息：对于每个分区，%s PARTITIONING需要VALUES %s的定义。 错误：1455 SQLSTATE: HY000 (ER_PARTITION_WRONG_VALUES_ERROR) 消息：在分区定义中，只有%s PARTITIONING能使用VALUES %s。 错误：1456 SQLSTATE: HY000 (ER_PARTITION_MAXVALUE_ERROR) 消息：MAXVALUE只能在最后1个分区定义中使用。 错误：1457 SQLSTATE: HY000 (ER_PARTITION_SUBPARTITION_ERROR) 消息：子分区只能是哈希分区，并按键分区。 错误：1458 SQLSTATE: HY000 (ER_PARTITION_WRONG_NO_PART_ERROR) 消息：定义了错误的分区数，与前面的设置不匹配。 错误：1459 SQLSTATE: HY000 (ER_PARTITION_WRONG_NO_SUBPART_ERROR) 消息：定义了错误的子分区数，与前面的设置不匹配。 错误：1460 SQLSTATE: HY000 (ER_CONST_EXPR_IN_PARTITION_FUNC_ERROR) 消息：在分区（子分区）函数中不允许使用常量／随机表达式。 错误：1461 SQLSTATE: HY000 (ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR) 消息：RANGE/LIST VALUES中的表达式必须是常量。 错误：1462 SQLSTATE: HY000 (ER_FIELD_NOT_FOUND_PART_ERROR) 消息：在表中未发现分区函数字段列表中的字段。 错误：1463 SQLSTATE: HY000 (ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR) 消息：仅在KEY分区中允许使用字段列表。 错误：1464 SQLSTATE: HY000 (ER_INCONSISTENT_PARTITION_INFO_ERROR) 消息：frm文件中的分区信息与能够写入到frm文件中的不一致。 错误：1465 SQLSTATE: HY000 (ER_PARTITION_FUNC_NOT_ALLOWED_ERROR) 消息：%s函数返回了错误类型。 错误：1466 SQLSTATE: HY000 (ER_PARTITIONS_MUST_BE_DEFINED_ERROR) 消息：对于%s分区，必须定义每个分区。 错误：1467 SQLSTATE: HY000 (ER_RANGE_NOT_INCREASING_ERROR) 消息：对于各分区，VALUES LESS THAN值必须严格增大。 错误：1468 SQLSTATE: HY000 (ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR) 消息：VALUES值必须与分区函数具有相同的类型。 错误：1469 SQLSTATE: HY000 (ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR) 消息：Multiple definition of same constant in list partitioning 错误：1470 SQLSTATE: HY000 (ER_PARTITION_ENTRY_ERROR) 消息：在查询中，不能独立使用分区功能。 错误：1471 SQLSTATE: HY000 (ER_MIX_HANDLER_ERROR) 消息：在该MySQL版本中，不允许分区中的句柄组合。 错误：1472 SQLSTATE: HY000 (ER_PARTITION_NOT_DEFINED_ERROR) 消息：对于分区引擎，有必要定义所有的%s。 错误：1473 SQLSTATE: HY000 (ER_TOO_MANY_PARTITIONS_ERROR) 消息：定义了过多分区。 错误：1474 SQLSTATE: HY000 (ER_SUBPARTITION_ERROR) 消息：对于子分区，仅能将RANGE/LIST分区与HASH/KEY分区混合起来。 错误：1475 SQLSTATE: HY000 (ER_CANT_CREATE_HANDLER_FILE) 消息：无法创建特定的句柄文件。 错误：1476 SQLSTATE: HY000 (ER_BLOB_FIELD_IN_PART_FUNC_ERROR) 消息：在分区函数中，不允许使用BLOB字段。 错误：1477 SQLSTATE: HY000 (ER_CHAR_SET_IN_PART_FIELD_ERROR) 消息：如果为分区函数选择了二进制校对，才允许使用VARCHAR。 错误：1478 SQLSTATE: HY000 (ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF) 消息：在分区函数中，%s需要包含所有文件。 错误：1479 SQLSTATE: HY000 (ER_NO_PARTS_ERROR) 消息：%s的数目= 0不是允许的值。 错误：1480 SQLSTATE: HY000 (ER_PARTITION_MGMT_ON_NONPARTITIONED) 消息：无法在非分区表上进行分区管理。 错误：1481 SQLSTATE: HY000 (ER_DROP_PARTITION_NON_EXISTENT) 消息：分区列表中的错误出现变化。 错误：1482 SQLSTATE: HY000 (ER_DROP_LAST_PARTITION) 消息：不能删除所有分区，请使用DROP TABLE取而代之。 错误：1483 SQLSTATE: HY000 (ER_COALESCE_ONLY_ON_HASH_PARTITION) 消息：COALESCE PARTITION仅能在HASH/KEY分区上使用。 错误：1484 SQLSTATE: HY000 (ER_ONLY_ON_RANGE_LIST_PARTITION) 消息：%s PARTITION仅能在RANGE/LIST分区上使用。 错误：1485 SQLSTATE: HY000 (ER_ADD_PARTITION_SUBPART_ERROR) 消息：试图用错误的子分区数增加分区。 错误：1486 SQLSTATE: HY000 (ER_ADD_PARTITION_NO_NEW_PARTITION) 消息：必须至少添加1个分区。 错误：1487 SQLSTATE: HY000 (ER_COALESCE_PARTITION_NO_PARTITION) 消息：必须至少合并1个分区。 错误：1488 SQLSTATE: HY000 (ER_REORG_PARTITION_NOT_EXIST) 消息：重组的分区数超过了已有的分区数。 错误：1489 SQLSTATE: HY000 (ER_SAME_NAME_PARTITION) 消息：在表中，所有分区必须有唯一的名称。 错误：1490 SQLSTATE: HY000 (ER_CONSECUTIVE_REORG_PARTITIONS) 消息：重组分区集合时，它们必须连续。 错误：1491 SQLSTATE: HY000 (ER_REORG_OUTSIDE_RANGE) 消息：新分区的范围超过了已重组分区的范围。 错误：1492 SQLSTATE: HY000 (ER_DROP_PARTITION_FAILURE) 消息：在该版本的句柄中，不支持撤销分区。 错误：1493 SQLSTATE: HY000 (ER_DROP_PARTITION_WHEN_FK_DEFINED) 消息：在表上定义了外键约束时，不能舍弃分区。 错误：1494 SQLSTATE: HY000 (ER_PLUGIN_IS_NOT_LOADED) 消息：未加载插件&#39;%s&#39; B.2. 客户端错误代码和消息客户端错误信息来自下述源文件： 圆括号中的错误值和符号与 include/errmsg.h MySQL 源文件中的定义对应。 消息值与 libmysql/errmsg.c 文件中列出的错误消息对应。%d 和%s 分别代表数值和字符串，显示时，它们将被消息值取代。 由于更新很频繁，这些文件中可能包含这里未列出的额外错误消息。 错误：2000 (CR_UNKNOWN_ERROR) 消息：未知MySQL错误。 错误：2001 (CR_SOCKET_CREATE_ERROR) 消息：不能创建UNIX套接字(%d) 错误：2002 (CR_CONNECTION_ERROR) 消息：不能通过套接字&#39;%s&#39; (%d)连接到本地MySQL服务器。 错误：2003 (CR_CONN_HOST_ERROR) 消息：不能连接到&#39;%s&#39; (%d)上的MySQL服务器。 错误：2004 (CR_IPSOCK_ERROR) 消息：不能创建TCP/IP套接字(%d) 错误：2005 (CR_UNKNOWN_HOST) 消息：未知的MySQL服务器主机&#39;%s&#39; (%d) 错误：2006 (CR_SERVER_GONE_ERROR) 消息：MySQL服务器不可用。 错误：2007 (CR_VERSION_ERROR) 消息：协议不匹配，服务器版本= %d，客户端版本= %d 错误：2008 (CR_OUT_OF_MEMORY) 消息：MySQL客户端内存溢出。 错误：2009 (CR_WRONG_HOST_INFO) 消息：错误的主机信息 错误：2010 (CR_LOCALHOST_CONNECTION) 消息：通过UNIX套接字连接的本地主机。 错误：2011 (CR_TCP_CONNECTION) 消息：%s，通过TCP/IP 错误：2012 (CR_SERVER_HANDSHAKE_ERR) 消息：服务器握手过程中出错。 错误：2013 (CR_SERVER_LOST) 消息：查询过程中丢失了与MySQL服务器的连接。 错误：2014 (CR_COMMANDS_OUT_OF_SYNC) 消息：命令不同步，你现在不能运行该命令。 错误：2015 (CR_NAMEDPIPE_CONNECTION) 消息：命名管道，%s 错误：2016 (CR_NAMEDPIPEWAIT_ERROR) 消息：无法等待命名管道，主机，%s；管道，%s (%lu) 错误：2017 (CR_NAMEDPIPEOPEN_ERROR) 消息：无法打开命名管道，主机，%s；管道，%s (%lu) 错误：2018 (CR_NAMEDPIPESETSTATE_ERROR) 消息：无法设置命名管道的状态，主机，%s；管道，%s (%lu) 错误：2019 (CR_CANT_READ_CHARSET) 消息：无法初始化字符集%s (路径：%s) 错误：2020 (CR_NET_PACKET_TOO_LARGE) 消息：获得的信息包大于&#39;max_allowed_packet&#39;字节。 错误：2021 (CR_EMBEDDED_CONNECTION) 消息：嵌入式服务器。 错误：2022 (CR_PROBE_SLAVE_STATUS) 消息：SHOW SLAVE STATUS出错： 错误：2023 (CR_PROBE_SLAVE_HOSTS) 消息：SHOW SLAVE HOSTS出错： 错误：2024 (CR_PROBE_SLAVE_CONNECT) 消息：连接到从服务器时出错： 错误：2025 (CR_PROBE_MASTER_CONNECT) 消息：连接到主服务器时出错： 错误：2026 (CR_SSL_CONNECTION_ERROR) 消息：SSL连接错误 错误：2027 (CR_MALFORMED_PACKET) 消息：残缺信息包。 错误：2028 (CR_WRONG_LICENSE) 消息：该客户端库仅授权给具有&#39;%s&#39;许可的MySQL服务器使用。 错误：2029 (CR_NULL_POINTER) 消息：空指针的无效使用。 错误：2030 (CR_NO_PREPARE_STMT) 消息：语句未准备好。 错误：2031 (CR_PARAMS_NOT_BOUND) 消息：没有为预处理语句中的参数提供数据。 错误：2032 (CR_DATA_TRUNCATED) 消息：数据截短。 错误：2033 (CR_NO_PARAMETERS_EXISTS) 消息：语句中不存在任何参数。 错误：2034 (CR_INVALID_PARAMETER_NO) 消息：无效的参数编号。 错误：2035 (CR_INVALID_BUFFER_USE) 消息：不能为非字符串／非二进制数据类型发送长数据（参数：%d）。 错误：2036 (CR_UNSUPPORTED_PARAM_TYPE) 消息：正使用不支持的缓冲区类型， %d （参数：%d） 错误：2037 (CR_SHARED_MEMORY_CONNECTION) 消息：共享内存，%s 错误：2038 (CR_SHARED_MEMORY_CONNECT_REQUEST_ERROR) 消息：不能打开共享内存，客户端不能创建请求事件(%lu) 错误：2039 (CR_SHARED_MEMORY_CONNECT_ANSWER_ERROR) 消息：不能打开共享内存，未收到服务器的应答事件(%lu) 错误：2040 (CR_SHARED_MEMORY_CONNECT_FILE_MAP_ERROR) 消息：不能打开共享内存，服务器不能分配文件映射(%lu) 错误：2041 (CR_SHARED_MEMORY_CONNECT_MAP_ERROR) 消息：不能打开共享内存，服务器不能获得文件映射的指针(%lu) 错误：2042 (CR_SHARED_MEMORY_FILE_MAP_ERROR) 消息：不能打开共享内存，客户端不能分配文件映射(%lu) 错误：2043 (CR_SHARED_MEMORY_MAP_ERROR) 消息：不能打开共享内存，客户端不能获得文件映射的指针(%lu) 错误：2044 (CR_SHARED_MEMORY_EVENT_ERROR) 消息：不能打开共享内存，客户端不能创建%s事件(%lu) 错误：2045 (CR_SHARED_MEMORY_CONNECT_ABANDONED_ERROR) 消息：不能打开共享内存，无来自服务器的应答 (%lu) 错误：2046 (CR_SHARED_MEMORY_CONNECT_SET_ERROR) 消息：不能打开共享内存，不能将请求事件发送到服务器(%lu) 错误：2047 (CR_CONN_UNKNOW_PROTOCOL) 消息：错误或未知协议 错误：2048 (CR_INVALID_CONN_HANDLE) 消息：无效的连接句柄 错误：2049 (CR_SECURE_AUTH) 消息：拒绝使用旧鉴定协议（早于4.1.1）的连接（开启了客户端&#39;secure_auth&#39;选项）。 错误：2050 (CR_FETCH_CANCELED) 消息：行检索被mysql_stmt_close()调用取消。 错误：2051 (CR_NO_DATA) 消息：在未事先获取行的情况下试图读取列。 错误：2052 (CR_NO_STMT_METADATA) 消息：预处理语句不含元数据。 错误：2053 (CR_NO_RESULT_SET) 消息：在没有与语句相关的结果集时试图读取行。 错误：2054 (CR_NOT_IMPLEMENTED) 消息：该特性尚未实施。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>错误代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql命令]]></title>
    <url>%2Fmysql%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[MySQL SQL语句 方便查找，备忘虽趣舍万殊，静躁不同。 启动和登录123mysql.server start/stopmysql -u root -p 数据库状态12查看数据库 show databases;使用数据库 use databeseName; 操作数据库123新建数据库 create database;删除数据库 drop database databaseName; commit;使用数据库 use databeseName; 表状态12显示数据库有多少表 show tabels;显示表结构 describe tableName; 新建表1234创建新表 create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)根据已有的表创建新表：A：create table tab_new like tab_old (使用旧表创建新表)B：create table tab_new as select col1,col2… from tab_old definition only 删除新表1drop table tabname 增加一个列12Alter table tabname add column col type注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。 添加主键12Alter table tabname add primary key(col)说明：删除主键： Alter table tabname drop primary key(col) 创建索引123create [unique] index idxname on tabname(col….)删除索引：drop index idxname注：索引是不可更改的，想更改必须删除重新建。 创建视图12create view viewname as select statement删除视图：drop view viewname 几个简单的常用sql语句1234567891011选择：select * from table1 where 范围插入：insert into table1(field1,field2) values(value1,value2)删除：delete from table1 where 范围更新：update table1 set field1=value1 where 范围查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!排序：select * from table1 order by field1,field2 [desc]总数：select count as totalcount from table1求和：select sum(field1) as sumvalue from table1平均：select avg(field1) as avgvalue from table1最大：select max(field1) as maxvalue from table1最小：select min(field1) as minvalue from table1 高级查询运算词UNION 运算符UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 EXCEPT 运算符EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 INTERSECT 运算符INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。注：使用运算词的几个查询结果行必须是一致的。 使用外连接left （outer） join左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c right （outer） join:右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 full/cross （outer） join全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。 分组:Group by 一张表，一旦分组完成后，查询后只能得到组相关的信息。 组相关的信息：（统计信息） count,sum,max,min,avg 分组的标准) 在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据 在selecte统计函数中的字段，不能和普通的字段放在一起； 对数据库进行操作 分离数据库： sp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名 如何修改数据库的名称sp_renamedb ‘old_name’, ‘new_name’ 提升复制表123(只复制结构,源表名：a 新表名：b)法一：select * into b from a where 1&lt;&gt;1（仅用于SQlServer）法二：select top 0 * into b from a 拷贝表12(拷贝数据,源表名：a 目标表名：b)insert into b(a, b, c) select d,e,f from b; 跨数据库之间表的拷贝(具体数据使用绝对路径)12insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件例子：..from b in '"&amp;Server.MapPath(".")&amp;"\data.mdb" &amp;"' where.. 子查询123(表名1：a 表名2：b)select a,b,c from a where a IN (select d from b )select a,b,c from a where a IN (1,2,3) 显示文章、提交人和最后回复时间1select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b 外连接查询12(表名1：a 表名2：b)select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c 在线视图查询12(表名1：a )select * from (SELECT a,b,c FROM a) T where t.a &gt; 1; between的用法123between限制查询数据范围时包括了边界值,not between不包括select * from table1 where time between time1 and time2select a,b,c, from table1 where a not between 数值1 and 数值2 in 的使用方法1select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’) not exists12两张关联表，删除主表中已经在副表中没有的信息delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 ) 四表联查问题1select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where ..... 日程安排提前五分钟提醒1SQL: select * from 日程安排 where datediff('minute',f开始时间,getdate())&gt;5 一条sql 语句搞定数据库分页1234567select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段具体实现：关于数据库分页： declare @start int,@end int @sql nvarchar(600) set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’ exec sp_executesql @sql 注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引） 前10条记录1select top 10 * form table1 where 范围 选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b) 包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表(select a from tableA ) except (select a from tableB) except (select a from tableC) 随机取出10条数据select top 10 * from tablename order by newid() 随机选择记录select newid() 删除重复记录1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,…)2),select distinct into temp from tablename delete from tablename insert into tablename select from temp评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段alter table tablename–添加一个自增列add column_b int identity(1,1) delete from tablename where column_b not in(select max(column_b) from tablename group by column1,column2,…)alter table tablename drop column column_b 列出数据库里所有的表名select name from sysobjects where type=’U’ // U代表用户 列出表里的所有的列名select name from syscolumns where id=object_id(‘TableName’)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx隐藏版本]]></title>
    <url>%2Fnginx%E9%9A%90%E8%97%8F%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[mark and learn 在搭建好了 nginx 之后，一般会隐藏版本号，避免不必要的麻烦， 1curl -I www.nginx.org 12345678HTTP/1.1 301 Moved PermanentlyServer: nginx/1.11.7Date: Tue, 11 Apr 2017 07:30:05 GMTContent-Type: text/htmlContent-Length: 185Connection: keep-aliveKeep-Alive: timeout=15Location: http://nginx.org/ 如上，就会看到 nginx 的版本是 1.11.7，之前爆出的 Nginx 版本漏洞，这样暴露出来的版本就容易变成被利用的信息，从安全角度来讲，隐藏会相对好一些。 1.进入 nginx 配置文件 在 http{}里面加上server_tokens off; 2.修改 php-fpm 配置文件，根据自己的配置文件名修改(fastcgi.conf…) 1234找到：fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;改为：fastcgi_param SERVER_SOFTWARE nginx; 3.重新加载 nginx 配置 1nginx -s reload Other 如果要隐藏 php 的版本，“X-Powered-By: PHP/5.2.13” 这个信息编辑 php.ini配置文件，修改或者加入 expose_php = Off再重启 php-fpm 1/etc/init.d/php-fpm restart]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>隐藏版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web常用国家代码]]></title>
    <url>%2Fweb%E5%B8%B8%E7%94%A8%E5%9B%BD%E5%AE%B6%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[备忘国家代码，方便查找 代码 国家 代码 国家 af 南非荷兰语 sq 阿尔巴尼亚语 ar-sa 阿拉伯语(沙特阿拉伯) ar-iq 阿拉伯语(伊拉克) ar-eg 阿拉伯语(埃及) ar-ly 阿拉伯语(利比亚) ar-dz 阿拉伯语(阿尔及利亚) ar-ma 阿拉伯语(摩洛哥) ar-tn 阿拉伯语(突尼斯) ar-om 阿拉伯语(阿曼) ar-ye 阿拉伯语(也门) ar-sy 阿拉伯语(叙利亚) ar-jo 阿拉伯语(约旦) ar-lb 阿拉伯语(黎巴嫩) ar-kw 阿拉伯语(科威特) ar-ae 阿拉伯语(阿拉伯联合酋长国) ar-bh 阿拉伯语(巴林) ar-qa 阿拉伯语(卡塔尔) eu 巴斯克语 bg 保加利亚语 be 贝劳语 ca 加泰罗尼亚语 zh-tw 中文(中国台湾) zh-cn 中文(中华人民共和国) zh-hk 中文(中国香港特别行政区) zh-sg 中文(新加坡) hr 克罗地亚语 cs 捷克语 da 丹麦语 nl 荷兰语(标准) nl-be 荷兰语(比利时) en 英语 en-us 英语(美国) en-gb 英语(英国) en-au 英语(澳大利亚) en-ca 英语(加拿大) en-nz 英语(新西兰) en-ie 英语(爱尔兰) en-za 英语(南非) en-jm 英语(牙买加) en 英语(加勒比) en-bz 英语(伯利兹) en-tt 英语(特立尼达) et 爱沙尼亚语 fo 法罗语 fa 波斯语 fi 芬兰语 fr 法语(标准) fr-be 法语(比利时) fr-ca 法语(加拿大) fr-ch 法语(瑞士) fr-lu 法语(卢森堡) gd 盖尔语(苏格兰) gd-ie 盖尔语(爱尔兰) de 德语(标准) de-ch 德语(瑞士) de-at 德语(奥地利) de-lu 德语(卢森堡) de-li 德语(列支敦士登) el 希腊语 he 希伯来语 hi 北印度语 hu 匈牙利语 is 冰岛语 in 印度尼西亚语 it 意大利语(标准) it-ch 意大利语(瑞士) ja 日语 ko 朝鲜语 ko 朝鲜语(韩国) lv 拉脱维亚语 lt 立陶宛语 mk FYRO 马其顿语 ms 马来西亚语 mt 马耳他语 no 挪威语(博克马尔) no 挪威语(尼诺斯克) pl 波兰语 pt-br 葡萄牙语(巴西) pt 葡萄牙语(葡萄牙) rm 拉丁语系 ro 罗马尼亚语 ro-mo 罗马尼亚语(摩尔达维亚) ru 俄语 ru-mo 俄语(摩尔达维亚) sz 萨摩斯语(拉普兰) sr 塞尔维亚语(西里尔) sr 塞尔维亚语(拉丁) sk 斯洛伐克语 sl 斯洛文尼亚语 sb 索布语 es 西班牙语(西班牙传统) es-mx 西班牙语(墨西哥) es 西班牙语(西班牙现代) es-gt 西班牙语(危地马拉) es-cr 西班牙语(哥斯达黎加) es-pa 西班牙语(巴拿马) es-do 西班牙语(多米尼加共和国) es-ve 西班牙语(委内瑞拉) es-co 西班牙语(哥伦比亚) es-pe 西班牙语(秘鲁) es-ar 西班牙语(阿根廷) es-ec 西班牙语(厄瓜多尔) es-cl 西班牙语(智利) es-uy 西班牙语(乌拉圭) es-py 西班牙语(巴拉圭) es-bo 西班牙语(玻利维亚) es-sv 西班牙语(萨尔瓦多) es-hn 西班牙语(洪都拉斯) es-ni 西班牙语(尼加拉瓜) es-pr 西班牙语(波多黎各) sx 苏图语 sv 瑞典语 sv-fi 瑞典语(芬兰) th 泰语 ts 汤加语 tn 瓦纳语 tr 土耳其语 uk 乌克兰语 ur 乌尔都语 ve 文达语 vi 越南语 xh 科萨语 ji 依地语 zu 祖鲁语]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>国家代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sticky footer]]></title>
    <url>%2Fsticky-footer%2F</url>
    <content type="text"><![CDATA[Sticky footer 是什么？ Sticky footers设计是最古老和最常见的网页效果之一，大多的CSSer都遇到过。可以概括成： 页面有一个footer，如果页面不够长，页脚在视窗底部；如果视窗足够长，页脚会被内容向下挤压，页脚最终还是在页面底部。 可以在这里看到效果 http://www.cssstickyfooter.com/ 常见实现这种效果几乎存在于所有的公司网站和单页网站，看上去很容易实现，但是实际要花费的时间远超预期。在css2.0中解决这个页脚基本都是设置一个固定高度来实现，甚至使用了js的一些计算来进行高度的定位。可以参考：Sticky FooterSticky CSS footers: The flexible way 目前比较流行的技巧就是通过设置容器height:100%;padding-bottom:&lt;固定高度&gt; ， footer maring-top:-&lt;固定高度&gt;实现 1234567891011121314151617181920212223242526//html&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="main"&gt; &lt;p&gt;xxxx&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="footer&gt; &lt;p&gt;xxxx&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;//stylus.wrapper min-height 100% .main margin-top 64px padding-bottom 64px.footer position relative width 32px height 32px margin -64px auto 0 auto clear both Flex 实现页脚Flex的语法可以参考我之前的一个Flex 布局 使用flex几行代码就可以实现，先在&lt;body&gt;上设置display:flex, 并添加flex-direction: column;让内容纵向排列，或者使用组合属性flex-flow:column, 再设置min-height:100vh，让body占据整个视窗。在&lt;main&gt;上设置flex:1来让main自动适配剩余空间的大小。这样就OK了。 12345678910111213body &#123; padding:0; margin:0; display: flex; flex-direction: column; min-height: 100vh;&#125;main &#123; flex: 1; &#125;#contents:checked ~ p &#123; display: none &#125;footer&#123; background: #000; color: #fff;&#125; 效果展示 参考Sticky CSS footers: The flexible way]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Flex</tag>
        <tag>布局</tag>
        <tag>Sticky footer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex弹性布局]]></title>
    <url>%2Fflex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言 Flex弹性布局， 友好、方便的布局方案。它已经得到了所有浏览器的支持，这意味着，只要带上前缀就可以在所有的浏览器上使用，而不用担心兼容性的问题。布局的传统解决方案，基于盒状模型，将display属性 + position属性 + float属性组合。它对于特殊布局比如垂直居中就不容实现。流行的UI框架的栅格布局也是基于盒模型，通过设置百分比和float来构建的。非常流行的Bootstrap 4.x就是用flex来重新布局的，替代了之前的栅格百分比的布局方式。Marked it afraid forgot. What？ Flex是什么Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。Flex,从2007年07月，flex第一版本的工作草案发布，到2012年09月，flex最新版本成为候选推荐。flex主要经历了三个版本 【1】旧版本 display:box | inline-box; IE浏览器不支持，windows下的safari浏览器只支持旧版本的写法且需要添加前缀，移动端可以兼容到andriod2.1-4.3和ios3.2-6.1也需要添加前缀 【2】混合版本 display:flexbox | inline-flexbox; 该版本只有IE10支持，且需要添加前缀-ms- 【3】新版本 display: flex | inline-flex 该版本兼容IE11+、firefox、safari、chrome、opera及移动端，但移动端ios7.1-8.4需要添加前缀-webkit- 目前个浏览器对最新版本有了很好的支持。 12345// 可以对每一个容器都可以指定为flex属性.box&#123; display: flex | inline-flex&#125; 不同的浏览器要加上其特定的前缀： -webkit-, -ms- 或 -moz- How？ 如何加持到容器Properties for the Parent flex容器有6个可设置属性（带图一目了然）： flex-direction 决定主轴的方向（即容器内项目的排列方向） flex-wrap 容器内的项目是否换行，如何换行 flex-flow 上面两个属性的组合 justify-content 容器内项目的水平方向的对齐方式 align-items 容器内项目的垂直方向的对齐方式 align-content flex-direction12345678.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125;row（默认值）：当`ltr`时，从左到右，当`rtl`时，从右向左，也就是按照文档流横向排列。row-reverse：和row相反。column：从上到下。column-reverse：和column相反。 flex-wrap1234567.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125;nowrap: 默认， 不换行wrap: 换行，按照顺序每行依次排列（第一行，第二行）wrap-reverse: 换行，每行倒序排列(第二行，第一行) flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content123456789.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125;flex-start（默认值）：左对齐flex-end：右对齐center： 居中对齐space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items123456789.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125;flex-start：顶端对齐。flex-end：底部对齐。center：居中对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content类似于justify-content的对齐方式， 针对多行生效，只有一行时不生效12345678910.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;flex-start：顶端对齐flex-end：低端对齐center：居中。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：拉伸占据整个容器的高度。&#125; 上面的6个属性都是设置在容器上的，针对项目占据容器的大小和顺序等由已下6个属性来设置。 How flexible？更灵活的设置ChildrenProperties for the Children order flex子项顺序 flex-grow flex子项占用容器可用空间的比例 flex-shrink flex子项在空间不足时缩小 flex-basis 定义flex子项的默认大小 flex 以上三个 flex-grow, flex-shrink, flex-basis的简写或者说是组合 align-self order默认情况下，flex项目按代码书写顺序布局。但是，order属性控制它们在flex容器中显示的顺序。123.item &#123; order: &lt;integer&gt;; //整数&#125; flex-grow如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; flex-shrink如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。123.item &#123; flex-shrink: &lt;number&gt;; /*默认为1 不能是负数*/&#125; flex-basis1234.item &#123; flex-basis: &lt;length&gt; | auto; /* 默认是 auto */&#125;length可以是20%, 5rem，10px等长度值 flex1234.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125;默认值是 0 1 auto. 后两个是可选项 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; Where？哪里能用 推荐 最后推荐一个淘宝的弹性布局方案 https://github.com/amfe/lib-flexible http://www.cnblogs.com/lyzg/p/5058356.html 参考 https://css-tricks.com/snippets/css/a-guide-to-flexbox/http://www.cnblogs.com/xiaohuochai/p/5323146.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Flex</tag>
        <tag>布局</tag>
        <tag>弹性布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git ssh配置和使用]]></title>
    <url>%2Fgit-ssh%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[记录一下 git 的 ssh 配置,备忘。 1.配置用户和邮箱 12$ git config --global user.name "webkong"$ git config --global user.email "webkong@webkong.cn" 如果在多用户情况下，一般设置本地用户 123//cd to repo path$ git config --local user.name "webkong"$ git config --local user.email "webkong@webkong.cn" 2.生成密钥 1234567$ ssh-keygen -t rsa -C "webkong@webkong.cn" [-f id_rsa_github]// -f 后面带生成的文件名， 在配置多git账号的时候使用,以区分不同的密钥文件然后连续敲3个回车，确认默认设置。就会在 ~/ 用户目录下生成.ssh文件包含 id_rsa 和 id_rsa.pub两个文件。 id_rsa.pub 就是公钥文件，将内容复制出来，添加到私人 Git 服务器或者是 github 上。 可以使用 ssh-agent 密钥管理器，将私钥交给 ssh-agent 来管理和使用 如果 windows 系统上传完还是不能使用，就要将 ssh 加入到 agent 里面。 12ssh-agent -sssh-add ~/.ssh/id_rsa 如果 执行 ssh-add 时添加私钥到 git 中报错 Could not open a connection to your authentication agent 1eval `ssh-agent` //执行启动，再执行add操作 1ssh-add -l //查看 若途中报错 “Permissions ???? for ‘/Users/xxx/.ssh/rsa’ are too open”的问题，则是该私钥文件权限过高，需要设置其权限 1chmod 600 ~/.ssh/rsa 3.多 git 账号配置 在 ~/.ssh目录新建文件 config 1234567891011Host github.com //配置host地址 HostName github.com User webkong //用户名 PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github //公钥地址Host gitlab.webkong.org HostName gitlab.webkong.org User wangsw PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS渲染]]></title>
    <url>%2Fcss%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[#CSS渲染 css是从右向左解析的 一开始我看到这个从右向左解析渲染的时候，也是呆了一下，但是想想这确实是目前效率最高的方式了。 OK，开始。 浏览器架构 1.用户界面 - 用户使用的界面：地址栏，书签，前进后退等 2.浏览器引擎 - 在用户界面和渲染引擎之间传递指令 3.渲染引擎 - 负责显示请求的内容，解析一些HTML、CSS并显示到屏幕 4.网络层 - 网络调用，比如：http、websocket等 5.JavaScript解释器 - 用于解释执行JavaScript代码 6.用户界面后端 - 7.数据存储 - 浏览器需要将持久化的数据存储在硬盘上。不如Cookie、localstroge等 我主要讨论一下渲染引擎 渲染引擎渲染引擎从网络层获取到请求问道的内容之后，就会执行如下基本流程： 1.渲染引擎开始解析HTML文档，并将各个标记逐渐转化成DOM树上的DOM节点。同时，解析外部CSS文件以及样式元素中的样式数据。等所有CSS文件获取成功后，结合内部style和行内样式，生成render树，render树包含了每个DOM的节点的样式信息。 2.结合DOM树和render树来绘制页面。 CSS是从右向左解析的 构建render树的过程是遍历dom树，每次拿到一个dom节点，然后遍历所有的样式规则，查找与当前节点匹配的规则，最后将所有匹配的规则中定义的样式写入到一个render对象，再将render对象挂到render树上（建立对象和render树的联系）。如图： 也就是说，每一个dom，已知的是class，id和tabName &lt;a id=&quot;aa&quot; class=&quot;bb&quot; href=&quot;&quot;&gt; ，但是匹配的规则可能有成千上万条，渲染引擎需要从中找到符合条件的1条或者多条（数量不会很多）。 由于每条规则都有很多嵌套例如： #content .box p{} .title a{} 假如采用从左向右的方式读取CSS规则，那么大多数的规则读取到后面发现是不匹配的，会浪费很多时间在无用的匹配上。 所以，采用从右向左匹配就会在发现最后边或者次右边的选择器不匹配，整个规则就可以跳过了。 在css模块化了之后，模块打包到一个css文件中了。 比如： 1234.model_a a&#123;...&#125;.model_b a&#123;...&#125;.model_c a&#123;...&#125;.model_d a&#123;...&#125; 浏览器会遍历所有的a，所以加大了匹配时间，所以，提倡不用tag标签来定义样式，一律用类 .class 参考How browsers work 中文 How browsers work Why do browsers match CSS selectors from right to left?]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django的基础使用]]></title>
    <url>%2Fdjango%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[环境依赖基础依赖 Python任意版本，3.x没有mysql引擎 pip 8.x 及以上 virtualenv Python虚拟环境，隔离本地项目 使用virtualenv 12345678mkdir mysite; cd mysitevirtualenv --no-site-package venv //创建一个虚拟环境source venv/bin/activate //进入虚拟环境deactivate //退出 接下来就可以在环境中配置Django的各种依赖 Django依赖 pip install Django pip install MySQL-python pip install Pillow 还有其他依赖 django-suit fast-rest-fromwork 验证1234import djangoprint(django.get_version()) 创建和使用Django创建项目1234567891011121314151617181920django-admin startproject site//生成的目录结构mysite/ manage.py //django的命令行工具 mysite/ __init__.py settings.py //django的配置文件 urls.py //url调度 wsgi.py 将应用配置进settings,以激活应用 数据库建立配置数据库12345678910111213141516171819202122//settings.pyDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django-test', 'USER': 'root', 'PASSWORD': '1234567890', 'HOST': '127.0.0.1', 'PORT': '3306', &#125;&#125; 数据迁移（migrate）12python manage.py migrate 启动服务12python manage.py runserver 创建应用（模型）12python manage.py startapp ad 新建Models1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class AdInfo(models.Model): id = models.CharField(primary_key=True, max_length=100) name = models.CharField(unique=True, max_length=100) description = models.CharField(max_length=1000, blank=True, null=True) priority = models.IntegerField() status = models.IntegerField() start_time = models.DateTimeField(blank=True, null=True) end_time = models.DateTimeField() max_show_count = models.BigIntegerField() max_day_show_count = models.BigIntegerField() create_time = models.DateTimeField() update_time = models.DateTimeField() class Meta: managed = True db_table = 'ad_info'class AdInfoPlacement(models.Model): ad_placement = models.ForeignKey('AdPlacement', models.DO_NOTHING) ad_info = models.ForeignKey(AdInfo, models.DO_NOTHING) create_time = models.DateTimeField() class Meta: managed = True db_table = 'ad_info_placement' unique_together = (('ad_info', 'ad_placement'),)class AdPlacement(models.Model): id = models.CharField(primary_key=True, max_length=100) name = models.CharField(max_length=100) app_id = models.CharField(max_length=100) status = models.IntegerField() create_time = models.DateTimeField() class Meta: managed = True db_table = 'ad_placement' unique_together = (('app_id', 'name'),)class AdProperties(models.Model): ad_info_id = models.CharField(max_length=100) property_key = models.CharField(max_length=100, blank=True, null=True) property_value = models.CharField(max_length=2000, blank=True, null=True) django不支持双主键或者多主键 执行命令通知django修改models 1234python manage.py makemigrations //创建迁移文件python manage.py migrate //更新到数据库 python manage.py inspectdb &gt; models.py //反向生成model 创建管理员，admin管理1234python manage.py createsuperuser根据提示一次输入用户名，邮箱和密码就OK了 启动服务看一下。 这样就成功启动了，根据自己定义的Model的Django。在host/admin/目录下可以登陆并看到相应的管理条目 自定义管理未完待续… 其他链接官方文档options 官方文档actions 配置详情url调度器]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组常用方法]]></title>
    <url>%2Fjavascript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[总是忘了数组的方法，所以备忘一下，记性真是不好一天之计在于晨 concat()连接两个或者更多的数组，并返回结果。 不会改变现有数组，会返回被连接数组的副本。 arrayObject.concat(arr1,arr2, ... arrx) 返回值：返回一个新的数组。 123var a = [1,2,3]console.log(a.concat([4,5]))// 1,2,3,4,5 join()把数组的所有元素放入一个字符串。元素通过制定的分隔符进行分隔。 arrayObject.join(separator) 默认分隔符为’,’ 返回值:返回一个字符串。 123var arr = [1,2,3,4,5,6,'haha']console.log(arr.join('.'))// 1.2.3.4.5.6.haha pop()删除并返回数组的最后一个元素 arrayObject.pop() 返回值:arrayObject的最后一个元素说明：原地操作。 pop()方法将删除arrayObject的最后一个元素，把数组长度减1，并返回删除的元素的值。如果数组为空，则不改变数组，并返回undefined值。 1234567var a = [1,2,3]console.log(a)console.log(a.pop())console.log(a)// [1,2,3]// 3// [1,2] push()向数组的末尾添加一个或多个元素，并返回新的长度。 arrayObject.push(newelement1,newelement2,....,newelementX) 返回值：元素添加到数组之后的新长度说明：原地操作。方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。unshift()可以在头部添加一个或者多个元素 1234567var a = [1,2,3,4,5]console.log(a)console.log(a.push(7))console.log(a)// [1,2,3,4,5]// 6// [1,2,3,4,5,7] reverse()颠倒数组中元素的顺序。 arrayObject.reverse() 返回值：颠倒顺序的数组本身说明：原地操作。直接改变原来的数组，不会创建新的数组。 1234var a = [1,2,3]console.log(a)console.log(a.reverse()=== a)console.log(a) slice()从已有的数组中返回选定的元素。 arrayObject.slice(start,end)start 必须，规定从何处开始选取。如果是负值，那么它规定从数组的为不开始算起的位置。也就是 -1 是最后一个元素，-2 是倒数第二个，以此类推end 可选，规定从何处结束选取。该参数是数组片段结束处的数组下标。如果没有指定，那么切分的数组包含从start到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 返回值:返回一个新的数组。包含start到end(不含)的元素 说明：非原地操作，返回子数组。start,end都是元素的下标 1234567var a = [1,2,3,4,5,6,7]console.log(a)console.log(a.slice(1)) //从下标是1开始选取到最后 [2,3,4,5,6,7]console.log(a.slice(1,3))//从下标1开始到下标3 [2,3]console.log(a.slice(1,-2)) //从下标1开始到倒数第二个[2,3,4,5]console.log(a.slice(-2)) //从倒数第二个开始到最后 [6,7]console.log(a.(-3,-1)) //从倒数第三个到倒数第一个[5,6] splice()方法向/从数组中添加/删除项目，然后返回被删除的项目。 arrayObject.splice(index,howmany,item1,.....,itemX) index 必须，整数， 规定添加/删除的位置，如果是负数，可从数组结尾处规定位置howmany 必须，要删除的项目的数量。如果设置为0 ，则不会删除项目。就是删除几个item,…,itemx 可选，向数组添加的新的项目 说明：原地操作。 splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。 1234567var a = [1,2,3,4,5];var b = [];b = a.slice(0);console.log(a.splice(1,3,9,8,7,6)) //执行后的返回值 [ 2, 3, 4 ]console.log(a) //[ 1, 9, 8, 7, 6, 5 ]console.log(b.splice(1,2))//[ 2, 3 ]console.log(b)//[ 1, 4, 5 ] sort()用于对数组的元素进行排序。 arrayObject.sort(sortby) sortby可选。规定排序顺序。必须是函数。 说明:原地操作。 数组在原数组上进行排序，不生成副本。如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。若 a 等于 b，则返回 0。若 a 大于 b，则返回一个大于 0 的值。 shift()把数组的第一个元素从其中删除，并返回第一个元素的值。arrayObject.shift() 说明：原地操作。 如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。和pop()方法使用相同 unshift()向数组的开头添加一个或更多元素，并返回新的长度。arrayObject.unshift(newelement1,newelement2,....,newelementX) 说明：原地操作。类似push()方法。unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。 toString()把数组转换为字符串，并返回结果。数组中的元素之间用逗号分隔。 arrayObject.toString() 说明：arrayObject 的字符串表示。返回值与没有参数的 join() 方法返回的字符串相同。 toLocaleString()把数组转换为本地字符串。首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。 valueOf()返回 Array 对象的原始值。 arrayObject.valueOf() 说明：方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。 indexOf()indexOf()方法返回给定元素能找在数组中找到的第一个索引值，否则返回-1。 arr.indexOf(searchElement[, fromIndex = 0]) searchElement:要查找的元素fromIndex:开始查找的位置,如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，仍然从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0. indexOf 在ECMA-262 标准 的第5版中被加入，但并非所有的浏览器都支持该方法。可以如下使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Production steps of ECMA-262, Edition 5, 15.4.4.14// Reference: http://es5.github.io/#x15.4.4.14if (!Array.prototype.indexOf) &#123; Array.prototype.indexOf = function(searchElement, fromIndex) &#123; var k; // 1. Let O be the result of calling ToObject passing // the this value as the argument. if (this == null) &#123; throw new TypeError('"this" is null or not defined'); &#125; var O = Object(this); // 2. Let lenValue be the result of calling the Get // internal method of O with the argument "length". // 3. Let len be ToUint32(lenValue). var len = O.length &gt;&gt;&gt; 0; // 4. If len is 0, return -1. if (len === 0) &#123; return -1; &#125; // 5. If argument fromIndex was passed let n be // ToInteger(fromIndex); else let n be 0. var n = +fromIndex || 0; if (Math.abs(n) === Infinity) &#123; n = 0; &#125; // 6. If n &gt;= len, return -1. if (n &gt;= len) &#123; return -1; &#125; // 7. If n &gt;= 0, then Let k be n. // 8. Else, n&lt;0, Let k be len - abs(n). // If k is less than 0, then let k be 0. k = Math.max(n &gt;= 0 ? n : len - Math.abs(n), 0); // 9. Repeat, while k &lt; len while (k &lt; len) &#123; // a. Let Pk be ToString(k). // This is implicit for LHS operands of the in operator // b. Let kPresent be the result of calling the // HasProperty internal method of O with argument Pk. // This step can be combined with c // c. If kPresent is true, then // i. Let elementK be the result of calling the Get // internal method of O with the argument ToString(k). // ii. Let same be the result of applying the // Strict Equality Comparison Algorithm to // searchElement and elementK. // iii. If same is true, return k. if (k in O &amp;&amp; O[k] === searchElement) &#123; return k; &#125; k++; &#125; return -1; &#125;;&#125; lastIndexOf()lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 语法1arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1]) 参数 searchElement 被查找的元素。 fromIndex 从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。返回值 数组中最后一个元素的索引，如未找到返回-1 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf isArray()方法用来判断某个值是否为Array。如果是，则返回 true，否则返回 false。 Array.isArray(value)value 要检测的值 every()every() 方法测试数组的所有元素是否都通过了指定函数的测试。 arr.every(callback[, thisArg]) callback:用来测试每个元素的函数。thisArg:执行 callback 时使用的 this 值。 说明：非原地操作。every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。 callback 被调用时传入三个参数：元素值，元素的索引，原数组。 如果为 every 提供一个 thisArg 参数，在该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。every 不会改变原数组。 same()some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试。对于放在空数组上的任何条件，此方法返回false。1arr.some(callback[, thisArg]) 参数 callback 用来测试每个元素的函数，接受三个参数： currentValue 数组中正在处理的元素。 index 可选 数组中正在处理的元素的索引值。 array可选 some()被调用的数组。 thisArg可选 执行 callback 时使用的 this 值。返回值 如果回调函数返回任何数组元素的truthy值，则返回true；否则为false。 123456789 var array = [1, 2, 3, 4, 5];var even = function(element) &#123; // checks whether an element is even return element % 2 === 0;&#125;;console.log(array.some(even));// expected output: true filter()filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。 var new_arrary = arr.filter(callback[, thisArg]) callback:用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。返回true表示保留该元素（通过测试），false则不保留。thisArg:可选。执行 callback 时的用于 this 的值。 说明：非原地操作。 返回通过filter的元素数组 map()善用map,能有效避免js里面for循环的坑 map() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。 array.map(callback[, thisArg])参数说明： callback, 原数组中的元素经过该方法后返回一个新的元素。 currentValue ,callback 的第一个参数，数组中当前被传递的元素。 index, callback 的第二个参数，数组中当前被传递的元素的索引。 array, callback 的第三个参数，调用 map 方法的数组。thisArg, 执行 callback 函数时 this 指向的对象。 reduce()reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。 arr.reduce(callback,[initialValue])参数说明：callback, 执行数组中每个值的函数，包含四个参数 previousValue， 上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue， 数组中当前被处理的元素 index， 当前元素在数组中的索引 array, 调用 reduce 的数组initialValue, 作为第一次调用 callback 的第一个参数。 说明：回调函数第一次执行时，previousValue 和 currentValue 的取值有两种情况，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。 123[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array)&#123; return previousValue + currentValue;&#125;); previousValue currentValue index array return value first call 0 1 1 [0,1,2,3,4] 1 second call 1 2 2 [0,1,2,3,4] 3 third call 3 3 3 [0,1,2,3,4] 6 fourth call 6 4 4 [0,1,2,3,4] 10 ES6中的方法from()可以将一个类数组对象或可遍历对象转换成真正的数组。 copyWithin()会浅拷贝数组的部分元素到同一数组的不同位置，且不改变数组的大小，返回该数组。 Array.of()Array.of() 方法会将它的任意类型的多个参数放在一个数组里并返回。 Array.of() 和 Array 构造函数不同的是：在处理数值类型的参数时，Array.of(42) 创建的数组只有一个元素，即 42, 但 Array(42) 创建了42个元素，每个元素都是undefined。 Array.of(element0[, element1[, ...[, elementN]]]) fill()使用 fill() 方法，可以将一个数组中指定区间的所有元素的值, 都替换成或者说填充成为某个固定的值。 arr.fill(value[, start = 0[, end = this.length]])value:用来填充数组元素的值。start:可选，开始索引。end:可选，结束索引。说明：原地操作。具体要填充的元素区间是 [start, end) , 一个半开半闭区间.如果 start 是个负数, 则开始索引会被自动计算成为 length+start, 其中 length 是 this 对象的 length 属性值. 如果 end 是个负数, 则结束索引会被自动计算成为 length+end. fill 方法故意被设计成通用方法, 也就是说它不需要 this 值必须是个数组对象, 类数组对象也是可以调用该方法的 . fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本. find()如果数组中某个元素满足测试条件，find() 方法就会返回那个元素的第一个值，如果没有满足条件的元素，则返回 undefined。区别：findIndex()方法返回的是满足条件的元素的索引，而非它的值。 arr.find(callback[, thisArg]) 参数说明:callback在数组每一项上执行的函数，接收 3 个参数： element, 当前遍历到的元素。 index, 当前遍历到的索引。 array, 数组本身。thisArg可选，指定 callback 的 this 参数。 includes()12arr.includes(searchElement)arr.includes(searchElement, fromIndex) 参数说明:searchElement : 需要查找的元素值。 fromIndex 可选 从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length - fromIndex 的索引开始搜索。默认为 0。 返回值节返回值 一个 Boolean。 key()keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。 语法1arr.keys() 返回值 一个新的 Array 迭代器对象。 #### 使用技巧 slice()方法复制数组，看前面的例子 push()和pop()可以实现先进后出栈的原理 push()和shift()可以实现先进先出队列的原理 后续继续添加 参考MDN-JavaScript标准库w3school JavaScript Array 对象]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django重置admin密码]]></title>
    <url>%2Fdjango%E9%87%8D%E7%BD%AEadmin%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[当忘记了Django的管理员密码可以通过一下两个办法来解决 直接修改1234567# 在项目目录下python manage.py changepassword adminChanging password for user 'admin'Password:Password (again):Password changed successfully for user 'admin' 就修改成功了。 如果修改不成功可以通过新建来达到目的1python manage.py createsuperuser --username admin 可以删掉之前的，重新再添加一个。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Django</tag>
        <tag>重置密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端跨域总结]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[转载自：前端跨域整理 什么是跨域？ 跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。下面是具体的跨域情况详解： 1234567891011121314151617URL 说明 是否允许通信http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许http://www.a.com/lab/a.jshttp://www.a.com/script/b.js 同一域名下不同文件夹 允许http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名，不同端口 不允许http://www.a.com/a.jshttps://www.a.com/b.js 同一域名，不同协议 不允许http://www.a.com/a.jshttp://70.32.92.74/b.js 域名和域名对应ip 不允许http://www.a.com/a.jshttp://script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）http://www.a.com/a.jshttp://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）http://www.cnblogs.com/a.jshttp://www.a.com/b.js 不同域名 不允许 这里我们需要注意两点:如果是协议和端口造成的跨域问题“前台”是无能为力的；在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。(“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。) 通过document.domain跨域 前面说过了，浏览器有一个同源策略，其限制之一是不能通过ajax的方法去请求不同源中的文档。 第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是http://www.damonare.cn/a.html ， 在这个页面里面有一个iframe，它的src是http://damonare.cn/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的： 123456789&lt;script type="text/javascript"&gt; function test()&#123; var iframe = document.getElementById('￼ifame'); var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的 var doc = win.document;//这里获取不到iframe里的document对象 var name = win.name;//这里同样获取不到window对象的name属性 &#125;&lt;/script&gt;&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt; 这个时候，document.domain就可以派上用场了，我们只要把http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。在页面http://www.damonare.cn/a.html 中设置document.domain:1234567&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt; document.domain = 'damonare.cn';//设置成主域 function test()&#123; alert(document.getElementById('￼iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象 &#125;&lt;/script&gt; 在页面http://damonare.cn/b.html 中也设置document.domain:123&lt;script type="text/javascript"&gt; document.domain = 'damonare.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同&lt;/script&gt; 修改document.domain的方法只适用于不同子域的框架间的交互。 通过location.hash跨域因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。下面举例说明：假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。a.html传送数据到b.htmla.html下修改iframe的src为google.com/b.html#pacob.html监听到url发生变化，触发相应操作b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframeb.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”http://www.baidu.com/proxy.html#data“proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）a.html监听到url发生变化，触发相应操作b.html页面的关键代码如下:123456789try &#123; parent.location.hash = 'data'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = "http://www.baidu.com/proxy.html#data"; document.body.appendChild(ifrproxy); &#125; proxy.html页面的关键代码如下 :12//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值 parent.parent.location.hash = self.location.hash.substring(1); 通过HTML5的postMessage方法跨域高级浏览器Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信A页面通过postMessage方法发送消息：12345window.onload = function() &#123; var ifr = document.getElementById('ifr'); var targetOrigin = "http://www.google.com"; ifr.contentWindow.postMessage('hello world!', targetOrigin); &#125;; postMessage的使用方法：otherWindow.postMessage(message, targetOrigin);otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口message: 是要发送的消息，类型为 String、Object (IE8、9 不支持)targetOrigin: 是限定消息接收范围，不限制请使用 ‘*B页面通过message事件监听并接受消息:1234567891011121314var onmessage = function (event) &#123; var data = event.data;//消息 var origin = event.origin;//消息来源地址 var source = event.source;//源Window对象 if(origin=="http://www.baidu.com")&#123; console.log(data);//hello world! &#125; &#125;; if (typeof window.addEventListener != 'undefined') &#123; window.addEventListener('message', onmessage, false); &#125; else if (typeof window.attachEvent != 'undefined') &#123; //for ie window.attachEvent('onmessage', onmessage); &#125; 同理，也可以B页面发送消息，然后A页面监听并接受消息。 通过jsonp跨域刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是http://damonare.cn/data.php,那么a.html中的代码就可以这样：123456&lt;script type="text/javascript"&gt; function dosomething(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt; 我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。因为是当做一个js文件来引入的，所以http://damonare.cn/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦):12345&lt;?php$callback = $_GET['callback'];//得到回调函数名$data = array('a','b','c');//要返回的数据echo $callback.'('.json_encode($data).')';//输出?&gt; 最终，输出结果为：dosomething([‘a’,’b’,’c’]);如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。12345&lt;script type="text/javascript"&gt; $.getJSON('http://example.com/data.php?callback=?,function(jsondata)')&#123; //处理获得的json数据 &#125;);&lt;/script&gt; jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。JSONP的优缺点JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 通过CORS跨域CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。平时的ajax请求可能是这样的:12345&lt;script type="text/javascript"&gt; var xhr = new XMLHttpRequest(); xhr.open("POST", "/damonare",true); xhr.send();&lt;/script&gt; 以上damonare部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示： 12345&lt;script type="text/javascript"&gt; var xhr = new XMLHttpRequest(); xhr.open("￼GET", "http://segmentfault.com/u/trigkit4/",true); xhr.send();&lt;/script&gt; 代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。关于CORS更多了解可以看下阮一峰老师的这一篇文章：跨域资源共享 CORS 详解CORS和JSONP对比JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。CORS与JSONP相比，无疑更为先进、方便和可靠。 通过window.name跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。比如：我们在任意一个页面输入1234window.name = "My window's name";setTimeout(function()&#123; window.location.href = "http://damonare.cn/";&#125;,1000) 进入damonare.cn页面后我们再检测再检测 window.name :1window.name; // My window's name 可以看到，如果在一个标签里面跳转网页的话，我们的 window.name 是不会改变的。基于这个思想，我们可以在某个页面设置好 window.name 的值，然后跳转到另外一个页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。由于安全原因，浏览器始终会保持 window.name 是string 类型。同样这个方法也可以应用到和iframe的交互来：比如：我的页面(http://damonare.cn/index.html)中内嵌了一个iframe： &lt;iframe id=&quot;iframe&quot; src=&quot;http://www.google.com/iframe.html&quot;&gt;&lt;/iframe&gt;在 iframe.html 中设置好了 window.name 为我们要传递的字符串。我们在 index.html 中写了下面的代码：12345var iframe = document.getElementById('iframe');var data = '';iframe.onload = function() &#123; data = iframe.contentWindow.name;&#125;; Boom!报错！肯定的，因为两个页面不同源嘛，想要解决这个问题可以这样干：12345678var iframe = document.getElementById('iframe');var data = '';iframe.onload = function() &#123; iframe.onload = function()&#123; data = iframe.contentWindow.name; &#125; iframe.src = 'about:blank';&#125;; 或者将里面的 about:blank 替换成某个同源页面（about:blank，javascript: 和 data: 中的内容，继承了载入他们的页面的源。）这种方法与 document.domain 方法相比，放宽了域名后缀要相同的限制，可以从任意页面获取 string 类型的数据。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>前端</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua基础-文件库]]></title>
    <url>%2Flua%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[文件操作Lua I\/O 库提供两种不同的方式处理文件：隐式文件描述，显式文件描述。 这些文件 I\/O 操作，在 OpenResty 的上下文中对事件循环是会产生阻塞效应。 OpenResty 比较擅长的是高并发网络处理，在这个环境中，任何文件的操作，都将阻塞其他并行执行的请求。实际中的应用，在 OpenResty 项目中应尽可能让网络处理部分、文件 I\/0 操作部分相互独立，不要揉和在一起。 隐式文件描述设置一个默认的输入或输出文件，然后在这个文件上进行所有的输入或输出操作。所有的操作函数由 io 表提供。 打开已经存在的 test1.txt 文件，并读取里面的内容 12345678910111213141516file = io.input("test1.txt") -- 使用 io.input() 函数打开文件repeat line = io.read() -- 逐行读取内容，文件结束时返回nil if nil == line then break end print(line)until (false)io.close(file) -- 关闭文件--&gt; outputmy test filehellolua 在 test1.txt 文件的最后添加一行 “hello world” 1234file = io.open("test1.txt", "a+") -- 使用 io.open() 函数，以添加模式打开文件io.output(file) -- 使用 io.output() 函数，设置默认输出文件io.write("\nhello world") -- 使用 io.write() 函数，把内容写到文件io.close(file) 在相应目录下打开test1.txt文件，查看文件内容发生的变化。 显式文件描述使用 file:XXX() 函数方式进行操作,其中 file 为 io.open() 返回的文件句柄。 打开已经存在的 test2.txt 文件，并读取里面的内容 1234567891011file = io.open("test2.txt", "r") -- 使用 io.open() 函数，以只读模式打开文件for line in file:lines() do -- 使用 file:lines() 函数逐行读取文件 print(line)endfile:close()--&gt;outputmy test2hello lua 在 test2.txt 文件的最后添加一行 “hello world” 123file = io.open("test2.txt", "a") -- 使用 io.open() 函数，以添加模式打开文件file:write("\nhello world") -- 使用 file:open() 函数，在文件末尾追加内容file:close() 在相应目录下打开test2.txt文件，查看文件内容发生的变化。 文件操作函数io.open (filename [, mode])按指定的模式 mode，打开一个文件名为filename的文件，成功则返回文件句柄，失败则返回 nil 加错误信息。模式： 模式字符串后面可以有一个 ‘b’，用于在某些系统中打开二进制文件。 注意 “w” 和 “wb” 的区别 “w” 表示文本文件。某些文件系统(如 Linux 的文件系统)认为 0x0A 为文本文件的换行符，Windows 的文件系统认为 0x0D0A 为文本文件的换行符。为了兼容其他文件系统（如从 Linux 拷贝来的文件），Windows 的文件系统在写文件时，会在文件中 0x0A 的前面加上 0x0D。使用 “w”，其属性要看所在的平台。 “wb” 表示二进制文件。文件系统会按纯粹的二进制格式进行写操作，因此也就不存在格式转换的问题。（Linux 文件系统下 “w” 和 “wb” 没有区别） file:close ()关闭文件。注意：当文件句柄被垃圾收集后，文件将自动关闭。句柄将变为一个不可预知的值。 io.close ([file])关闭文件，和 file:close() 的作用相同。没有参数 file 时，关闭默认输出文件。 file:flush ()把写入缓冲区的所有数据写入到文件 file 中。 io.flush ()相当于 file:flush()，把写入缓冲区的所有数据写入到默认输出文件。 io.input ([file])当使用一个文件名调用时，打开这个文件（以文本模式），并设置文件句柄为默认输入文件；当使用一个文件句柄调用时，设置此文件句柄为默认输入文件；当不使用参数调用时，返回默认输入文件句柄。 file:lines ()返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回 nil，但不关闭文件。 io.lines ([filename])打开指定的文件 filename 为读模式并返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回 nil，并自动关闭文件。若不带参数时 io.lines() 等价于 io.input():lines() 读取默认输入设备的内容，结束时不关闭文件。 io.output ([file])类似于 io.input，但操作在默认输出文件上。 file:read (…)按指定的格式读取一个文件。按每个格式将返回一个字符串或数字,如果不能正确读取将返回 nil,若没有指定格式将指默认按行方式进行读取。格式： io.read (…)相当于 io.input():read io.type (obj)检测 obj 是否一个可用的文件句柄。如果 obj 是一个打开的文件句柄，则返回 “file” 如果 obj 是一个已关闭的文件句柄，则返回 “closed file” 如果 obj 不是一个文件句柄，则返回 nil。 file:write (…)把每一个参数的值写入文件。参数必须为字符串或数字，若要输出其它值，则需通过 tostring 或 string.format 进行转换。 io.write (…)相当于 io.output():write。 file:seek ([whence] [, offset])设置和获取当前文件位置，成功则返回最终的文件位置(按字节，相对于文件开头),失败则返回 nil 加错误信息。缺省时，whence 默认为 “cur”，offset 默认为 0。参数 whence： file:setvbuf (mode [, size])设置输出文件的缓冲模式。模式： 最后两种模式，size 可以指定缓冲的大小(按字节)，忽略 size 将自动调整为最佳的大小。 原文https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/file.html]]></content>
      <categories>
        <category>Lua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lua基础-数学库]]></title>
    <url>%2Flua%E5%9F%BA%E7%A1%80-%E6%95%B0%E5%AD%A6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Lua 数学库由一组标准的数学函数构成。数学库的引入丰富了 Lua 编程语言的功能，同时也方便了程序的编写。常用数学函数见下表： 1234567891011121314151617181920212223print(math.pi) --&gt;output 3.1415926535898print(math.rad(180)) --&gt;output 3.1415926535898print(math.deg(math.pi)) --&gt;output 180print(math.sin(1)) --&gt;output 0.8414709848079print(math.cos(math.pi)) --&gt;output -1print(math.tan(math.pi / 4)) --&gt;output 1print(math.atan(1)) --&gt;output 0.78539816339745print(math.asin(0)) --&gt;output 0print(math.max(-1, 2, 0, 3.6, 9.1)) --&gt;output 9.1print(math.min(-1, 2, 0, 3.6, 9.1)) --&gt;output -1print(math.fmod(10.1, 3)) --&gt;output 1.1print(math.sqrt(360)) --&gt;output 18.97366596101print(math.exp(1)) --&gt;output 2.718281828459print(math.log(10)) --&gt;output 2.302585092994print(math.log10(10)) --&gt;output 1print(math.floor(3.1415)) --&gt;output 3print(math.ceil(7.998)) --&gt;output 8 另外使用 math.random() 函数获得伪随机数时，如果不使用 math.randomseed() 设置伪随机数生成种子或者设置相同的伪随机数生成种子，那么得得到的伪随机数序列是一样的。示例代码： 1234math.randomseed (100) --把种子设置为100print(math.random()) --&gt;output 0.0012512588885159print(math.random(100)) --&gt;output 57print(math.random(100, 360)) --&gt;output 150 稍等片刻，再次运行上面的代码。 1234math.randomseed (100) --把种子设置为100print(math.random()) --&gt;output 0.0012512588885159print(math.random(100)) --&gt;output 57print(math.random(100, 360)) --&gt;output 150 两次运行的结果一样。为了避免每次程序启动时得到的都是相同的伪随机数序列，通常是使用当前时间作为种子。修改上例中的代码： 1234math.randomseed (os.time()) --把100换成os.time()print(math.random()) --&gt;output 0.88369396038697print(math.random(100)) --&gt;output 66print(math.random(100, 360)) --&gt;output 228 稍等片刻，再次运行上面的代码。 1234math.randomseed (os.time()) --把100换成os.time()print(math.random()) --&gt;output 0.88946195867794print(math.random(100)) --&gt;output 68print(math.random(100, 360)) --&gt;output 129 原文 https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/math_library.html]]></content>
      <categories>
        <category>Lua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lua基础-table库]]></title>
    <url>%2Flua%E5%9F%BA%E7%A1%80-table%E5%BA%93%2F</url>
    <content type="text"><![CDATA[table 库是由一些辅助函数构成的，这些函数将 table 作为数组来操作。 下标从 1 开始在 Lua 中，数组下标从 1 开始计数。官方解释：Lua lists have a base index of 1 because it was thought to be most friendly for non-programmers, as it makes indices correspond to ordinal element positions.确实，对于我们数数来说，总是从 1 开始数的，而从 0 开始对于描述偏移量这样的东西有利。 而 Lua 最初设计是一种类似 XML 的数据描述语言，所以索引（index）反应的是数据在里面的位置，而不是偏移量。在初始化一个数组的时候，若不显式地用键值对方式赋值，则会默认用数字作为下标，从 1 开始。由于在 Lua 内部实际采用哈希表和数组分别保存键值对、普通值，所以不推荐混合使用这两种赋值方式。 123456local color=&#123;first="red", "blue", third="green", "yellow"&#125;print(color["first"]) --&gt; output: redprint(color[1]) --&gt; output: blueprint(color["third"]) --&gt; output: greenprint(color[2]) --&gt; output: yellowprint(color[3]) --&gt; output: nil 从其他语言过来的开发者会觉得比较坑的一点是，当我们把 table 当作栈或者队列使用的时候，容易犯错，追加到 table 的末尾用的是 s[#s+1] = something，而不是 s[#s] = something，而且如果这个 something 是一个 nil 的话，会导致这一次压栈（或者入队列）没有存入任何东西，#s的值没有变。如果 s = { 1, 2, 3, 4, 5, 6 }，你令s[4] = nil，#s 会令你“匪夷所思”地变成 3 table.getn 获取长度取长度操作符写作一元操作 #。 字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度）。对于常规的数组，里面从 1 到 n 放着一些非空的值的时候， 它的长度就精确的为 n，即最后一个值的下标。 如果数组有一个“空洞” （就是说，nil 值被夹在非空值之间）， 那么 #t 可能是指向任何一个是 nil 值的前一个位置的下标 （就是说，任何一个 nil 值都有可能被当成数组的结束）。这也就说明对于有“空洞”的情况，table 的长度存在一定的 不可确定性。 1234567891011121314151617local tblTest1 = &#123; 1, a = 2, 3 &#125;print("Test1 " .. table.getn(tblTest1))local tblTest2 = &#123; 1, nil &#125;print("Test2 " .. table.getn(tblTest2))local tblTest3 = &#123; 1, nil, 2 &#125;print("Test3 " .. table.getn(tblTest3))local tblTest4 = &#123; 1, nil, 2, nil &#125;print("Test4 " .. table.getn(tblTest4))local tblTest5 = &#123; 1, nil, 2, nil, 3, nil &#125;print("Test5 " .. table.getn(tblTest5))local tblTest6 = &#123; 1, nil, 2, nil, 3, nil, 4, nil &#125;print("Test6 " .. table.getn(tblTest6)) 我们使用 Lua 5.1 和 LuaJIT 2.1 分别执行这个用例，结果如下： $ lua test.luaTest1 2Test2 1Test3 3Test4 1Test5 3Test6 1$ luajit test.luaTest1 2Test2 1Test3 1Test4 1Test5 1Test6 1 这一段的输出结果，就是这么 匪夷所思。请问，你以后还敢在 lua 的 table 中用 nil 值吗？如果你继续往后面加 nil，你可能会发现点什么。你可能认为你发现的是个规律。但是，你千万不要认为这是个规律，因为这是错误的。不要在 lua 的 table 中使用 nil 值，如果一个元素要删除，直接 remove，不要用 nil 去代替。 table.concat (table [, sep [, i [, j ] ] ])对于元素是 string 或者 number 类型的表 table，返回 table[i]..sep..table[i+1] ··· sep..table[j] 连接成的字符串。填充字符串 sep 默认为空白字符串。起始索引位置 i 默认为 1，结束索引位置 j 默认是 table 的长度。如果 i 大于 j，返回一个空字符串。 12345local a = &#123;1, 3, 5, "hello" &#125;print(table.concat(a)) -- output: 135helloprint(table.concat(a, "|")) -- output: 1|3|5|helloprint(table.concat(a, " ", 4, 2)) -- output:print(table.concat(a, " ", 2, 4)) -- output: 3 5 hello table.insert (table, [pos ,] value)在（数组型）表 table 的 pos 索引位置插入 value，其它元素向后移动到空的地方。pos 的默认值是表的长度加一，即默认是插在表的最后。 123456789local a = &#123;1, 8&#125; --a[1] = 1,a[2] = 8table.insert(a, 1, 3) --在表索引为1处插入3print(a[1], a[2], a[3])table.insert(a, 10) --在表的最后插入10print(a[1], a[2], a[3], a[4])--&gt;output3 1 83 1 8 10 table.maxn (table)返回（数组型）表 table 的最大索引编号；如果此表没有正的索引编号，返回 0。当长度省略时，此函数通常需要 O(n) 的时间复杂度来计算 table 的末尾。因此用这个函数省略索引位置的调用形式来作 table 元素的末尾追加，是高代价操作。 123456789local a = &#123;&#125;a[-1] = 10print(table.maxn(a))a[5] = 10print(table.maxn(a))--&gt;output05 此函数的行为不同于 # 运算符，因为 # 可以返回数组中任意一个 nil 空洞或最后一个 nil 之前的元素索引。当然，该函数的开销相比 # 运算符也会更大一些。 table.remove (table [, pos])在表 table 中删除索引为 pos（pos 只能是 number 型）的元素，并返回这个被删除的元素，它后面所有元素的索引值都会减一。pos 的默认值是表的长度，即默认是删除表的最后一个元素。 123456789101112local a = &#123; 1, 2, 3, 4&#125;print(table.remove(a, 1)) --删除速索引为1的元素print(a[1], a[2], a[3], a[4])print(table.remove(a)) --删除最后一个元素print(a[1], a[2], a[3], a[4])--&gt;output12 3 4 nil42 3 nil nil table.sort (table [, comp])按照给定的比较函数 comp 给表 table 排序，也就是从 table[1] 到 table[n] ，这里 n 表示 table 的长度。 比较函数有两个参数，如果希望第一个参数排在第二个的前面，就应该返回 true，否则返回 false。 如果比较函数 comp 没有给出，默认从小到大排序。 12345678910111213local function compare(x, y) --从大到小排序 return x &gt; y --如果第一个参数大于第二个就返回true，否则返回falseendlocal a = &#123; 1, 7, 3, 4, 25&#125;table.sort(a) --默认从小到大排序print(a[1], a[2], a[3], a[4], a[5])table.sort(a, compare) --使用比较函数进行排序print(a[1], a[2], a[3], a[4], a[5])--&gt;output1 3 4 7 2525 7 4 3 1 table 其他非常有用的函数LuaJIT 2.1 新增加的 table.new 和 table.clear 函数是非常有用的。前者主要用来预分配 lua table 空间，后者主要用来高效的释放 table 空间，并且它们都是可以被 JIT 编译的。具体可以参考一下 OpenResty 捆绑的 lua-resty-* 库，里面有些实例可以作为参考。 原文https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/table_library.html]]></content>
      <categories>
        <category>Lua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lua基础-String库]]></title>
    <url>%2Flua%E5%9F%BA%E7%A1%80-string%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Lua 字符串库包含很多强大的字符操作函数。字符串库中的所有函数都导出在模块 string 中。在 Lua 5.1 中，它还将这些函数导出作为 string 类型的方法。这样假设要返回一个字符串转的大写形式，可以写成 ans = string.upper(s) ,也能写成 ans = s:upper()。为了避免与之前版本不兼容，此处使用前者。Lua 字符串总是由字节构成的。Lua 核心并不尝试理解具体的字符集编码（比如 GBK 和 UTF-8 这样的多字节字符编码）。需要特别注意的一点是，Lua 字符串内部用来标识各个组成字节的下标是从 1 开始的，这不同于像 C 和 Perl 这样的编程语言。这样数字符串位置的时候再也不用调整，对于非专业的开发者来说可能也是一个好事情，string.sub(str, 3, 7) 直接表示从第三个字符开始到第七个字符（含）为止的子串。 string.byte(s[,i[,j]])返回字符 s[i]、s[i + 1]、s[i + 2]、······、s[j] 所对应的 ASCII 码。i 的默认值为 1，即第一个字节,j 的默认值为 i 。 12345678print(string.byte("abc", 1, 3))print(string.byte("abc", 3)) -- 缺少第三个参数，第三个参数默认与第二个相同，此时为 3print(string.byte("abc")) -- 缺少第二个和第三个参数，此时这两个参数都默认为 1--&gt;output97 98 999997 由于 string.byte 只返回整数，而并不像 string.sub 等函数那样（尝试）创建新的 Lua 字符串， 因此使用 string.byte 来进行字符串相关的扫描和分析是最为高效的，尤其是在被 LuaJIT 2 所 JIT 编译之后。 string.char (…)接收 0 个或更多的整数（整数范围 ：0~255）,返回这些整数所对应的 ASCII 码字符组成的字符串。当参数为空时，默认是一个 0。 123456789print(string.char(96, 97, 98))print(string.char()) -- 参数为空，默认是一个0， -- 你可以用string.byte(string.char())测试一下print(string.char(65, 66))--&gt; output`abAB 此函数特别适合从具体的字节构造出二进制字符串。这经常比使用 table.concat 函数和 .. 连接运算符更加高效。 string.upper(s)接收一个字符串 s，返回一个把所有小写字母变成大写字母的字符串。 string.lower(s)接收一个字符串 s，返回一个把所有大写字母变成小写字母的字符串。 string.len(s)接收一个字符串，返回它的长度。 使用此函数是不推荐的。应当总是使用` # 运算符来获取 Lua 字符串的长度由于 Lua 字符串的长度是专门存放的，并不需要像 C 字符串那样即时计算，因此获取字符串长度的操作总是 O(1) 的时间复杂度。 string.find(s, p [, init [, plain]])在 s 字符串中第一次匹配 p 字符串。若匹配成功，则返回 p 字符串在 s 字符串中出现的开始位置和结束位置；若匹配失败，则返回 nil。 第三个参数 init 默认为 1，并且可以为负整数，当 init 为负数时，表示从 s 字符串的 string.len(s) + init 索引处开始向后匹配字符串 p 。 第四个参数默认为 false，当其为 true 时，只会把 p 看成一个字符串对待。 123456789101112131415local find = string.findprint(find("abc cba", "ab"))print(find("abc cba", "ab", 2)) -- 从索引为2的位置开始匹配字符串：abprint(find("abc cba", "ba", -1)) -- 从索引为7的位置开始匹配字符串：baprint(find("abc cba", "ba", -3)) -- 从索引为6的位置开始匹配字符串：baprint(find("abc cba", "(%a+)", 1)) -- 从索引为1处匹配最长连续且只含字母的字符串print(find("abc cba", "(%a+)", 1, true)) --从索引为1的位置开始匹配字符串：(%a+)--&gt;output1 2nilnil6 71 3 abcnil 对于 LuaJIT 这里有个性能优化点，对于 string.find 方法，当只有字符串查找匹配时，是可以被 JIT 编译器优化的，有关 JIT 可以编译优化清单，大家可以参考 http://wiki.luajit.org/NYI ，性能提升是非常明显的，通常是 100 倍量级。 这里有个的例子，大家可以参考 https://groups.google.com/forum/m/#!topic/openresty-en/rwS88FGRsUI。 string.format(formatstring, …)按照格式化参数 formatstring，返回后面 … 内容的格式化版本。编写格式化字符串的规则与标准 c 语言中 printf 函数的规则基本相同：它由常规文本和指示组成，这些指示控制了每个参数应放到格式化结果的什么位置，及如何放入它们。一个指示由字符 % 加上一个字母组成，这些字母指定了如何格式化参数，例如 d 用于十进制数、x 用于十六进制数、o 用于八进制数、f 用于浮点数、s 用于字符串等。在字符%和字母之间可以再指定一些其他选项，用于控制格式的细节。 123456789print(string.format("%.4f", 3.1415926)) -- 保留4位小数print(string.format("%d %x %o", 31, 31, 31))-- 十进制数31转换成不同进制d = 29; m = 7; y = 2015 -- 一行包含几个语句，用；分开print(string.format("%s %02d/%02d/%d", "today is:", d, m, y))--&gt;output3.141631 1f 37today is: 29/07/2015 string.match(s, p [, init])在字符串 s 中匹配（模式）字符串 p，若匹配成功，则返回目标字符串中与模式匹配的子串；否则返回 nil。第三个参数 init 默认为 1，并且可以为负整数，当 init 为负数时，表示从 s 字符串的 string.len(s) + init 索引处开始向后匹配字符串 p。 12345678910print(string.match("hello lua", "lua"))print(string.match("lua lua", "lua", 2)) --匹配后面那个luaprint(string.match("lua lua", "hello"))print(string.match("today is 27/7/2015", "%d+/%d+/%d+"))--&gt;outputlualuanil27/7/2015 string.match 目前并不能被 JIT 编译，应 尽量 使用 ngx_lua 模块提供的 ngx.re.match 等接口。 string.gmatch(s, p)返回一个迭代器函数，通过这个迭代器函数可以遍历到在字符串 s 中出现模式串 p 的所有地方。 123456789101112131415161718192021222324s = "hello world from Lua"for w in string.gmatch(s, "%a+") do --匹配最长连续且只含字母的字符串 print(w)end--&gt;outputhelloworldfromLuat = &#123;&#125;s = "from=world, to=Lua"for k, v in string.gmatch(s, "(%a+)=(%a+)") do --匹配两个最长连续且只含字母的 t[k] = v --字符串，它们之间用等号连接endfor k, v in pairs(t) doprint (k,v)end--&gt;outputto Luafrom world 此函数目前并不能被 LuaJIT 所 JIT 编译，而只能被解释执行。应 尽量 使用 ngx_lua 模块提供的 ngx.re.gmatch 等接口。 string.rep(s, n)返回字符串 s 的 n 次拷贝。 string.sub(s, i [, j])返回字符串 s 中，索引 i 到索引 j 之间的子字符串。当 j 缺省时，默认为 -1，也就是字符串 s 的最后位置。 i 可以为负数。当索引 i 在字符串 s 的位置在索引 j 的后面时，将返回一个空字符串。 12345678910print(string.sub("Hello Lua", 4, 7))print(string.sub("Hello Lua", 2))print(string.sub("Hello Lua", 2, 1)) --看到返回什么了吗print(string.sub("Hello Lua", -3, -1))--&gt;outputlo Lello LuaLua 如果你只是想对字符串中的单个字节进行检查，使用 string.char 函数通常会更为高效。 string.gsub(s, p, r [, n])将目标字符串 s 中所有的子串 p 替换成字符串 r。可选参数 n，表示限制替换次数。返回值有两个，第一个是被替换后的字符串，第二个是替换了多少次。 123456print(string.gsub("Lua Lua Lua", "Lua", "hello"))print(string.gsub("Lua Lua Lua", "Lua", "hello", 2)) --指明第四个参数--&gt;outputhello hello hello 3hello hello Lua 2 此函数不能为 LuaJIT 所 JIT 编译，而只能被解释执行。一般我们推荐使用 ngx_lua 模块提供的 ngx.re.gsub 函数。 string.reverse (s)接收一个字符串 s，返回这个字符串的反转。 1print(string.reverse("Hello Lua")) --&gt; output: auL olleH 原文地址https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/string_library.html]]></content>
      <categories>
        <category>Lua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lua基础-模块]]></title>
    <url>%2Flua%E5%9F%BA%E7%A1%80-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[从 Lua 5.1 语言添加了对模块和包的支持。一个 Lua 模块的数据结构是用一个 Lua 值（通常是一个 Lua 表或者 Lua 函数）。一个 Lua 模块代码就是一个会返回这个 Lua 值的代码块。 可以使用内建函数 require() 来加载和缓存模块。简单的说，一个代码模块就是一个程序库，可以通过 require 来加载。模块加载后的结果通过是一个 Lua table，这个表就像是一个命名空间，其内容就是模块中导出的所有东西，比如函数和变量。require 函数会返回 Lua 模块加载后的结果，即用于表示该 Lua 模块的 Lua 值。 require 函数Lua 提供了一个名为 require 的函数用来加载模块。要加载一个模块，只需要简单地调用 require “file”就可以了，file 指模块所在的文件名。这个调用会返回一个由模块函数组成的 table ，并且还会定义一个包含该 table 的全局变量。在 Lua 中创建一个模块最简单的方法是：创建一个 table ，并将所有需要导出的函数放入其中，最后返回这个 table 就可以了。相当于将导出的函数作为 table 的一个字段，在 Lua 中函数是第一类值，提供了天然的优势。 1234567891011local foo=&#123;&#125;local function getname() return "Lucy"endfunction foo.greeting() print("hello " .. getname())endreturn foo 调用 12local fp = require("my")fp.greeting() --&gt;output: hello Lucy 注：对于需要导出给外部使用的公共模块，处于安全考虑，是要避免全局变量的出现。我们可以使用 lua-releng 工具完成全局变量的检测，具体参考 lua 的 局部变量 章节。 原文https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/module.html]]></content>
      <categories>
        <category>Lua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lua基础]]></title>
    <url>%2Flua%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Lua 基础数据类型nilnil 是一种类型，Lua 将 nil 用于表示“无效值”。一个变量在第一次赋值前的默认值是 nil，将 nil 赋予给一个全局变量就等同于删除它。 12345local numprint(num) --&gt;output:nilnum = 10print(num) --&gt;output:10 boolean布尔类型，可选值 true/false；Lua 中 nil 和 false 为“假”，其它所有值均为“真”。 1234567891011121314151617181920local a = truelocal b = 0local c = nilif a then print("a") --&gt;output:aelse print("not a") --这个没有执行endif b then print("b") --&gt;output:belse print("not b") --这个没有执行endif c then print("c") --这个没有执行else print("not c") --&gt;output:not cend number（数字）Number 类型用于表示实数，和 C/C++ 里面的 double 类型很类似。可以使用数学函数 math.floor（向下取整）和 math.ceil（向上取整）进行取整操作。 1234local order = 3.99local score = 98.01print(math.floor(order)) --&gt;output:3print(math.ceil(score)) --&gt;output:99 一般地，Lua 的 number 类型就是用双精度浮点数来实现的。值得一提的是，LuaJIT 支持所谓的“dual-number”（双数）模式，即 LuaJIT 会根据上下文用整型来存储整数，而用双精度浮点数来存放浮点数。+ 另外，LuaJIT 还支持“长长整型”的大整数（在 x86_64 体系结构上则是 64 位整数）。例如print(9223372036854775807LL - 1) --&gt;output:9223372036854775806LL String (字符串)Lua 中有三种方式表示字符串:1、使用一对匹配的单引号。例：’hello’。2、使用一对匹配的双引号。例：”abclua”。3、字符串还可以用一种长括号（即[[ ]]）括起来的方式定义。 我们把两个正的方括号（即[[ ）间插入 n 个等号定义为第 n 级正长括号。 就是说，0 级正的长括号写作 [[ ， 一级正的长括号写作 [=[ ，如此等等。 反的长括号也作类似定义； 举个例子，4 级反的长括号写作 ]====] 。 一个长字符串可以由任何一级的正的长括号开始，而由第一个碰到的同级反的长括号结束。 整个词法分析过程将不受分行限制，不处理任何转义符，并且忽略掉任何不同级别的长括号。 这种方式描述的字符串可以包含任何东西，当然本级别的反长括号除外。 例：[[abc\nbc]]，里面的 &quot;\n&quot; 不会被转义。另外，Lua 的字符串是不可改变的值，不能像在 c 语言中那样直接修改字符串的某个字符，而是根据修改要求来创建一个新的字符串。Lua 也不能通过下标来访问字符串的某个字符。 123456789local str1 = 'hello world'local str2 = "hello lua"local str3 = [["add\name",'hello']]local str4 = [=[string have a [[]].]=]print(str1) --&gt;output:hello worldprint(str2) --&gt;output:hello luaprint(str3) --&gt;output:"add\name",'hello'print(str4) --&gt;output:string have a [[]]. 在 Lua 实现中，Lua 字符串一般都会经历一个“内化”（intern）的过程，即两个完全一样的 Lua 字符串在 Lua 虚拟机中只会存储一份。每一个 Lua 字符串在创建时都会插入到 Lua 虚拟机内部的一个全局的哈希表中。 这意味着 创建相同的 Lua 字符串并不会引入新的动态内存分配操作，所以相对便宜（但仍有全局哈希表查询的开销）， 内容相同的 Lua 字符串不会占用多份存储空间， 已经创建好的 Lua 字符串之间进行相等性比较时是 O(1) 时间度的开销，而不是通常见到的 O(n). table(表)Table 类型实现了一种抽象的“关联数组”。“关联数组” 是一种具有特殊索引方式的数组，索引通常是字符串（string）或者 number 类型，但也可以是除 nil 以外的任意类型的值。 123456789101112131415161718local corp = &#123; web = "www.google.com", --索引为字符串，key = "web", -- value = "www.google.com" telephone = "12345678", --索引为字符串 staff = &#123;"Jack", "Scott", "Gary"&#125;, --索引为字符串，值也是一个表 100876, --相当于 [1] = 100876，此时索引为数字 -- key = 1, value = 100876 100191, --相当于 [2] = 100191，此时索引为数字 [10] = 360, --直接把数字索引给出 ["city"] = "Beijing" --索引为字符串&#125;print(corp.web) --&gt;output:www.google.comprint(corp["telephone"]) --&gt;output:12345678print(corp[2]) --&gt;output:100191print(corp["city"]) --&gt;output:"Beijing"print(corp.staff[1]) --&gt;output:Jackprint(corp[10]) --&gt;output:360 在内部实现上，table 通常实现为一个哈希表、一个数组、或者两者的混合。具体的实现为何种形式，动态依赖于具体的 table 的键分布特点。 function (函数)在 Lua 中，函数 也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。 123456789101112131415161718192021222324252627282930local function foo() print("in the function") --dosomething() local x = 10 local y = 20 return x + yendlocal a = foo --把函数赋给变量print(a())--output:in the function30有名函数的定义本质上是匿名函数对变量的赋值。为说明这一点，考虑function foo()end等价于foo = function ()end类似地，local function foo()end等价于local foo = function ()end Lua 表达式算数表达式+ - * / % ^ ^指数 12345678910print(1 + 2) --&gt;打印 3print(5 / 10) --&gt;打印 0.5。 这是Lua不同于c语言的print(5.0 / 10) --&gt;打印 0.5。 浮点数相除的结果是浮点数-- print(10 / 0) --&gt;注意除数不能为0，计算的结果会出错print(2 ^ 10) --&gt;打印 1024。 求2的10次方local num = 1357print(num % 2) --&gt;打印 1print((num % 2) == 1) --&gt;打印 true。 判断num是否为奇数print((num % 5) == 0) --&gt;打印 false。判断num是否能被5整数 关系运算符&lt; &gt; &lt;= &gt;= == ~= ~= 不等于 12345print(1 &lt; 2) --&gt;打印 trueprint(1 == 2) --&gt;打印 falseprint(1 ~= 2) --&gt;打印 truelocal a, b = true, falseprint(a == b) --&gt;打印 false 在使用“==”做等于判断时，要注意对于 table, userdate 和函数， Lua 是作引用比较的。也就是说，只有当两个变量引用同一个对象时，才认为它们相等。可以看下面的例子： 12345678910local a = &#123; x = 1, y = 0&#125;local b = &#123; x = 1, y = 0&#125;if a == b then print("a==b")else print("a~=b")end---output:a~=b 由于 Lua 字符串总是会被“内化”，即相同内容的字符串只会被保存一份，因此 Lua 字符串之间的相等性比较可以简化为其内部存储地址的比较。这意味着 Lua 字符串的相等性比较总是为 O(1). 而在其他编程语言中，字符串的相等性比较则通常为 O(n)，即需要逐个字节（或按若干个连续字节）进行比较。 逻辑运算符and or not 与 或 非 Lua 中的 and 和 or 是不同于 c 语言的。在 c 语言中，and 和 or 只得到两个值 1 和 0，其中 1 表示真，0 表示假。而 Lua 中 and 的执行过程是这样的： a and b 如果 a 为 nil，则返回 a，否则返回 b;a or b如果 a 为 nil，则返回 b，否则返回 a。 所有逻辑操作符将 false 和 nil 视作假，其他任何值视作真，对于 and 和 or，“短路求值”，对于 not，永远只返回 true 或者 false。 字符串连接在 Lua 中连接两个字符串，可以使用操作符“..”（两个点）。如果其任意一个操作数是数字的话，Lua 会将这个数字转换成字符串。注意，连接操作符只会创建一个新字符串，而不会改变原操作数。也可以使用 string 库函数 string.format 连接字符串。 12345678print("Hello " .. "World") --&gt;打印 Hello Worldprint(0 .. 1) --&gt;打印 01str1 = string.format("%s-%s","hello","world")print(str1) --&gt;打印 hello-worldstr2 = string.format("%d-%s-%.2f",123,"world",1.21)print(str2) --&gt;打印 123-world-1.21 由于 Lua 字符串本质上是只读的，因此字符串连接运算符几乎总会创建一个新的（更大的）字符串。这意味着如果有很多这样的连接操作（比如在循环中使用 .. 来拼接最终结果），则性能损耗会非常大。在这种情况下，推荐使用 table 和 table.concat() 来进行很多字符串的拼接，例如： 12345local pieces = &#123;&#125;for i, elem in ipairs(my_list) do pieces[i] = my_process(elem)endlocal res = table.concat(pieces) 当然，上面的例子还可以使用 LuaJIT 独有的 table.new 来恰当地初始化 pieces 表的空间，以避免该表的动态生长。这个特性我们在后面还会详细讨论。 优先级Lua 操作符的优先级如下表所示(从高到低)： 12345678^not # -* / %+ -..&lt; &gt; &lt;= &gt;= == ~=andor 1234567local a, b = 1, 2local x, y = 3, 4local i = 10local res = 0res = a + i &lt; b/2 + 1 --&gt;等价于res = (a + i) &lt; ((b/2) + 1)res = 5 + x^2*8 --&gt;等价于res = 5 + ((x^2) * 8)res = a &lt; y and y &lt;=x --&gt;等价于res = (a &lt; y) and (y &lt;= x) 若不确定某些操作符的优先级，就应显示地用括号来指定运算顺序。这样做还可以提高代码的可读性。 Lua 的控制结构流程控制语句对于程序设计来说特别重要，它可以用于设定程序的逻辑结构。一般需要与条件判断语句结合使用。Lua 语言提供的控制结构有 if，while，repeat，for，并提供 break 关键字来满足更丰富的需求。本章主要介绍 Lua 语言的控制结构的使用。 if/elseif-else 是我们熟知的一种控制结构。Lua 跟其他语言一样，提供了 if-else 的控制结构。因为是大家熟悉的语法，本节只简单介绍一下它的使用方法。 单个 if 分支1234local x = 10if x &gt; 0 then print('x is a positive number')end 两个分支 if-else 型123456x = 10if x &gt; 0 then print("x is a positive number")else print("x is a non-positive number")end 多个分支 if-elseif-else123456789local score = 90if score == 100 then print("Very good!Your score is 100")elseif score &gt;= 60 then print("Congratulations, you have passed it,your score greater or equal to 60")--此处可以添加多个elseifelse print("Sorry, you do not pass the exam! ")end 与 C 语言的不同之处是 else 与 if 是连在一起的，若将 else 与 if 写成 “else if” 则相当于在 else 里嵌套另一个 if 语句，如下代码： 123456789101112score = 0if score == 100 then print("Very good!Your score is 100")elseif score &gt;= 60 then print("Congratulations, you have passed it,your score greater or equal to 60")else if score &gt; 0 then print("Your score is better than 0") else print("My God, your score turned out to be 0") end --与上一示例代码不同的是，此处要添加一个endend whileLua 跟其他常见语言一样，提供了 while 控制结构，语法上也没有什么特别的。但是没有提供 do-while 型的控制结构，但是提供了功能相当的 repeat。+ while 型控制结构语法如下，当表达式值为假（即 false 或 nil）时结束循环。也可以使用 break 语言提前跳出循环。 123while 表达式 do--bodyend 示例代码，求 1 + 2 + 3 + 4 + 5 的结果 12345678x = 1sum = 0while x &lt;= 5 do sum = sum + x x = x + 1endprint(sum) --&gt;output 15 值得一提的是，Lua 并没有像许多其他语言那样提供类似 continue 这样的控制语句用来立即进入下一个循环迭代（如果有的话）。因此，我们需要仔细地安排循环体里的分支，以避免这样的需求。没有提供 continue ，却也提供了另外一个标准控制语句 break ，可以跳出当前循环。例如我们遍历 table ，查找值为 11 的数组下标索引： 123456789local t = &#123;1, 3, 5, 8, 11, 18, 21&#125;local ifor i, v in ipairs(t) do if 11 == v then print("index[" .. i .. "] have right value[11]") break endend repeatLua 中的 repeat 控制结构类似于其他语言（如：C++语言）中的 do-while，但是控制方式是刚好相反的。简单点说，执行 repeat 循环体后，直到 until 的条件为真时才结束，而其他语言（如：C++语言）的 do-while 则是当条件为假时就结束循环。 1234x = 10repeat print(x)until true 除此之外，repeat 与其他语言的 do-while 基本是一样的。同样，Lua 中的 repeat 也可以在使用 break 退出。 forfor 数字型 for 语句有两种形式：数字 for（numeric for）和范型 for（generic for）。 数字型 for 的语法如下： 123for var = begin, finish, step do --bodyend 关于数字 for 需要关注以下几点： var 从 begin 变化到 finish，每次变化都以 step 作为步长递增 var begin、 finish、 step 三个表达式只会在循环开始时执行一次 第三个表达式 step 是可选的， 默认为 1 控制变量 var 的作用域仅在 for 循环内，需要在外面控制，则需将值赋给一个新的变量 循环过程中不要改变控制变量的值，那样会带来不可预知的影响 12345678910for i = 1, 5 do print(i)end-- output:12345 如果不想给循环设置上限的话，可以使用常量 math.huge： 123456for i = 1, math.huge do if (0.3*i^3 - 20*i^2 - 500 &gt;=0) then print(i) break endend for 泛型泛型 for 循环通过一个迭代器（iterator）函数来遍历所有值： 1234567891011-- 打印数组a的所有值local a = &#123;"a", "b", "c", "d"&#125;for i, v in ipairs(a) do print("index:", i, " value:", v)end-- output:index: 1 value: aindex: 2 value: bindex: 3 value: cindex: 4 value: d Lua 的基础库提供了 ipairs，这是一个用于遍历数组的迭代器函数。在每次循环中，i 会被赋予一个索引值，同时 v 被赋予一个对应于该索引的数组元素值。下面是另一个类似的示例，演示了如何遍历一个 table 中所有的 key 1234-- 打印table t中所有的keyfor k in pairs(t) do print(k)end 从外观上看泛型 for 比较简单，但其实它是非常强大的。通过不同的迭代器，几乎可以遍历所有的东西， 而且写出的代码极具可读性。标准库提供了几种迭代器，包括用于迭代文件中每行的（io.lines）、 迭代 table 元素的（pairs）、迭代数组元素的（ipairs）、迭代字符串中单词的（string.gmatch）等。泛型 for 循环与数字型 for 循环有两个相同点：（1）循环变量是循环体的局部变量；（2）决不应该对循环变量作任何赋值。 对于泛型 for 的使用，再来看一个更具体的示例。假设有这样一个 table，它的内容是一周中每天的名称： 1234local days = &#123; "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"&#125; 现在要将一个名称转换成它在一周中的位置。为此，需要根据给定的名称来搜索这个 table。然而 在 Lua 中，通常更有效的方法是创建一个“逆向 table”。例如这个逆向 table 叫 revDays，它以 一周中每天的名称作为索引，位置数字作为值： 123456789local revDays = &#123; ["Sunday"] = 1, ["Monday"] = 2, ["Tuesday"] = 3, ["Wednesday"] = 4, ["Thursday"] = 5, ["Friday"] = 6, ["Saturday"] = 7 &#125; 接下来，要找出一个名称所对应的需要，只需用名字来索引这个 reverse table 即可： 12local x = "Tuesday"print(revDays[x]) --&gt;3 当然，不必手动声明这个逆向 table，而是通过原来的 table 自动地构造出这个逆向 table： 1234567891011121314151617181920212223local days = &#123; "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday","Sunday"&#125;local revDays = &#123;&#125;for k, v in pairs(days) do revDays[v] = kend-- print valuefor k,v in pairs(revDays) do print("k:", k, " v:", v)end-- output:k: Tuesday v: 2k: Monday v: 1k: Sunday v: 7k: Thursday v: 4k: Friday v: 5k: Wednesday v: 3k: Saturday v: 6 这个循环会为每个元素进行赋值，其中变量 k 为 key(1、2、…)，变量 v 为 value(“Sunday”、”Monday”、…)。值得一提的是，在 LuaJIT 2.1 中，ipairs() 内建函数是可以被 JIT 编译的，而 pairs() 则只能被解释执行。因此在性能敏感的场景，应当合理安排数据结构，避免对哈希表进行遍历。事实上，即使未来 pairs 可以被 JIT 编译，哈希表的遍历本身也不会有数组遍历那么高效，毕竟哈希表就不是为遍历而设计的数据结构。 break/returnbreak 语句 break 用来终止 while、repeat 和 for 三种循环的执行，并跳出当前循环体， 继续执行当前循环之后的语句。下面举一个 while 循环中的 break 的例子来说明： 12345678910sum = 0i = 1while true do sum = sum + i if sum &gt; 100 then break end i = i + 1endprint("The result is " .. i) --&gt;output:The result is 14 在实际应用中，break 经常用于嵌套循环中。 return return 主要用于从函数中返回结果，或者用于简单的结束一个函数的执行。 Lua 函数在 Lua 中，函数是一种对语句和表达式进行抽象的主要机制。函数既可以完成某项特定的任务，也可以只做一些计算并返回结果。在第一种情况中，一句函数调用被视为一条语句；而在第二种情况中，则将其视为一句表达式。示例代码： 123print("hello world!") -- 用 print() 函数输出 hello world！local m = math.max(1, 5) -- 调用数学库函数 max， -- 用来求 1,5 中的最大值，并返回赋给变量 m 使用函数的好处： 降低程序的复杂性：把函数作为一个独立的模块，写完函数后，只关心它的功能，而不再考虑函数里面的细节。增加程序的可读性：当我们调用 math.max() 函数时，很明显函数是用于求最大值的，实现细节就不关心了。避免重复代码：当程序中有相同的代码部分时，可以把这部分写成一个函数，通过调用函数来实现这部分代码的功能，节约空间，减少代码长度。隐含局部变量：在函数中使用局部变量，变量的作用范围不会超出函数，这样它就不会给外界带来干扰。 函数的定义Lua 使用关键字 function 定义函数，语法如下： 123function function_name (arc) -- arc 表示参数列表，函数的参数列表可以为空 -- bodyend 上面的语法定义了一个全局函数，名为 function_name. 全局函数本质上就是函数类型的值赋给了一个全局变量，即上面的语法等价于 123function_name = function (arc) -- bodyend 由于全局变量一般会污染全局名字空间，同时也有性能损耗（即查询全局环境表的开销），因此我们应当尽量使用“局部函数”，其记法是类似的，只是开头加上 local 修饰符： 123local function function_name (arc) -- bodyend 由于函数定义本质上就是变量赋值，而变量的定义总是应放置在变量使用之前，所以函数的定义也需要放置在函数调用之前。 123456789101112local function max(a, b) --定义函数 max，用来求两个数的最大值，并返回 local temp = nil --使用局部变量 temp，保存最大值 if(a &gt; b) then temp = a else temp = b end return temp --返回最大值endlocal m = max(-12, 20) --调用函数 max，找去 -12 和 20 中的最大值print(m) --&gt; output 20 如果参数列表为空，必须使用 () 表明是函数调用。 12345678local function func() --形参为空 print("no parameter")endfunc() --函数调用，圆扩号不能省--&gt; output：no parameter 在定义函数要注意几点： 利用名字来解释函数、变量的目的，使人通过名字就能看出来函数、变量的作用。 每个函数的长度要尽量控制在一个屏幕内，一眼可以看明白。 让代码自己说话，不需要注释最好。 由于函数定义等价于变量赋值，我们也可以把函数名替换为某个 Lua 表的某个字段，例如 123function foo.bar(a, b, c) -- body ...end 此时我们是把一个函数类型的值赋给了 foo 表的 bar 字段。换言之，上面的定义等价于 123foo.bar = function (a, b, c) print(a, b, c)end 对于此种形式的函数定义，不能再使用 local 修饰符了，因为不存在定义新的局部变量了。 函数的参数按值传递Lua 函数的参数大部分是按值传递的。值传递就是调用函数时，实参把它的值通过赋值运算传递给形参，然后形参的改变和实参就没有关系了。在这个过程中，实参是通过它在参数表中的位置与形参匹配起来的。 1234567891011121314151617local function swap(a, b) --定义函数swap,函数内部进行交换两个变量的值 local temp = a a = b b = temp print(a, b)endlocal x = "hello"local y = 20print(x, y)swap(x, y) --调用swap函数print(x, y) --调用swap函数后，x和y的值并没有交换--&gt;outputhello 2020 hellohello 20 在调用函数的时候，若形参个数和实参个数不同时，Lua 会自动调整实参个数。调整规则：若实参个数大于形参个数，从左向右，多余的实参被忽略；若实参个数小于形参个数，从左向右，没有被实参初始化的形参会被初始化为 nil。 123456789101112131415161718local function fun1(a, b) --两个形参，多余的实参被忽略掉 print(a, b)endlocal function fun2(a, b, c, d) --四个形参，没有被实参初始化的形参，用nil初始化 print(a, b, c, d)endlocal x = 1local y = 2local z = 3fun1(x, y, z) -- z被函数fun1忽略掉了，参数变成 x, yfun2(x, y, z) -- 后面自动加上一个nil，参数变成 x, y, z, nil--&gt;output1 21 2 3 nil 变长参数上面函数的参数都是固定的，其实 Lua 还支持变长参数。若形参为 … ,示该函数可以接收不同长度的参数。访问参数的时候也要使用 … 123456789101112131415local function func( ... ) -- 形参为 ... ,表示函数采用变长参数 local temp = &#123;...&#125; -- 访问的时候也要使用 ... local ans = table.concat(temp, " ") -- 使用 table.concat 库函数对数 -- 组内容使用 " " 拼接成字符串。 print(ans)endfunc(1, 2) -- 传递了两个参数func(1, 2, 3, 4) -- 传递了四个参数--&gt;output1 21 2 3 4 值得一提的是，LuaJIT 2 尚不能 JIT 编译这种变长参数的用法，只能解释执行。所以对性能敏感的代码，应当避免使用此种形式。 具名参数(参数是一个 table)Lua 还支持通过名称来指定实参，这时候要把所有的实参组织到一个 table 中，并将这个 table 作为唯一的实参传给函数。 12345678910111213141516local function change(arg) -- change 函数，改变长方形的长和宽，使其各增长一倍 arg.width = arg.width * 2 arg.height = arg.height * 2 return argendlocal rectangle = &#123; width = 20, height = 15 &#125;print("before change:", "width =", rectangle.width, "height =", rectangle.height)rectangle = change(rectangle)print("after change:", "width =", rectangle.width, "height =", rectangle.height)--&gt;outputbefore change: width = 20 height = 15after change: width = 40 height = 30 按引用传递当函数参数是 table 类型时，传递进来的是 实际参数的引用，此时在函数内部对该 table 所做的修改，会直接对调用者所传递的实际参数生效，而无需自己返回结果和让调用者进行赋值。 我们把上面改变长方形长和宽的例子修改一下。 123456789101112131415function change(arg) --change函数，改变长方形的长和宽，使其各增长一倍 arg.width = arg.width * 2 --表arg不是表rectangle的拷贝，他们是同一个表 arg.height = arg.height * 2end -- 没有return语句了local rectangle = &#123; width = 20, height = 15 &#125;print("before change:", "width = ", rectangle.width, " height = ", rectangle.height)change(rectangle)print("after change:", "width = ", rectangle.width, " height =", rectangle.height)--&gt; outputbefore change: width = 20 height = 15after change: width = 40 height = 30 在常用基本类型中，除了 table 是按址传递类型外，其它的都是按值传递参数。 用全局变量来代替函数参数的不好编程习惯应该被抵制，良好的编程习惯应该是减少全局变量的使用。 函数返回值Lua 具有一项与众不同的特性，允许函数返回多个值。Lua 的库函数中，有一些就是返回多个值。 示例代码：使用库函数 string.find，在源字符串中查找目标字符串，若查找成功，则返回目标字符串在源字符串中的起始位置和结束位置的下标。 12local s, e = string.find("hello world", "llo")print(s, e) --&gt;output 3 5 返回多个值时，值之间用 “,” 隔开。 示例代码：定义一个函数，实现两个变量交换值 12345678local function swap(a, b) -- 定义函数 swap，实现两个变量交换值 return b, a -- 按相反顺序返回变量的值endlocal x = 1local y = 20x, y = swap(x, y) -- 调用 swap 函数print(x, y) --&gt; output 20 1 当函数返回值的个数和接收返回值的变量的个数不一致时，Lua 也会自动调整参数个数。 调整规则： 若返回值个数大于接收变量的个数，多余的返回值会被忽略掉； 若返回值个数小于参数个数，从左向右，没有被返回值初始化的变量会被初始化为 nil。 12345678910111213function init() --init 函数 返回两个值 1 和 "lua" return 1, "lua"endx = init()print(x)x, y, z = init()print(x, y, z)--output11 lua nil 当一个函数有一个以上返回值，且函数调用不是一个列表表达式的最后一个元素，那么函数调用只会产生一个返回值,也就是第一个返回值。 123456789local function init() -- init 函数 返回两个值 1 和 "lua" return 1, "lua"endlocal x, y, z = init(), 2 -- init 函数的位置不在最后，此时只返回 1print(x, y, z) --&gt;output 1 2 nillocal a, b, c = 2, init() -- init 函数的位置在最后，此时返回 1 和 "lua"print(a, b, c) --&gt;output 2 1 lua 函数调用的实参列表也是一个列表表达式。考虑下面的例子： 123456local function init() return 1, "lua"endprint(init(), 2) --&gt;output 1 2print(2, init()) --&gt;output 2 1 lua 如果你确保只取函数返回值的第一个值，可以使用括号运算符，例如 123456local function init() return 1, "lua"endprint((init()), 2) --&gt;output 1 2print(2, (init())) --&gt;output 2 1 值得一提的是，如果实参列表中某个函数会返回多个值，同时调用者又没有显式地使用括号运算符来筛选和过滤，则这样的表达式是不能被 LuaJIT 2 所 JIT 编译的，而只能被解释执行。 全动态函数调用调用回调函数，并把一个数组参数作为回调函数的参数。 12local args = &#123;...&#125; or &#123;&#125;method_name(unpack(args, 1, table.maxn(args))) 使用场景如果你的实参 table 中确定没有 nil 空洞，则可以简化为 1method_name(unpack(args)) 你要调用的函数参数是未知的； 函数的实际参数的类型和数目也都是未知的。 12345add_task(end_time, callback, params)if os.time() &gt;= endTime then callback(unpack(params, 1, table.maxn(params)))end 值得一提的是，unpack 内建函数还不能为 LuaJIT 所 JIT 编译，因此这种用法总是会被解释执行。对性能敏感的代码路径应避免这种用法。 小试牛刀123456789101112131415local function run(x, y) print('run', x, y)endlocal function attack(targetId) print('targetId', targetId)endlocal function do_action(method, ...) local args = &#123;...&#125; or &#123;&#125; method(unpack(args, 1, table.maxn(args)))enddo_action(run, 1, 2) -- output: run 1 2do_action(attack, 1111) -- output: targetId 1111 来源https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/class.html]]></content>
      <categories>
        <category>Lua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6-箭头函数]]></title>
    <url>%2Fes6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ES6 允许使用箭头（=&gt;）来定义函数 语法 具有一个参数的简单函数 12345var f = a =&gt; a;//相当于var f = function(a)&#123; return a;&#125; 没有参数或者参数为多个，用() 1234//没有参数var f = () =&gt; console.log('没有参数');//多个参数var f = (a,b,c) =&gt; console.log(a+b+c); 相当于123var f = function()&#123;console.log('没有参数');&#125;var f = function(a,b,c)&#123;console.log(a+b+c);&#125; 如果箭头函数代码块多于一条语句，用{}括起来 1234var f = (a,b,c) =&gt; &#123; let d = a + b + c ; console.log(c);&#125; 如果返回为对象时，对象外面要用()括起来，因为大括号会被解释成代码块 123456789var f = a =&gt; (&#123;id:a,name:'wekbong'&#125;);//var f = a =&gt; &#123; //something return(&#123; id:a, name:'webkong' &#125;)&#125;; 直接作为事件的handler 123document.addEventLister('click',event=&gt;&#123; console.log(event) &#125;); 箭头函数可嵌套,箭头函数内部可以使用箭头函数 1234567891011121314let insert = (value) =&gt; (&#123;into:(array)&#125;) =&gt;(&#123;after:(afterValue)&#125;) =&gt; &#123; array.splice(array.indexOf(afterValue)) + 1,0,value); return array;&#125;&#125;)&#125;);//相当于function insert(value) &#123; return &#123;into: function (array) &#123; return &#123;after: function (afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125;&#125;; &#125;&#125;;&#125; 注意点箭头函数的几个使用注意点 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 不可以使用yield命令，因此箭头函数不能用作Generator函数。 第一点尤其值得注意。this 对象的志向是可变的，但是在箭头函数中它是固定的。123456789function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;); 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。 123456789101112var handler = &#123; id: '123456', init: function() &#123; document.addEventListener('click', event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125;; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReviewBoard常用命令]]></title>
    <url>%2Freviewboard%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[作为码农，review 代码是每天必须要做的。相互 review 代码，是找出 bug,学习进步的好方法。Code review doesn’t have to be so hard – ReviewBoard 本次只是介绍 RBT（RevieBoard 的客户端命令行工具）使用，服务器安装请自行扒官网 依赖git, python 下载https://www.reviewboard.org/downloads/rbtools/ 安装完成启动命令行工具 12➜ rbtTest git:(master) rbt -vRBTools 0.8 alpha 0 (dev) 说明安装成功了 使用1.进入到项目目录执行 setup-repo ,创建 .reviewboardrc文件rbt setup-repo 提示输入 reviewBoard server 的地址，根据你的服务器地址输入 提示 是否使用当前的 Git 库 输入 yes 提示 按照如下创建 .reviewboardrc 文件么 输入 yes 1234REVIEWBOARD_URL = "server"REPOSITORY = "rbtTest"BRANCH = "master"LAND_DEST_BRANCH = "master" 2.登录 rbt login 3.提交审核 123//所有的post审核都是在 git commit 之后的//第一次提交rbt post 输出 1234Review request #1052 posted.http://server/r/1052/http://server/r/1052/diff/ 证明 post 提交成功，可以去控制台设置 review 的人和组，然后 publish 就能让别人看到了 123456789//第二次修改针对第一次提交`rbt post -r 1052`输出Review request #1052 posted.http://server:8083/r/1052/http://server:8083/r/1052/diff/ 4.跟踪状态 rbt status 5.关闭审核 rbt close --close-type=discarded 1052 6.退出 rbt logout 7.帮助 rbt help]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ReviewBoard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript函数]]></title>
    <url>%2Ftypescript%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数介绍函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义 行为的地方。 TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。 函数和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。 通过下面的例子可以迅速回想起这两种JavaScript中的函数： 1234567// Named function 命名函数function add(x, y) &#123; return x + y;&#125;// Anonymous function 匿名函数let myAdd = function(x, y) &#123; return x + y; &#125;; 在JavaScript里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习JavaScript和TypeScript会很有帮助。12345let z = 100;function addToZ(x, y) &#123; return x + y + z;&#125; 函数类型为函数定义类型让我们为上面那个函数添加类型： 12345function add(x: number, y: number): number &#123; return x + y;&#125;let myAdd = function(x: number, y: number): number &#123; return x+y; &#125;; 我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。 书写完整函数类型现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。12let myAdd: (x:number, y:number)=&gt;number = function(x: number, y: number): number &#123; return x+y; &#125;; 函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 我们也可以这么写：12let myAdd: (baseValue:number, increment:number) =&gt; number = function(x: number, y: number): number &#123; return x + y; &#125;; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。 第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用( =&gt; )符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void而不能留空。 函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。 推断类型尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型：123456// myAdd has the full function typelet myAdd = function(x: number, y: number): number &#123; return x + y; &#125;;// The parameters `x` and `y` have the type numberlet myAdd: (baseValue:number, increment:number) =&gt; number = function(x, y) &#123; return x + y; &#125;; 这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。 可选参数和默认参数TypeScript里的每个函数参数都是必须的。 这不是指不能传递 null或undefined作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。1234567function buildName(firstName: string, lastName: string) &#123; return firstName + " " + lastName;&#125;let result1 = buildName("Bob"); // error, too few parameterslet result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result3 = buildName("Bob", "Adams"); // ah, just right JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用 ?实现可选参数的功能。 比如，我们想让last name是可选的： 12345678910function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + " " + lastName; else return firstName;&#125;let result1 = buildName("Bob"); // works correctly nowlet result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result3 = buildName("Bob", "Adams"); // ah, just right 可选参数必须跟在必须参数后面。 如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。 在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是undefined时。 它们叫做有默认初始化值的参数。 让我们修改上例，把last name的默认值设置为”Smith”。 12345678function buildName(firstName: string, lastName = "Smith") &#123; return firstName + " " + lastName;&#125;let result1 = buildName("Bob"); // works correctly now, returns "Bob Smith"let result2 = buildName("Bob", undefined); // still works, also returns "Bob Smith"let result3 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result4 = buildName("Bob", "Adams"); // ah, just right 在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型。123function buildName(firstName: string, lastName?: string) &#123; // ...&#125; 和123function buildName(firstName: string, lastName = "Smith") &#123; // ...&#125; 共享同样的类型(firstName: string, lastName?: string) =&gt; string。 默认参数的默认值消失了，只保留了它是一个可选参数的信息。 与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined值来获得默认值。 例如，我们重写最后一个例子，让 firstName是带默认值的参数：12345678function buildName(firstName = "Will", lastName: string) &#123; return firstName + " " + lastName;&#125;let result1 = buildName("Bob"); // error, too few parameterslet result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result3 = buildName("Bob", "Adams"); // okay and returns "Bob Adams"let result4 = buildName(undefined, "Adams"); // okay and returns "Will Adams" 剩余参数必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 arguments来访问所有传入的参数。 在TypeScript里，你可以把所有参数收集到一个变量里： 12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + " " + restOfName.join(" ");&#125;let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie"); 剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ ...）后面给定的名字，你可以在函数体内使用这个数组。 这个省略号也会在带有剩余参数的函数类型定义上使用到：12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + " " + restOfName.join(" ");&#125;let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName; this学习使用JavaScript里·就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清 this工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了 this的地方。 如果你想了解JavaScript里的 this是如何工作的，那么首先阅读Yehuda Katz写的Understanding JavaScript Function Invocation and “this”。 Yehuda的文章详细的阐述了 this的内部工作原理，因此我们这里只做简单介绍。 this和箭头函数JavaScript里，this的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。下面看一个例子：1234567891011121314151617let deck = &#123; suits: ["hearts", "spades", "clubs", "diamonds"], cards: Array(52), createCardPicker: function() &#123; return function() &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert("card: " + pickedCard.card + " of " + pickedCard.suit); 可以看到createCardPicker是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为 createCardPicker返回的函数里的this被设置成了window而不是deck对象。 因为我们只是独立的调用了 cardPicker()。 顶级的非方法式调用会将 this视为window。 （注意：在严格模式下， this为undefined而不是window）。 为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的 this值，而不是调用时的值： 我们把函数表达式变为使用lambda表达式（ () =&gt; {} ）。 这样就会在函数创建的时候就指定了‘this’值，而不是在函数调用的时候。 123456789101112131415161718let deck = &#123; suits: ["hearts", "spades", "clubs", "diamonds"], cards: Array(52), createCardPicker: function() &#123; // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert("card: " + pickedCard.card + " of " + pickedCard.suit); 更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了--noImplicitThis标记。 它会指出 this.suits[pickedSuit]里的this的类型为any。 this参数不幸的是，this.suits[pickedSuit]的类型依旧为any。 这是因为 this来自对象字面量里的函数表达式。 修改的方法是，提供一个显示的 this参数。 this参数是个假的参数，它出现在参数列表的最前面： 123function f(this: void) &#123; // make sure `this` is unusable in this standalone function&#125; 让我们往例子里添加一些接口，Card 和 Deck，让类型重用能够变得清晰简单些： 123456789101112131415161718192021222324252627interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: ["hearts", "spades", "clubs", "diamonds"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert("card: " + pickedCard.card + " of " + pickedCard.suit); 现在TypeScript知道createCardPicker期望在某个Deck对象上调用。 也就是说 this是Deck类型的，而非any，因此--noImplicitThis不会报错了。 this参数在回调函数里你可以也看到过在回调函数里的this报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用， this将为undefined。 稍做改动，你就可以通过 this参数来避免错误。 首先，库函数的作者要指定 this的类型： 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void means that addClickListener expects onclick to be a function that does not require a this type. Second, annotate your calling code with this: 123456789class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used this here. using this callback would crash at runtime this.info = e.message; &#125;;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // error! 指定了this类型后，你显示声明onClickBad必须在Handler的实例上调用。 然后TypeScript会检测到 addClickListener要求函数带有this: void。 改变 this类型来修复这个错误： 123456789class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can't use this here because it's of type void! console.log('clicked!'); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); 因为onClickGood指定了this类型为void，因此传递addClickListener是合法的。 当然了，这也意味着不能使用 this.info. 如果你两者都想要，你不得不使用箭头函数了： 1234class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message &#125;&#125; 这是可行的因为箭头函数不会捕获this，所以你总是可以把它们传给期望this: void的函数。 缺点是每个 Handler对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到 Handler的原型链上。 它们在不同 Handler对象间是共享的。 重载JavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。 12345678910111213141516171819202122let suits = ["hearts", "spades", "clubs", "diamonds"];function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == "object") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == "number") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: "diamonds", card: 2 &#125;, &#123; suit: "spades", card: 10 &#125;, &#123; suit: "hearts", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);let pickedCard2 = pickCard(15);alert("card: " + pickedCard2.card + " of " + pickedCard2.suit); pickCard方法根据传入参数的不同会返回两种不同的类型。 如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。 如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。 方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 pickCard函数。 123456789101112131415161718192021222324let suits = ["hearts", "spades", "clubs", "diamonds"];function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123;suit: string; card: number; &#125;;function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == "object") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == "number") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: "diamonds", card: 2 &#125;, &#123; suit: "spades", card: 10 &#125;, &#123; suit: "hearts", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);let pickedCard2 = pickCard(15);alert("card: " + pickedCard2.card + " of " + pickedCard2.suit); 这样改变后，重载的pickCard函数在调用的时候会进行正确的类型检查。 为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。 注意，function pickCard(x): any并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard会产生错误。 参考TypeScript中文网 阮一峰老师–ECMAScript 6 入门]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript接口]]></title>
    <url>%2Ftypescript%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口介绍TypeScript的核心原则之一是对值所具有的shape进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 接口初探下面通过一个简单示例来观察接口是如何工作的：123456function printLabel(labelledObj: &#123; label: string &#125;) &#123; console.log(labelledObj.label);&#125;let myObj = &#123; size: 10, label: "Size 10 Object" &#125;;printLabel(myObj); 类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为·的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。 下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：12345678910interface LabelledValue &#123; label: string;&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: "Size 10 Object"&#125;;printLabel(myObj); LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。 还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。 可选属性接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。 下面是应用了“option bags”的例子： 1234567891011121314151617interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123; let newSquare = &#123;color: "white", area: 100&#125;; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123;color: "black"&#125;); 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示： 只读属性一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性: 1234interface Point &#123; readonly x: number; readonly y: number;&#125; 你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。12let p1: Point = &#123; x: 10, y: 20 &#125;;p1.x = 5; // error! TypeScript具有ReadonlyArray&lt;T&gt;类型，它与Array&lt;T&gt;相似，只是把怕有可变方法去掉了，因此可以确保数组创建后再也不能被修改： 123456let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error! 上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写： a = ro as number[]; readonly vs const最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。 额外的属性检查我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。 然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说：12345678910interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let mySquare = createSquare(&#123; colour: "red", width: 100 &#125;); 注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。 你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。 然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 12// error: 'colour' not expected in type 'SquareConfig'let mySquare = createSquare(&#123; colour: "red", width: 100 &#125;); 绕开这些检查非常简单。 最简便的方法是使用类型断言： 1let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig); 然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它： 12345interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; 我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。 还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。12let squareOptions = &#123; colour: "red", width: 100 &#125;;let mySquare = createSquare(squareOptions); 要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如选择包，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。 函数类型接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 123interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。 12345678910let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); if (result == -1) &#123; return false; &#125; else &#123; return true; &#125;&#125; 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，Typescript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。12345678910let mySearch: SearchFunc;mySearch = function(src, sub) &#123; let result = src.search(sub); if (result == -1) &#123; return false; &#125; else &#123; return true; &#125;&#125; 可索引的类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[&quot;daniel&quot;]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子： 12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = ["Bob", "Fred"];let myStr: string = myArray[0]; 上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。 共有支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。 123456789101112class Animal &#123; name: string;&#125;class Dog extends Animal &#123; breed: string;&#125;// Error: indexing with a 'string' will sometimes get you a Dog!interface NotOkay &#123; [x: number]: Animal; [x: string]: Dog;&#125; 字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[&quot;property&quot;]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示： 12345interface NumberDictionary &#123; [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型不是索引类型的子类型&#125; 最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：12345interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = ["Alice", "Bob"];myArray[2] = "Mallory"; // error! 你不能设置myArray[2]，因为索引签名是只读的。 类类型实现接口与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。 12345678interface ClockInterface &#123; currentTime: Date;&#125;class Clock implements ClockInterface &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样： 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 类静态部分与实例部分的区别当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误： 12345678interface ClockConstructor &#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。 因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript变量声明]]></title>
    <url>%2Ftypescript%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[变量声明简述let和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。 因为TypeScript是JavaScript的超集，所以它本身就支持let和const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 var。 如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 var声明的怪异之处了如指掌，那么你可以轻松地略过这节。 var 声明一直以来我们都是通过var关键字定义JavaScript变量。 var a = 10; 大家都能理解，这里定义了一个名为a值为10的变量。 我们也可以在函数内部定义变量： 12345function f() &#123; var message = "Hello, world!"; return message;&#125; 并且我们也可以在其它函数内部访问相同的变量。 12345678910function f() &#123; var a = 10; return function g() &#123; var b = a + 1; return b; &#125;&#125;var g = f();g(); // returns 11; 上面的例子里，g可以获取到f函数里定义的a变量。 每当 g被调用时，它都可以访问到f里的a变量。 即使当 g在f已经执行完后才被调用，它仍然可以访问及修改a。 123456789101112131415function f() &#123; var a = 1; a = 2; var b = g(); a = 3; return b; function g() &#123; return a; &#125;&#125;f(); // returns 2 作用域规则对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子： 12345678910function f(shouldInitialize: boolean) &#123; if (shouldInitialize) &#123; var x = 10; &#125; return x;&#125;f(true); // returns '10'f(false); // returns 'undefined' 有些读者可能要多看几遍这个例子。 变量 x是定义在if语句里面，但是我们却可以在语句的外面访问它。 这是因为 var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为 var作用域或函数作用域。 函数参数也使用函数作用域。 这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：1234567891011function sumMatrix(matrix: number[][]) &#123; var sum = 0; for (var i = 0; i &lt; matrix.length; i++) &#123; var currentRow = matrix[i]; for (var i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i]; &#125; &#125; return sum;&#125; 这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。 变量获取怪异之处快速的猜一下下面的代码会返回什么：123for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123;console.log(i); &#125;, 100 * i);&#125; 介绍一下，setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。 好吧，看一下结果： 10101010101010101010很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样： 0123456789还记得我们上面讲的变量获取吗？ 每当g被调用时，它都可以访问到f里的a变量。让我们花点时间考虑在这个上下文里的情况。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为10。 所以当函数被调用的时候，它会打印出 10！ 一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值：1234567for (var i = 0; i &lt; 10; i++) &#123; // capture the current state of 'i' // by invoking a function with its current value (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100 * i); &#125;)(i);&#125; 这种奇怪的形式我们已经司空见惯了。 参数 i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。 let 声明现在你已经知道了var存在一些问题，这恰好说明了为什么用let语句来声明变量。 除了名字不同外， let与var的写法一致。 let hello = &quot;Hello!&quot;;主要的区别不在语法上，而是语义，我们接下来会深入研究。 块作用域当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。123456789101112function f(input: boolean) &#123; let a = 100; if (input) &#123; // Still okay to reference 'a' let b = a + 1; return b; &#125; // Error: 'b' doesn't exist here return b;&#125; 这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。 在catch语句里声明的变量也具有同样的作用域规则。123456789try &#123; throw "oh no!";&#125;catch (e) &#123; console.log("Oh well.");&#125;// Error: 'e' doesn't exist hereconsole.log(e); 拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 时间死区。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。12a++; // illegal to use 'a' before it's declared;let a; 注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。12345678910function foo() &#123; // okay to capture 'a' return a;&#125;// 不能在'a'被声明前调用'foo'// 运行时应该抛出错误foo();let a; 关于时间死区的更多信息，查看这里Mozilla Developer Network. 重定义及屏蔽我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。12345678function f(x) &#123; var x; var x; if (true) &#123; var x; &#125;&#125; 在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是， let声明就不会这么宽松了。12let x = 10;let x = 20; // 错误，不能在1个作用域里多次声明`x` 并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。12345678function f(x) &#123; let x = 100; // error: interferes with parameter declaration&#125;function g() &#123; let x = 100; var x = 100; // error: can't have both declarations of 'x'&#125; 并不是说块级作用域变量不能在函数作用域内声明。 而是块级作用域变量需要在不用的块里声明。1234567891011function f(condition, x) &#123; if (condition) &#123; let x = 100; return x; &#125; return x;&#125;f(false, 0); // returns 0f(true, 0); // returns 100 在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。1234567891011function sumMatrix(matrix: number[][]) &#123; let sum = 0; for (let i = 0; i &lt; matrix.length; i++) &#123; var currentRow = matrix[i]; for (let i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i]; &#125; &#125; return sum;&#125; 这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。 通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。 块级作用域变量的获取在我们最初谈及获取用var声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。123456789101112function theCityThatAlwaysSleeps() &#123; let getCity; if (true) &#123; let city = "Seattle"; getCity = function() &#123; return city; &#125; &#125; return getCity();&#125; 因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。 回想一下前面setTimeout的例子，我们最后需要使用立即执行的函数表达式来获取每次for循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。 当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。123for (let i = 0; i &lt; 10 ; i++) &#123; setTimeout(function() &#123;console.log(i); &#125;, 100 * i);&#125; 会输出与预料一致的结果： 0123456789 const 声明const 声明是声明变量的另一种方式。 const numLivesForCat = 9;它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。 这很好理解，它们引用的值是不可变的。1234567891011121314151617const numLivesForCat = 9;const kitty = &#123; name: "Aurora", numLives: numLivesForCat,&#125;// Errorkitty = &#123; name: "Danielle", numLives: numLivesForCat&#125;;// all "okay"kitty.name = "Rory";kitty.name = "Kitty";kitty.name = "Cat";kitty.numLives--; 除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 接口一章有详细说明。 let vs. const现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。 使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 const也可以让我们更容易的推测数据的流动。 另一方面，用户很喜欢let的简洁性。 这个手册大部分地方都使用了 let。 跟据你的自己判断，如果合适的话，与团队成员商议一下。 Fortunately, TypeScript allows you to specify that members of an object are readonly. The chapter on Interfaces has the details. 解构Another TypeScript已经可以解析其它 ECMAScript 2015 特性了。 完整列表请参见 the article on the Mozilla Developer Network。 本章，我们将给出一个简短的概述。 解构数组最简单的解构莫过于数组的解构赋值了：1234let input = [1, 2];let [first, second] = input;console.log(first); // outputs 1console.log(second); // outputs 2 这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：12first = input[0];second = input[1]; 解构作用于已声明的变量会更好：12// swap variables[first, second] = [second, first]; 作用于函数参数：12345function f([first, second]: [number, number]) &#123; console.log(first); console.log(second);&#125;f(input); 你可以使用...name语法创建一个剩余变量列表：123let [first, ...rest] = [1, 2, 3, 4];console.log(first); // outputs 1console.log(rest); // outputs [ 2, 3, 4 ] 当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：12let [first] = [1, 2, 3, 4];console.log(first); // outputs 1 或其它元素：1let [, second, , fourth] = [1, 2, 3, 4]; 对象解构你也可以解构对象：123456let o = &#123; a: "foo", b: 12, c: "bar"&#125;let &#123;a, b&#125; = o; 这通过 o.aand o.b创建了 a和b 。 注意，如果你不需要 c 你可以忽略它。 就像数组解构，你可以用没有声明的赋值： ({a, b} = {a: &quot;baz&quot;, b: 101});注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。 属性重命名你也可以给属性以不同的名字： let {a: newName1, b: newName2} = o;这里的语法开始变得混乱。 你可以将 a: newName1 读做 “a 作为 newName1”。 方向是从左到右，好像你写成了以下样子： let newName1 = o.a;let newName2 = o.b;令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。 let {a, b}: {a: string, b: number} = o; 默认值默认值可以让你在属性为 undefined 时使用缺省值：123function keepWholeObject(wholeObject: &#123;a: string, b?: number&#125;) &#123; let &#123;a, b = 1001&#125; = wholeObject;&#125; 现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。 函数声明解构也能用于函数声明。 看以下简单的情况：1234type C = &#123;a: string, b?: number&#125;function f(&#123;a, b&#125;: C): void &#123; // ...&#125; 但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要知道在设置默认值之前设置其类型。1234function f(&#123;a, b&#125; = &#123;a: "", b: 0&#125;): void &#123; // ...&#125;f(); // ok, default to &#123;a: "", b: 0&#125; 其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：123456function f(&#123;a, b = 0&#125; = &#123;a: ""&#125;): void &#123; // ...&#125;f(&#123;a: "yes"&#125;) // ok, default b = 0f() // ok, default to &#123;a: ""&#125;, which then defaults b = 0f(&#123;&#125;) // error, 'a' is required if you supply an argument 要小心使用解构。 从前面的例子可以看出，就算是最简单的解构也会有很多问题。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>变量声明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript基础类型]]></title>
    <url>%2Ftypescript%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[TypeScript基础类型TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 布尔值最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。 123let isDone: boolean = false;//let，ES6新增命令，用来声明变量。//它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 数字和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，Typescript还支持ECMAScript 2015中引入的二进制和八进制字面量。 1234let decLiteral: number = 6; //十进制let hexLiteral: number = 0xf00d; //十六进制 0x开头let binaryLiteral: number = 0b1010; // 二进制 0b开头let octalLiteral: number = 0o744; // 八进制 0o开头 字符串JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（&quot;）或单引号（&#39;）表示字符串。 12let name:string = 'webkong';name = "wangs"; 你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（`），并且以${ expr }这种形式嵌入表达式 123let name: string = `Gene`;let age: number = 37;let sentence: string = `hello, my name is $&#123;name&#125;. I'll be $&#123;age + 1&#125; years old next month.`; 这与下面定义sentence的方式效果相同： 1let sentence: string = "Hello, my name is " + name + ".\n\n" + "I'll be " + (age + 1) + "years old next month."; 数组TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组： 12let list: number[] = [1,2,3];let liststr: string[] = ['1','2','3']; 第二种方式是使用数组泛型，Array&lt;元素类型&gt;： 1let list: Array&lt;number&gt; = [1,2,3]; 元组 Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。 123456//声明一个元组let x : [string, number];x = ['hello',10];//不正确的赋值x = [10,'hello']; 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个越界的元素，会使用联合类型替代： 12345678x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型//联合类型 string | number 类似这种或者是string或者是number类型// 联合类型表示一个值可以是几种类型之一。 我们用竖线（ |）分隔每个类型，所以number | string | boolean表示一个值可以是number，string，或boolean。 枚举enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。12enum Color &#123;Red, Green, Blue&#125;;let c: Color = Color.Green; 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：12enum Color &#123;Red = 1, Green, Blue&#125;;let c: Color = Color.Green; 或者，全部都采用手动赋值：12enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;;let c: Color = Color.Green; 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：1234enum Color &#123;Red = 1, Green, Blue&#125;;let colorName: string = Color[2];alert(colorName); 任意值有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：123let notSure: any = 4;notSure = "maybe a string instead";notSure = false; // okay, definitely a boolean 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 – 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：1234567let notSure: any = 4;notSure.ifItExists(); // okay, ifItExists might exist at runtimenotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'. 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： 123let list: any[] = [1, true, "free"];list[1] = 100; 空值某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： 123function warnUser(): void &#123; alert("This is my warning message");&#125; 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null： 1let unusable: void = undefined; Null 和 UndefinedTypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大： 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。 然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 注意：我们鼓励尽可能地使用--strictNullChecks。 类型断言有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 其一是“尖括号” &lt;&gt;语法： 123let someValue: any = "this is a string";let strLength: number = (&lt;string&gt;someValue).length; 另一个为as语法： 123let someValue: any = "this is a string";let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。 参考地址TypeScript中文网 阮一峰老师–ECMAScript 6 入门]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[V8引擎的垃圾回收机制]]></title>
    <url>%2Fv8%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[V8的垃圾回收 基于分代式垃圾回收机制 因为在实际的应用场景中，对象的生存周期长短不一样。不同的算法只能针对特定的情况具有最好的效果。 为此，统计学在垃圾回收算法的发展中产生了较大的作用，现代的垃圾回收算法中按对象的存活时间将内存的垃圾进行不同的分代，然后对不同的分代的内存实施更高效的算法。 V8的内存分代：主要分为新生代和老生代 Scavenge算法，新生代的对象主要通过Scavenge算法进行垃圾回收，再具体实现中，采用Cheney算法。 Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为semispace。在两个semispace中一个处于使用中，一个处于闲置状态。处于使用中的称之为From空间，处于闲置状态的称之为To空间。当开始垃圾回收时，检查From空间中存活的对象，这些对象被复制到To空间，而非存活对象占用的空间被释放掉。完成复制后，From和To空间角色发生兑换。 当一个对象经过多次复制依然存活，它将会被认为是生命周期较长的对象，这种较长周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代移动到老生代中的过程称之为晋升。 对象晋升的条件主要有两个： 1. 对象是否经历过Scavenge回收 2.To空间的内存占用比超过限制。 Mark-Sweep &amp; Mark-Compact Mark-Sweep 是标记清除的意思。 Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。 Mark-Sweep存在一个最大的问题就是，在进行一次标记清除回收之后，内存空间会出现不连续的状态。 为了解决内存碎片问题Mark-Compact被提出来。Mark-Compact是标记整理的意思。是在Mark-Sweep基础上演变出来的。它们的差别在于，在整理过程中，MC将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。 V8中两种算法是结合使用的。 Incremental Marking 为了避免出现JavaScript应用逻辑与垃圾回收器看起来不一样，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再回复执行应用逻辑，这种行为被称为全停顿（stop-the-word）. 为了降低全堆垃圾回收带来的停顿时间，V8从标记阶段入手，将原本一口气停顿完成的动作改为增量标记，每做完一个“步进”就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成。 V8经过增量标记之后，垃圾回收的最大停顿时间可以减少到原来的1/6 后续引入了延迟清理（lazy sweeping）增量整理（incremental compaction）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>V8</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理解决ajax跨域问题]]></title>
    <url>%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3ajax%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[跨域问题，是前端同学遇到和服务器交换数据最常见的问题。下面就说一下如何解决跨域问题。个人认为，通过 nginx 反向代理解决跨域是最为简单和方便，并且针对：测试过程为跨域，线上为同域的场景 1. 什么是跨域跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 javascript 施加的安全限制。 所谓同源是指，域名，协议，端口相同。浏览器执行 javascript 脚本时，会检查这个脚本属于那个页面，如果不是同源页面，就不会被执行。同源策略的目的，是防止黑客做一些做奸犯科的勾当。比如说，如果一个银行的一个应用允许用户上传网页，如果没有同源策略，黑客可以编写一个登陆表单提交到自己的服务器上，得到一个看上去相当高大上的页面。黑客把这个页面通过邮件等发给用户，用户误认为这是某银行的主网页进行登陆，就会泄露自己的用户数据。而因为浏览器的同源策略，黑客无法收到表单数据。 2. 常见的解决跨域的方法 使用 iFrame 访问另一个域。 然后再从另一个页面读取 iFrame 的内容。jquery 等有一些封装。 jsonp。需要服务器支持。使用 script src 动态得到一段 javascript 代码。是回调页面上的 js 函数，参数是一个 json 对象。jquery 有封装。 设置 http 头，Access-Control-Allow-Origin： // 或者一个具体的 origin 服务器代理。将某个请求代理到服务器地址 3. nginx 反向代理以上的方法，都会造成测试代码和正式代码的不一致，导致重复和多余的工作量，而且测试也不方便。例如：用 iframe，已经过时的使用， jsonp 需要服务其支持，将返回封装在 CALLBACK 里面， http 修改 Access 需要服务器支持修改。那么： 用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。 我们只需要配置 nginx，在一个服务器上配置多个前缀来转发 http/https 请求到多个真实的服务器即可。这样，这个服务器上所有 url 都是相同的域名、协议和端口。因此，对于浏览器来说，这些 url 都是同源的，没有跨域限制。而实际上，这些 url 实际上由物理服务器提供服务。这些服务器内的 javascript 可以跨域调用所有这些服务器上的 url。 4. 配置过程打开 nginx.conf 的配置文件找到 server 项 123456789101112131415161718192021server &#123; listen 8080; #服务监听的端口 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /work/; #项目目录 index index.html index.htm; &#125; #反向代理开始 #拦截所有/ios/的请求并将以ws_开头的请求代理到 http://192.168.255.140:80/ location ^~/ios/&#123; rewrite ^ws* /$1 break; #代理的规则（正则表达式） include uwsgi_params; proxy_pass http://192.168.255.140:80/; #要代理到的url &#125;&#125; 5. 平滑重启1通过 nginx -s reload 来重启nginx 6. nginx 的正则表达式12345678910111213141516171819202122232425262728293031323334353637383940414243444546471、正则表达式匹配 ~ 为区分大小写的匹配。 ~* 不区分大小写的匹配（匹配firefox的正则同时匹配FireFox）。 !~ 不匹配的 !~* 不匹配的 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 &#123;n&#125; 重复n次 &#123;n,&#125; 重复n次或更多次 &#123;n,m&#125; 重复n到m次 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 &#123;n,m&#125;? 重复n到m次，但尽可能少重复 &#123;n,&#125;? 重复n次以上，但尽可能少重复 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?&lt;name&gt;exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读2、文件及目录匹配 -f和!-f用来判断是否存在文件 -d和!-d用来判断是否存在目录 -e和!-e用来判断是否存在文件或目录 -x和!-x用来判断文件是否可执行 例如： 123456location = /#匹配任何查询，因为所有请求都已 / 开头。但是正则表达式规则和长的块规则将被优先和查询匹配location ^~ /images/ &#123;# 匹配任何已/images/开头的任何查询并且停止搜索。任何正则表达式将不会被测试。location ~* .(gif|jpg|jpeg)$ &#123;# 匹配任何已.gif、.jpg 或 .jpeg 结尾的请求]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>反向代理</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包avalon2.0项目]]></title>
    <url>%2Fwebpack%E6%89%93%E5%8C%85avalon2-0%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[最近项目需要做一个小巧的web应用，所以用了avalon，并用webpack管理代码 安装过程就不在赘述，可以看webpack的安装 安装webpack 新建项目目录 123456789101112├── package.json # 项目配置├── index.html # 入口文件1├── index2.html # 入口文件2├── source # 资源目录│ ├── css/ # css资源│ ├── img/ # 图片资源├── src/ # 入口js│ ├── index.js│ ├── index2.js├── modules # js模块├── template # html模板文件├── webpack.config.js # webpack配置入口 使用 npm init 新建一个package.json来管理依赖 123456789101112131415161718192021222324252627282930313233343536373839//可以复制，然后执行 npm install&#123; "name": "", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [ "web", ], "author": "", "license": "ISC", "devDependencies": &#123; "autoprefixer": "^6.3.7", "autoprefixer-loader": "^3.2.0", "css-loader": "^0.23.1", "extract-text-webpack-plugin": "^1.0.1", "file-loader": "^0.8.5", "html-loader": "^0.4.3", "imports-loader": "^0.6.5", "less": "^2.7.1", "less-loader": "^2.2.3", "node-sass": "^3.8.0", "sass-loader": "^4.0.0", "style-loader": "^0.13.1", "text-loader": "0.0.1", "transfer-webpack-plugin": "^0.1.4", "url-loader": "^0.5.7", "webpack": "^1.13.1", "webpack-dev-server": "^1.14.1" &#125;, "dependencies": &#123; "avalon2": "^2.1.5", "jquery": "^3.1.0", "jquery.qrcode": "^1.0.3" &#125;&#125; 配置webpack 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//新建webpack.config.jsvar webpack = require("webpack");var path = require("path");var ExtractTextPlugin = require("extract-text-webpack-plugin"); //单独打包插件var TransferWebpackPlugin = require('transfer-webpack-plugin');//复制文件插件module.exports = &#123; devtool: false, entry: &#123; entry: "./src/entry.js",//入口1 entry2: "./src/entry2.js"//入口2 &#125;, output: &#123; path: __dirname + "/dist/", filename: "[name].js" &#125;, module: &#123; loaders: [&#123; test: /\.css$/, //loader: "style-loader!css-loader?modules" loader: ExtractTextPlugin.extract("style-loader", "css-loader") &#125;, &#123; test: /\.(jpg|png)$/, loader: "url?limit=8192" &#125;, &#123; test: /\.scss$/, //loader: "style!css!sass" loader: ExtractTextPlugin.extract('style', 'css!sass') &#125;,&#123; test: /\.less$/, loader: "style!css!less" &#125;,&#123; test: /\.html$/, loader: "html?attrs=img:src img:data-src" &#125;, &#123; test: /\.(woff|ttf|eot|woff2)$/, loader: "file-loader"&#125; ] &#125;, resolve: &#123; extension: ['', '.js', '.css','.html','.scss'], alias: &#123; avalon: ("avalon2"), //avalon: path.join(__dirname, "./node_modules/avalon2/dist/avalon.js") jquery: ("jquery"), &#125; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; //将jQuery设置成全局变量 $: "jquery", jQuery: "jquery", "window.jQuery": "jquery", "window.$": "jquery" &#125;), new ExtractTextPlugin("styles.css"), new TransferWebpackPlugin([ &#123;from: '',to:''&#125; ], path.resolve(__dirname,'')),//copy new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;)//压缩js ]&#125; 使用在index.html 引用 /dist/index.js 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;test avalon&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div ms-controller="avalonCtrl"&gt;&lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script src="./dist/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编写index.js,需要哪个就require进来 123456var avalon = require('avalon');avalon.define(&#123;$id: "avalonCtrl",name: "Hello world!"&#125;);$("&lt;div&gt;这是jquery生成的,看看avalon好使不&lt;/div&gt;").appendTo("body") 编写完成后，在终端进入到项目路径下，执行打包指令webapck 启动webpack-dev-server,访问http://localhost:8080/webpack-dev-server/index.html 现在已经成功打包了avalon 配置文件详解1234567891011121314151617181920212223module: &#123; loaders: [&#123; test: /\.css$/, //loader: "style-loader!css-loader?modules" loader: ExtractTextPlugin.extract("style-loader", "css-loader") &#125;, &#123; test: /\.(jpg|png)$/, loader: "url?limit=8192" &#125;, &#123; test: /\.scss$/, //loader: "style!css!sass" loader: ExtractTextPlugin.extract('style', 'css!sass') &#125;,&#123; test: /\.less$/, loader: "style!css!less" &#125;,&#123; test: /\.html$/, loader: "html?attrs=img:src img:data-src" &#125;, &#123; test: /\.(woff|ttf|eot|woff2)$/, loader: "file-loader"&#125; ]&#125;, 配置文件中的loader，用来将各种文件一起打包在一起，css,js,scss,html等文件打包到一起可以去官网查看具体的loader[http://webpack.github.io/docs/list-of-plugins.html](http://webpack.github.io/docs/list-of-p 可以查看webpack配置jQuery插件]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原创</tag>
        <tag>模块化</tag>
        <tag>webpack</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo 安装升级123npm install hexo -g #安装npm update hexo -g #升级hexo init #初始化 简写12345hexo n "我的博客" == hexo new "我的博客" #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 开启本地服务器12345678hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署12345两个命令的作用是相同的hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 发布草稿1hexo publish [layout] &lt;title&gt; 模版123456789hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo new [layout] &lt;title&gt;hexo new photo "My Gallery"hexo new "Hello World" --lang tw]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sass基本用法]]></title>
    <url>%2Fsass%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、什么是SASSSASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。本文总结了SASS的主要用法。我的目标是，有了这篇文章，日常的一般使用就不需要去看官方文档了。二、安装和使用2.1 安装SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先安装Ruby，然后再安装SASS。假定你已经安装好了Ruby，接着在命令行输入下面的命令：1 gem install sass 然后，就可以使用了。2.2 使用SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。） sass test.scss如果要将显示结果保存成文件，后面再跟一个.css文件名。 sass test.scss test.cssSASS提供四个编译风格的选项： 1.nested：嵌套缩进的css代码，它是默认值。2.expanded：没有缩进的、扩展的css代码。3.compact：简洁格式的css代码。4.compressed：压缩后的css代码。 生产环境当中，一般使用最后一个选项。 sass --style compressed test.sass test.css你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。1234 // watch a file sass --watch input.scss:output.css // watch a directory sass --watch app/sass:public/stylesheets SASS的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。三、基本用法3.1 变量SASS允许使用变量，所有变量以$开头。1234 $blue : #1875e7; div &#123; color : $blue; &#125; 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。1234 $side : left; .rounded &#123; border-#&#123;$side&#125;-radius: 5px; &#125; 3.2 计算功能SASS允许在代码中使用算式：12345 body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%; &#125; 3.3 嵌套SASS允许选择器嵌套。比如，下面的CSS代码：123 div h1 &#123; color : red; &#125; 可以写成：12345 div &#123; hi &#123; color:red; &#125; &#125; 属性也可以嵌套，比如border-color属性，可以写成：12345 p &#123; border: &#123; color: red; &#125; &#125; 注意，border后面必须加上冒号。在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成：123 a &#123; &amp;:hover &#123; color: #ffb3ff; &#125; &#125; 3.4 注释SASS共有两种注释风格。标准的CSS注释 /* comment */ ，会保留到编译后的文件。单行注释 // comment，只保留在SASS源文件中，编译后被省略。在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。123/*! 重要注释！ */ 四、代码的重用4.1 继承SASS允许一个选择器，继承另一个选择器。比如，现有class1：123 .class1 &#123; border: 1px solid #ddd; &#125; class2要继承class1，就要使用@extend命令：1234 .class2 &#123; @extend .class1; font-size:120%; &#125; 4.2 MixinMixin有点像C语言的宏（macro），是可以重用的代码块。使用@mixin命令，定义一个代码块。1234 @mixin left &#123; float: left; margin-left: 10px; &#125; 使用@include命令，调用这个mixin。123 div &#123; @include left; &#125; mixin的强大之处，在于可以指定参数和缺省值。1234 @mixin left($value: 10px) &#123; float: left; margin-right: $value; &#125; 使用的时候，根据需要加入参数：123 div &#123; @include left(20px); &#125; 下面是一个mixin的实例，用来生成浏览器前缀。12345 @mixin rounded($vert, $horz, $radius: 10px) &#123; border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; -moz-border-radius-#&#123;$vert&#125;#&#123;$horz&#125;: $radius; -webkit-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; &#125; 使用的时候，可以像下面这样调用：12 #navbar li &#123; @include rounded(top, left); &#125; #footer &#123; @include rounded(top, left, 5px); &#125; 4.3 颜色函数SASS提供了一些内置的颜色函数，以便生成系列颜色。1234 lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 4.4 插入文件@import命令，用来插入外部文件。 @import &quot;path/filename.scss&quot;;如果插入的是.css文件，则等同于css的import命令。 @import &quot;foo.css&quot;;五、高级用法5.1 条件语句@if可以用来判断：1234 p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; &#125; 配套的还有@else命令：12345 @if lightness($color) &gt; 30% &#123; background-color: #000; &#125; @else &#123; background-color: #fff; &#125; 5.2 循环语句SASS支持for循环：12345 @for $i from 1 to 10 &#123; .border-#&#123;$i&#125; &#123; border: #&#123;$i&#125;px solid blue; &#125; &#125; 也支持while循环：12345 $i: 6; @while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2; &#125; each命令，作用与for类似：12345 @each $member in a, b, c, d &#123; .#&#123;$member&#125; &#123; background-image: url("/image/#&#123;$member&#125;.jpg"); &#125; &#125; 5.3 自定义函数SASS允许用户编写自己的函数。123456 @function double($n) &#123; @return $n * 2; &#125; #sidebar &#123; width: double(5px); &#125; 原文]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的promise]]></title>
    <url>%2Fjquery%E7%9A%84promise%2F</url>
    <content type="text"><![CDATA[本文粗浅的讨论一下promise。仅一家之言，不能尽信之。在现在流行的单页面应用SPA构建中，难免会有AJAX异步请求数据进行视图的渲染。这时候就会遇到在页面渲染的时候，数据还没有请求过来的情况，就会导致页面缺失或者是页面渲染失败。或者是在某个特定返回之后才能执行某些methods。有人说，你可以把AJAX设置成同步，那就不得不科普一下了。 JavaScript语言的执行环境是“单线程”，所谓单线程，就是一次只能够执行一个任务，如果有多个任务的话就要排队，前面一个任务完成后才可以继续下一个任务。“单线程”的好处就是实现起来比较简单、操作容易；坏处就是容易造成阻塞，因为队列中如果有一个任务耗时比较长，那么后面的任务都无法快速执行，或导致页面卡在某个状态上，体验很差。 JavaScript通过 异步模式，来解决这个问题，一般有如下方式： 回调函数 callbacks 事件监听 addEventListener Promise对象 关于回调函数，如下代码：12345678910111213141516171819$.ajax(&#123; url:"test.json", type: "GET", data: &#123;username:$("#username").val()&#125;, dataType: "json", beforSend:function()&#123; // 禁用按钮防止重复提交 $("#submit").attr(&#123; disabled: "disabled" &#125;); &#125;, complete:function(msg)&#123; //请求完成后调用的回调函数（请求成功或失败时均调用） &#125; , error:function(msg)&#123; //请求失败时被调用的函数 &#125; , Sucess:function(msg)&#123; //请求成功后调用的回调函数 &#125;&#125;); 当执行ajax请求时候，如果成功了，就执行回调函数sucess，如果失败就会调error，当我们处理的任务不是很多的时候，这种还是可以应付的，但是如果任务比较多的时候，当依赖回调的函数还要依赖其他的函数的时候就会出现依赖嵌套，使代码的维护性和可读性都变差，并且它们篡改了代码的流程，加重调试的负担。 监听器越多，对浏览器的消耗越大，导致响应速度，加载速度变慢等。 所以这时候就会用到promise 什么是PromisePromise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。 现在可以这么写 123456var promise = $.ajax(&#123; url: "/url"&#125;);promise.done(successFunction);promise.fail(errorFunction);promise.always(alwaysFunction); 从 jQuery 1.5 开始，$.ajax()返回的jqXHR对象 实现了 Promise接口, 使它拥有了 Promise 的所有属性，方法和行为。为了让回调函数的名字统一，便于在$.ajax()中使用。jqXHR也提供.error() .success()和.complete()方法。这些方法都带有一个参数，该参数是一个函数，此函数在 $.ajax()请求结束时被调用,并且这个函数接收的参数，与调用 $.ajax()函数时的参数是一致。这将允许你在一次请求时，对多个回调函数进行赋值，甚至允许你在请求已经完成后，对回调函数进行赋值(如果该请求已经完成，则回调函数会被立刻调用)。1jqXHR.done(function(data, textStatus, jqXHR) &#123;&#125;); 一个可供选择的 success 回调选项的构造函数，.done()方法取代了的过时的jqXHR.success()方法.1jqXHR.fail(function(jqXHR, textStatus, errorThrown) &#123;&#125;); 一种可供选择的 error 回调选项的构造函数，.fail()方法取代了的过时的.error()方法。1jqXHR.always(function(data|jqXHR, textStatus, jqXHR|errorThrown) &#123; &#125;); 一种可供选择的 complete 回调选项的构造函数，.always()方法取代了的过时的.complete()方法。 在响应一个成功的请求后，该函数的参数和.done()的参数是相同的：data, textStatus, 和 jqXHR 对象.对于失败的请求，参数和.fail()的参数是相同的：jqXHR 对象, textStatus, 和 errorThrown。请参阅deferred.always()的实现细节。 jqXHR.then(function(data, textStatus, jqXHR) {}, function(jqXHR, textStatus, errorThrown) {});包含了 .done() 和 .fail()方法的功能，（从 jQuery 1.8 开始）允许底层被操纵。 promise对象的一大好处，就是它允许你自由添加多个回调函数,可以用链式调用的方法，随时使用。 在任何时刻，Promise只能处于三种状态之一：未完成(unfulfilled)、已完成(resolved)和已失败(resolved)。promise默认的状态是unresolved，任何处于回调队列的函数都会被执行。假设，如果一个Ajax调用成功，$.resolved会被调用，同时promise的状态转为resolved，以及任何监听done的回调都会被执行；相反，则$.rejected会被调用，同时promise的状态转为rejected，以及任何监听fail的回调都会被执行。 在jQuery中，pomise对象类似功能的deferred对象 http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原创</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack配置（jQuery+jq插件）]]></title>
    <url>%2Fwebpack%E9%85%8D%E7%BD%AE%EF%BC%88jquery-jq%E6%8F%92%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[安装webpack过程略过，同学可自行查看上一篇文章. 1.在项目目录下新建文件webpack.config.js 1234567module.exports = &#123; entry: './src/app.js', output: &#123; path: './bin', filename: 'app.bundle.js' &#125; &#125;; 这个一个符合CommonJS风格的module 2.简单的配置之后就可以运行打包。1webpack webpack就会读取配置文件webpack.config.js，build并生成app.bundle.js 3.还可以依赖插件,通过loader加载不同格式的文件123456789101112131415161718192021222324252627282930const webpack = require('webpack');module.exports = &#123; entry: './src/app.js', output: &#123; path: './bin', filename: 'app.bundle.js', &#125;, module: &#123; loaders: [&#123; //加载器 test: /\.jsx?$/, exclude: /node_modules/, loader: 'babel', &#125;] &#125;, resolve: &#123; extension: ['', '.js', '.css'], alias: &#123;//设置别名 jquery: ("jquery"), qrcode: ("jquery.qrcode") &#125; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: "jquery", jQuery: "jquery", "window.jQuery": "jquery" &#125;) ]&#125; 4.使用jQuery和jQuery插件如上面的代码plugins：1234567lugins: [ //全局变量不用require new webpack.ProvidePlugin(&#123; $: "jquery", jQuery: "jquery", "window.jQuery": "jquery" &#125;)] 对于不支持CommonJS规范的模块，需要安装 imports-loader 123//app.jsrequire('imports?$=jquery!qrcode'); //引入 jQuery的二维码插件这样就可以成功引入jQuery和jQuery的插件。 config文件说明 entry配置要打包的文件的入口;可以配置多个入口文件，下面会有介绍。 resolve配置文件后缀名(extensions)，除了js，还有jsx、coffee等等。alias配置项，可以为常用模块配置改属性，可以节省编译的搜索时间。例如：123456resolve:&#123; extensions:['.js','.jsx'], alias:&#123; 'react':path.join(nodeModulesPath,'react/react.js') &#125;&#125; output配置输出文件的路径，文件名等。 module(loaders)配置要使用的loader。对文件进行一些相应的处理。比如babel-loader可以把es6的文件转换成es5。大部分的对文件的处理的功能都是通过loader实现的。loader就相当于gulp里的task。loader可以用来处理在入口文件中require的和其他方式引用进来的文件。loader一般是一个独立的node模块，要单独安装。 loader配置项：1234test: /\.(js|jsx)$/, //注意是正则表达式，不要加引号，匹配要处理的文件loader: 'eslint-loader', //要使用的loader，"-loader"可以省略include: [path.resolve(__dirname, "src/app")], //把要处理的目录包括进来exclude: [nodeModulesPath] //排除不处理的目录 目前已有的loader列表：https://webpack.github.io/docs/list-of-loaders.html 一个module的例子:1234567891011121314151617module: &#123; preLoaders: [ &#123; test: /\.(js|jsx)$/, loader: 'eslint-loader', include: [path.resolve(__dirname, "src/app")], exclude: [nodeModulesPath] &#125;, ], loaders: [ &#123; test: /\.(js|jsx)$/, //正则表达式匹配 .js 和 .jsx 文件 loader: 'babel-loader?optional=runtime&amp;stage=0',//对匹配的文件进行处理的loader exclude: [nodeModulesPath]//排除node module中的文件 &#125; ]&#125; plugins顾名思义，就是配置要使用的插件。plugin是比loader功能更强大的插件，能使用更多的wepack api。来看一个使用plugin的例子：123456789101112131415plugins: [ //压缩打包的文件 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; //supresses warnings, usually from module minification warnings: false &#125; &#125;), //允许错误不打断程序 new webpack.NoErrorsPlugin(), //把指定文件夹xia的文件复制到指定的目录 new TransferWebpackPlugin([ &#123;from: 'www'&#125; ], path.resolve(__dirname,"src")) ] 目前已有的plugins列表：http://webpack.github.io/docs/list-of-plugins.html webpack官方文档 可以暴露成全局变量的2个配置 ,引用国际友人的解释。来源 externalsProvidePlugin It’s both possible: You can include libraries with a &lt;script&gt; (i. e. to use a library from a CDN) or include them into the generated bundle. If you load it via &lt;script&gt; tag, you can use the externals option to allow to write require(…) in your modules. Example with library from CDN:1234567&lt;script src="https://code.jquery.com/jquery-git2.min.js"&gt;&lt;/script&gt;// the artifial module "jquery" exports the global var "jQuery"externals: &#123; jquery: "jQuery" &#125;// inside any modulevar $ = require("jquery"); Example with library included in bundle:12345678copy `jquery-git2.min.js` to your local filesystem// make "jquery" resolve to your local copy of the library// i. e. through the resolve.alias optionresolve: &#123; alias: &#123; jquery: "/path/to/jquery-git2.min.js" &#125; &#125;// inside any modulevar $ = require("jquery"); The ProvidePlugin can map modules to (free) variables. So you could define: “Every time I use the (free) variable xyz inside a module you (webpack) should set xyz to require(&quot;abc&quot;).” Example without ProvidePlugin:123// You need to require underscore before you can use itvar _ = require("underscore");_.size(...); Example with ProvidePlugin:12345678plugins: [ new webpack.ProvidePlugin(&#123; "_": "underscore" &#125;)]// If you use "_", underscore is automatically required_.size(...) Summary: Library from CDN: Use &lt;script&gt; tag and externals optionLibrary from filesystem: Include the library in the bundle. (Maybe modify resolve options to find the library)externals: Make global vars available as moduleProvidePlugin: Make modules available as free variables inside modules]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原创</tag>
        <tag>模块化</tag>
        <tag>webpack</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack的安装]]></title>
    <url>%2Fwebpack%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[前端不能少了模块化、压缩、打包等等的工具，就来用一下webpack。Mac OX 系统为例。 webpack官网 安装webpack 需要的依赖 node.js npm 执行命令1sudo npm install webpack -g 输入密码，安装完成之后，就在全局安装了webpack，并且webpack命令就可以使用了。 在项目中使用 123$ mkdir test$ cd test$ npm init 通过npm 初始化一个项目，生成一个package.json文件。 1npm install webpack --save-dev 就会在项目中添加webpack的依赖，也可以选择安装哪个版本 1$ npm install webpack@1.2.x --save-dev 后面会说到如何配置webpack，和如何添加jQuery和jQuery的插件。]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原创</tag>
        <tag>模块化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-字符串的扩展]]></title>
    <url>%2Fes6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[ES6字符的Unicode表示法JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。 12"\u0061"// "a" 但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。12345"\uD842\uDFB7"// "𠮷""\u20BB7"// " 7" 上面代码表示，如果直接在“\u”后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript会理解成“\u20BB+7”。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。 ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 1234567891011"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true 上面代码中，最后一个例子表明，大括号表示法与四字节的UTF-16编码是等价的。 有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。123456'\z' === 'z' // true'\172' === 'z' // true'\x7A' === 'z' // true'\u007A' === 'z' // true'\u&#123;7A&#125;' === 'z' // truecodePointAt() JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。123456var s = "𠮷";s.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 上面代码中，汉字“𠮷”的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。 ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。 123456var s = '𠮷a';s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.charCodeAt(2) // 97 codePointAt方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，codePointAt方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。 总之，codePointAt方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。 codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。 123var s = '𠮷a';s.codePointAt(0).toString(16) // "20bb7"s.charCodeAt(2).toString(16) // "61" 你可能注意到了，codePointAt方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是1，但是必须向charCodeAt方法传入2。解决这个问题的一个办法是使用for…of循环，因为它会正确识别32位的UTF-16字符。123456789101112131415var s = '𠮷a';for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16));&#125;// 20bb7// 61codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit("𠮷") // trueis32Bit("a") // falseString.fromCodePoint() ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。 12String.fromCharCode(0x20BB7)// "ஷ" 上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。 1234String.fromCodePoint(0x20BB7)// "𠮷"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'// true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 字符串的遍历器接口ES6为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历。123456for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// "f"// "o"// "o" 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。123456789101112var text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// " "// " "for (let i of text) &#123; console.log(i);&#125;// "𠮷" 上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for…of循环会正确识别出这一个字符。 at()ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。&#39;abc&#39;.charAt(0) // &quot;a&quot;&#39;𠮷&#39;.charAt(0) // &quot;\uD842&quot;上面代码中，charAt方法返回的是UTF-16编码的第一个字节，实际上是无法显示的。 目前，有一个提案，提出字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。‘abc’.at(0) // “a”‘𠮷’.at(0) // “𠮷”这个方法可以通过垫片库实现。 normalize()许多欧洲语言有语调符号和重音符合。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。 这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。123'\u01D1'==='\u004F\u030C' //false'\u01D1'.length // 1'\u004F\u030C'.length // 2 上面代码表示，JavaScript将合成字符视为两个字符，导致两种表示方法不相等。 ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 12'\u01D1'.normalize() === '\u004F\u030C'.normalize()// true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 12'\u004F\u030C'.normalize('NFC').length // 1'\u004F\u030C'.normalize('NFD').length // 2 上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。 includes(), startsWith(), endsWith()传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。12345678910111213var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true这三个方法都支持第二个参数，表示开始搜索的位置。var s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false&gt;上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat() repeat方法返回一个新字符串，表示将原字符串重复n次。12345678910111213141516171819202122'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'na'.repeat(0) // ""参数如果是小数，会被取整。'na'.repeat(2.9) // "nana"如果repeat的参数是负数或者Infinity，会报错。'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。'na'.repeat(-0.9) // ""参数NaN等同于0。'na'.repeat(NaN) // ""如果repeat的参数是字符串，则会先转换成数字。'na'.repeat('na') // ""'na'.repeat('3') // "nanana" padStart()，padEnd()ES7推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全。12345678910111213141516171819202122232425262728'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba'&gt;padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。1.如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx'2.如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。'abc'.padStart(10, '0123456789')// '0123456abc'3.如果省略第二个参数，则会用空格补全长度。'x'.padStart(4) // ' x''x'.padEnd(4) // 'x '4.padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456"另一个用途是提示字符串格式。'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串传统的JavaScript语言，输出模板通常是这样写的。123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量var name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。var greeting = `\`Yo\` World!`;如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`);上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim());模板字符串中嵌入变量，需要将变量名写在$&#123;&#125;之中。function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125;大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。var x = 1;var y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// "1 + 2 = 3"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// "1 + 4 = 5"var obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// 3模板字符串之中还能调用函数。function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。如果模板字符串中的变量没有声明，将报错。// 变量place没有声明var msg = `Hello, $&#123;place&#125;`;// 报错由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。`Hello $&#123;'World'&#125;`// "Hello World"模板字符串甚至还能嵌套。const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`;上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt;如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。// 写法一let str = 'return ' + '`Hello $&#123;name&#125;!`';let func = new Function('name', str);func('Jack') // "Hello Jack!"// 写法二let str = '(name) =&gt; `Hello $&#123;name&#125;!`';let func = eval.call(null, str);func('Jack') // "Hello Jack!"实例：模板编译下面，我们来看一个通过模板字符串，生成正式模板的实例。var template = `&lt;ul&gt; &lt;% for(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`;上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置JavaScript代码，使用&lt;%= ... %&gt;输出JavaScript表达式。怎么编译这个模板字符串呢？一种思路是将其转换为JavaScript表达式字符串。echo('&lt;ul&gt;');for(var i=0; i &lt; data.supplies.length; i++) &#123; echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');&#125;;echo('&lt;/ul&gt;');这个转换使用正则表达式就行了。var evalExpr = /&lt;%=(.+?)%&gt;/g;var expr = /&lt;%([\s\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`');template = 'echo(`' + template + '`);';然后，将template封装在一个函数里面返回，就可以了。var script =`(function parse(data)&#123; var output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output;&#125;)`;return script;将上面的内容拼装成一个模板编译函数compile。function compile(template)&#123; var evalExpr = /&lt;%=(.+?)%&gt;/g; var expr = /&lt;%([\s\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`'); template = 'echo(`' + template + '`);'; var script = `(function parse(data)&#123; var output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output; &#125;)`; return script;&#125;compile函数的用法如下。var parse = eval(compile(template));div.innerHTML = parse(&#123; supplies: [ "broom", "mop", "cleaner" ] &#125;);// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 alert123// 等同于alert(123)标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 var a = 5;var b = 10; tagHello ${ a + b } world ${ a * b };// 等同于tag([‘Hello ‘, ‘ world ‘, ‘’], 15, 50);上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数。 function tag(stringArr, value1, value2){ // …} // 等同于 function tag(stringArr, …values){ // …}tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下。 第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]第二个参数: 15第三个参数：50也就是说，tag函数实际上以下面的形式调用。 tag([‘Hello ‘, ‘ world ‘, ‘’], 15, 50)我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。 var a = 5;var b = 10; function tag(s, v1, v2) { console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return “OK”;} tagHello ${ a + b } world ${ a * b};// “Hello “// “ world “// “”// 15// 50// “OK”下面是一个更复杂的例子。 var total = 30;var msg = passthruThe total is ${total} (${total*1.05} with tax); function passthru(literals) { var result = ‘’; var i = 0; while (i &lt; literals.length) { result += literals[i++]; if (i &lt; arguments.length) { result += arguments[i]; } } return result;} msg // “The total is 30 (31.5 with tax)”上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。 passthru函数采用rest参数的写法如下。 function passthru(literals, …values) { var output = “”; for (var index = 0; index &lt; values.length; index++) { output += literals[index] + values[index]; } output += literals[index] return output;}“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。 var message = SaferHTML&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;; function SaferHTML(templateData) { var s = templateData[0]; for (var i = 1; i &lt; arguments.length; i++) { var arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;) .replace(/&lt;/g, &quot;&amp;lt;&quot;) .replace(/&gt;/g, &quot;&amp;gt;&quot;); // Don&apos;t escape special characters in the template. s += templateData[i]; } return s;}上面代码中，经过SaferHTML函数处理，HTML字符串的特殊字符都会被转义。 标签模板的另一个应用，就是多语言转换（国际化处理）。 i18nWelcome to ${siteName}, you are visitor number ${visitorNumber}!// “欢迎访问xxx，您是第xxxx位访问者！”模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。 // 下面的hashTemplate函数// 是一个自定义的模板处理函数var libraryHtml = hashTemplate` #for book in ${myBooks} &lt;li&gt;&lt;i&gt;#{book.title}&lt;/i&gt; by #{book.author}&lt;/li&gt; #end `;除此之外，你甚至可以使用标签模板，在JavaScript语言之中嵌入其他语言。 jsx&lt;div&gt; &lt;input ref=&#39;input&#39; onChange=&#39;${this.handleChange}&#39; defaultValue=&#39;${this.state.value}&#39; /&gt; ${this.state.value} &lt;/div&gt;上面的代码通过jsx函数，将一个DOM字符串转为React对象。你可以在Github找到jsx函数的具体实现。 下面则是一个假想的例子，通过java函数，在JavaScript代码之中运行Java代码。 javaclass HelloWorldApp { public static void main(String[] args) { System.out.println(“Hello World!”); // Display the string. } }HelloWorldApp.main();模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。 tagFirst line\nSecond line function tag(strings) { console.log(strings.raw[0]); // “First line\nSecond line”}上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[“First line\nSecond line”]，那么strings.raw数组就是[“First line\nSecond line”]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将\n视为\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。 String.raw()ES6还为原生的String对象，提供了一个raw方法。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 String.rawHi\n${2+3}!;// “Hi\n5!” String.rawHi\u000A!;// ‘Hi\u000A!’如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。 String.rawHi\\n// “Hi\n”String.raw的代码基本如下。 String.raw = function (strings, …values) { var output = “”; for (var index = 0; index &lt; values.length; index++) { output += strings.raw[index] + values[index]; } output += strings.raw[index] return output;}String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。 String.raw({ raw: ‘test’ }, 0, 1, 2);// ‘t0e1s2t’ // 等同于String.raw({ raw: [‘t’,’e’,’s’,’t’] }, 0, 1, 2); 来源]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript连等赋值]]></title>
    <url>%2Fjavascript%E8%BF%9E%E7%AD%89%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[说一下JavaScript的连等赋值，遇到的坑，例如12345var a = &#123;n:1&#125;;var b = a; // 持有a，以回查a.x = a = &#123;n:2&#125;;alert(a.x);// --&gt; undefinedalert(b.x);// --&gt; &#123;n:2&#125; 我的思路出发点 1.运算符优先级来考虑，.运算优先于=赋值运算2.右结合性 12345678910var a = &#123;n:1&#125;; /*定义a，赋值为&#123;n:1&#125;，假设指向存储地址为add_1*/var b = a; /*定义b，赋值为a，指向同一存储地址add_1*/a.x = a = &#123;n:2&#125;;/*（1）：定义a.x，赋值为a，即&#123;n:1&#125;，存储地址add_1上面的内容被更改 （2）：a.x重新赋值为&#123;n:2&#125;，存储地址add_1上面的内容被更改 （3）：a重新赋值为&#123;n:2&#125;，更改存储地址add_2*/alert(a.x);/*现在a的存储地址add_2，内容为&#123;n:2&#125;，上面并不存在a.x属性，所以为undefined*/alert(b.x);/*现在b的存储地址add_1，内容为&#123;n:1,x:&#123;n:2&#125;&#125;，所以b.x为&#123;n:2&#125;*/]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原创</tag>
        <tag>连等赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-变量的解构赋值]]></title>
    <url>%2Fes6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。123var a = 1;var b = 2;var c = 3; ES6允许写成下面这样。var [a, b, c] = [1, 2, 3];上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。12var [foo] = [];var [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。12345678// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;;` 上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。 解构赋值不仅适用于var命令，也适用于let和const命令。123var [v1, v2, ..., vN ] = array;let [v1, v2, ..., vN ] = array;const [v1, v2, ..., vN ] = array; 对于Set结构，也可以使用数组的解构赋值。12let [x, y, z] = new Set(["a", "b", "c"]);x // "a" 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。123456789101112function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。 默认值解构赋值允许指定默认值。12345var [foo = true] = [];foo // true[x, y = 'b'] = ['a']; // x='a', y='b'[x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。12345var [x = 1] = [undefined];x // 1var [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。1234567891011121314151617181920function f() &#123; console.log('aaa');&#125;let [x = f()] = [1];上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125;默认值可以引用解构赋值的其他变量，但该变量必须已经声明。let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123var &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456var &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"var &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果变量名与属性名不一致，必须写成下面这样。1234567var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写。 1234567var &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。var &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined上面代码中，真正被赋值的是变量baz，而不是模式foo。 注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。 123456789101112131415161718192021222324252627282930313233343536373839404142let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration "foo"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration "baz"上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。和数组一样，解构也可以用于嵌套结构的对象。var obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;var &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"注意，这时p是模式，不是变量，因此不会被赋值。var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined上面代码中，只有line是变量，loc和start都是模式，不会被赋值。 下面是嵌套赋值的例子。1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 对象的解构也可以指定默认值。123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 默认值生效的条件是，对象的属性值严格等于undefined。123456var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。 如果解构失败，变量的值等于undefined。12var &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。1234567891011121314151617181920212223242526272829// 报错var &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;;上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。var _tmp = &#123;baz: 'baz'&#125;;_tmp.foo.bar // 报错如果要将一个已经声明的变量用于解构赋值，必须非常小心。// 错误的写法var x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error上面代码的写法会报错，因为JavaScript引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;);上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []);上面的表达式虽然毫无意义，但是语法是合法的，可以执行。对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。let &#123; log, sin, cos &#125; = Math;上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。1234var arr = [1, 2, 3];var &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象结构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。12345678910const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o"类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 123456let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值。12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined就会触发函数参数的默认值。12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。 ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况以下三种解构赋值不得使用圆括号。 （1）变量声明语句中，不能带有圆括号。12345678910// 全部报错var [(a)] = [1];var &#123;x: (c)&#125; = &#123;&#125;;var (&#123;x: c&#125;) = &#123;&#125;;var &#123;(x: c)&#125; = &#123;&#125;;var &#123;(x): c&#125; = &#123;&#125;;&#125;var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数中，模式不能带有圆括号。 函数参数也属于变量声明，因此不能带有圆括号。12// 报错function f([(z)]) &#123; return z; &#125; （3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。12345678910111213141516// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];上面代码将整个模式放在圆括号之中，导致报错。// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];上面代码将嵌套模式的一层，放在圆括号之中，导致报错。可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多。 交换变量的值 [x, y] = [y, x];上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。 1234567891011var jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309]上面代码可以快速提取JSON数据的值。 函数参数的默认值 123456789101112jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;;指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。 遍历Map结构 任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 1234567891011121314151617181920var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world如果只想获取键名，或者只想获取键值，可以写成下面这样。// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 来源]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用 Git 命令清单]]></title>
    <url>%2F%E5%B8%B8%E7%94%A8-git-%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[转载自阮一峰的日志http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html 我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 1234* Workspace：工作区* Index / Stage：暂存区* Repository：仓库区（或本地仓库）* Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]" 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archive]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript隐式转换]]></title>
    <url>%2Fjavascript%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[当一些操作涉及到不一样的数据类型，就会出现类型转换（隐形） 符号+ - 1234+ 有字符串拼接和加法运算的功能如果把一个变量a ，转换成数字，最简单的 方法就是 用 a-0同理如果想转化成字符串就 a+'' ,用变量加上一个空字符串 等于”==”和严格等于”===” 123456严格等于 ===判断两边的类型（相同or不同），直接返回true OR falsenull === null true == 也是trueundefined === undefined true == 也是trueNaN === NaN 返回false ，NaN 不等于自己 。 == 也返回falsenew Object 不等于 new Object 因为他们不是相同的对象,返回false 。 == 也返回false 类型不同会尝试转换类型后比较 12345null == undifined truenumber == string 转 number 1 == '1.0' trueboolean == ? 转 number true == 1 trueObject == number | string 尝试转换成基础类型new String('hi') == 'hi' true 其他的返回FALSE]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>类型转换</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript强制类型转换]]></title>
    <url>%2Fjavascript%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Javascript的变量是松散类型的，它可以存储Javascript支持的任何数据类型，其变量的类型可以在运行时被动态改变。 正因为Javascript中变量类型具有动态性，在程序实际执行的过程中就需要用到类型转换的概念。类型转换可以分为隐式转换和显式转换，所谓隐 式转换即程序在运行时进行的自动转换，显式转换则是人为的对类型进行强制转换。 Javascript提供了以下转型函数：转换为数值类型：Number(mix)、parseInt(string,radix)、parseFloat(string)转换为字符串类型：toString(radix)、String(mix)转换为布尔类型：Boolean(mix) Number(mix)函数，可以将任意类型的参数mix转换为数值类型。其规则为： 123456789Boolean-&gt;Number : true,false --&gt; 1,0Number-&gt;Number : 返回其本身undefined-&gt;Number : undefined --&gt; NaNString-&gt;Number : + 如果字符串中只包含数字，则将其转换为十进制（忽略前导0） + 如果字符串中包含有效的浮点格式，将其转换为浮点数值（忽略前导0） + 如果是空字符串，将其转换为0 + 如果字符串中包含非以上格式，则将其转换为NaN + 如果是对象，则调用对象的valueOf()方法，然后依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再次依照前面的规则转换返回的字符串值。 下表列出了对象的valueOf()的返回值： 对象 返回值 Array 数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起。其操作与 Array.toString 和 Array.join 方法相同。 Boolean Boolean 值。 Date 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。 Function 函数本身。 Number 数字值。 Object 对象本身。这是默认情况。 String 字符串值。 parseInt(string, radix)函数，将字符串转换为整数类型的数值。它也有一定的规则： 12345忽略字符串前面的空格，直至找到第一个非空字符如果第一个字符不是数字符号或者负号，返回NaN如果第一个字符是数字，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止如果上步解析的结果以0开头，则将其当作八进制来解析；如果以x开头，则将其当作十六进制来解析如果指定radix参数，则以radix为基数进行解析 parseFloat(string)函数，将字符串转换为浮点数类型的数值。 12它的规则与parseInt基本相同，但也有点区别：字符串中第一个小数点符号是有效的，另外parseFloat会忽略所有前导0，如果字符串包含一个可解析为整数的数，则返回整数值而不是浮点数值。 toString(radix)方法。除undefined和null之外的所有类型的值都具有toString()方法，其作用是返回对象的字符串表示。 对象 操作 Array 将 Array 的元素转换为字符串。结果字符串由逗号分隔，且连接起来。 Boolean 如果 Boolean 值是 true，则返回 “true”。否则，返回 “false”。 Date 返回日期的文字表示法。 Error 返回一个包含相关错误信息的字符串。 Function 返回如下格式的字符串，其中 functionname 是被调用 toString 方法函数的名称： function functionname( ) { [native code] } Number 返回数字的文字表示。 String 返回 String 对象的值。 默认 返回 “[object objectname]”，其中 objectname 是对象类型的名称。 String(mix)函数，将任何类型的值转换为字符串，其规则为： 123如果有toString()方法，则调用该方法（不传递radix参数）并返回结果如果是null，返回”null”如果是undefined，返回”undefined” Boolean(mix)函数，将任何类型的值转换为布尔值。 1以下值会被转换为false：fals* ”"、0、NaN、null、undefined，其余任何值都会被转换为true。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>类型转换</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现Base64编码]]></title>
    <url>%2Fjavascript%E5%AE%9E%E7%8E%B0base64%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[编码规则 Base64编码的思想是是采用64个基本的ASCII码字符对数据进行重新编码。它将需要编码的数据拆分成字节数组。以3个字节为一组。按顺序排列24 位数据，再把这24位数据分成4组，即每组6位。再在每组的的最高位前补两个0凑足一个字节。这样就把一个3字节为一组的数据重新编码成了4个字节。当所要编码的数据的字节数不是3的整倍数，也就是说在分组时最后一组不够3个字节。这时在最后一组填充1到2个0字节。并在最后编码完成后在结尾添加1到2个 “=”。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138 //下面是64个基本的编码 var base64EncodeChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; var base64DecodeChars = new Array( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1); //编码的方法 function base64encode(str) &#123; var out, i, len; var c1, c2, c3; len = str.length; i = 0; out = ""; while(i &lt; len) &#123; c1 = str.charCodeAt(i++) &amp; 0xff; if(i == len) &#123; out += base64EncodeChars.charAt(c1 &gt;&gt; 2); out += base64EncodeChars.charAt((c1 &amp; 0x3) &lt;&lt; 4); out += "=="; break; &#125; c2 = str.charCodeAt(i++); if(i == len) &#123; out += base64EncodeChars.charAt(c1 &gt;&gt; 2); out += base64EncodeChars.charAt(((c1 &amp; 0x3)&lt;&lt; 4) | ((c2 &amp; 0xF0) &gt;&gt; 4)); out += base64EncodeChars.charAt((c2 &amp; 0xF) &lt;&lt; 2); out += "="; break; &#125; c3 = str.charCodeAt(i++); out += base64EncodeChars.charAt(c1 &gt;&gt; 2); out += base64EncodeChars.charAt(((c1 &amp; 0x3)&lt;&lt; 4) | ((c2 &amp; 0xF0) &gt;&gt; 4)); out += base64EncodeChars.charAt(((c2 &amp; 0xF) &lt;&lt; 2) | ((c3 &amp; 0xC0) &gt;&gt;6)); out += base64EncodeChars.charAt(c3 &amp; 0x3F); &#125; return out; &#125; //解码的方法 function base64decode(str) &#123; var c1, c2, c3, c4; var i, len, out; len = str.length; i = 0; out = ""; while(i &lt; len) &#123; do &#123; c1 = base64DecodeChars[str.charCodeAt(i++) &amp; 0xff]; &#125; while(i &lt; len &amp;&amp; c1 == -1); if(c1 == -1) break; do &#123; c2 = base64DecodeChars[str.charCodeAt(i++) &amp; 0xff]; &#125; while(i &lt; len &amp;&amp; c2 == -1); if(c2 == -1) break; out += String.fromCharCode((c1 &lt;&lt; 2) | ((c2 &amp; 0x30) &gt;&gt; 4)); do &#123; c3 = str.charCodeAt(i++) &amp; 0xff; if(c3 == 61) return out; c3 = base64DecodeChars[c3]; &#125; while(i &lt; len &amp;&amp; c3 == -1); if(c3 == -1) break; out += String.fromCharCode(((c2 &amp; 0XF) &lt;&lt; 4) | ((c3 &amp; 0x3C) &gt;&gt; 2)); do &#123; c4 = str.charCodeAt(i++) &amp; 0xff; if(c4 == 61) return out; c4 = base64DecodeChars[c4]; &#125; while(i &lt; len &amp;&amp; c4 == -1); if(c4 == -1) break; out += String.fromCharCode(((c3 &amp; 0x03) &lt;&lt; 6) | c4); &#125; return out; &#125; function utf16to8(str) &#123; var out, i, len, c; out = ""; len = str.length; for(i = 0; i &lt; len; i++) &#123; c = str.charCodeAt(i); if ((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)) &#123; out += str.charAt(i); &#125; else if (c &gt; 0x07FF) &#123; out += String.fromCharCode(0xE0 | ((c &gt;&gt; 12) &amp; 0x0F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 6) &amp; 0x3F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 0) &amp; 0x3F)); &#125; else &#123; out += String.fromCharCode(0xC0 | ((c &gt;&gt; 6) &amp; 0x1F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 0) &amp; 0x3F)); &#125; &#125; return out;&#125;function utf8to16(str) &#123; var out, i, len, c; var char2, char3; out = ""; len = str.length; i = 0; while(i &lt; len) &#123; c = str.charCodeAt(i++); switch(c &gt;&gt; 4) &#123; case case case case case case case case // 0xxxxxxx out += str.charAt(i-1); break; case case // 110x xxxx 10xx xxxx char2 = str.charCodeAt(i++); out += String.fromCharCode(((c &amp; 0x1F) &lt;&lt; 6) | (char2 &amp; 0x3F)); break; case // 1110 xxxx 10xx xxxx 10xx xxxx char2 = str.charCodeAt(i++); char3 = str.charCodeAt(i++); out += String.fromCharCode(((c &amp; 0x0F) &lt;&lt; 12) | ((char2 &amp; 0x3F) &lt;&lt; 6) | ((char3 &amp; 0x3F) &lt;&lt; 0)); break; &#125; &#125; return out;&#125; 调用 12345//编码value = base64encode(utf16to8(src))//解码value = utf8to16(base64decode(src))]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript字符串常用方法]]></title>
    <url>%2Fjavascript%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[列举常用的JavaScript字符串操作的方法 concat将两个或多个字符的文本组合起来，返回一个新的字符串。12345var a = "hello";var b = ",world";var c = a.concat(b);alert(c);//c = "hello,world" indexOf返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。1234var index1 = a.indexOf("l");//index1 = 2var index2 = a.indexOf("l",3);//index2 = 3 charAt返回指定位置的字符。12var get_char = a.charAt(0);//get_char = "h" lastIndexOf返回字符串中一个子串最后一处出现的索引（从右到左搜索），如果没有匹配项，返回 -1 。1234var index1 = lastIndexOf('l');//index1 = 3var index2 = lastIndexOf('l',2)//index2 = 2 match检查一个字符串匹配一个正则表达式内容，如果么有匹配返回 null。12345var re = new RegExp(/^\w+$/);var is_alpha1 = a.match(re);//is_alpha1 = "hello"var is_alpha2 = b.match(re);//is_alpha2 = null substring返回字符串的一个子串，传入参数是起始位置和结束位置。1234var sub_string1 = a.substring(1);//sub_string1 = "ello"var sub_string2 = a.substring(1,4);//sub_string2 = "ell" substr返回字符串的一个子串，传入参数是起始位置和长度1234var sub_string1 = a.substr(1);//sub_string1 = "ello"var sub_string2 = a.substr(1,4);//sub_string2 = "ello" replace用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。1234var result1 = a.replace(re,"Hello");//result1 = "Hello"var result2 = b.replace(re,"Hello");//result2 = ",world" search执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。1234var index1 = a.search(re);//index1 = 0var index2 = b.search(re);//index2 = -1 slice提取字符串的一部分，并返回一个新字符串（与 substring 相同）。1234var sub_string1 = a.slice(1);//sub_string1 = "ello"var sub_string2 = a.slice(1,4);//sub_string2 = "ell" split通过将字符串划分成子串，将一个字符串做成一个字符串数组。12var arr1 = a.split("");//arr1 = [h,e,l,l,o] length返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。12var len = a.length();//len = 5 **toLowerCase 将整个字符串转成小写字母。12var lower_string = a.toLowerCase();//lower_string = "hello" **toUpperCase 将整个字符串转成大写字母。12var upper_string = a.toUpperCase();//upper_string = "HELLO"]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原创</tag>
        <tag>字符串方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node项目中,Package.json的版本管理]]></title>
    <url>%2Fnode%E9%A1%B9%E7%9B%AE%E4%B8%AD-package-json%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[package.json 的版本的匹配规则 用version来表示一个具体的版本 一般范围语法 version //必须严格匹配到 version版本 &gt;version //必须大于 version的版本 &gt;=version //大于等于 version的版本 &lt;version //小于version的版本 &lt;=version //小于等于 带alpha的版本 // 例如 &gt;1.2.3-alpha.3,允许匹配版本1.2.3-alpha.7，但它不匹配 3.4.5-alpha.9，即使3.4.5-alpha.9在技术上是“大于” 1.2.3-alpha.3的。SemVer排序规则 高级区域语法 version1 - version2 //连字符范围, 1.2.3 - 2.3.4 等价于 &gt;=1.2.3 &lt;=2.3.4 ~version //一般是补丁级别的修改 例如：~1.2.3 等价于 &gt;=1.2.3 &lt;1.(2+1).0 等价于 &gt;=1.2.3 &lt;1.3.0 ^version //“兼容的版本” 参考 1.2.x //匹配 &gt;=1.2.0 &lt;1.3.0 * //匹配任意版本“” // &quot;&quot;（空字符串）等价于 * 等价于 &gt;=0.0.0 range1 || range2 //range1 或者 range2 的任一版本. 更多的使用方法请访问参考链接 参考 The semantic versioner for npmSemantic Versioning 2.0.0]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>package.json</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现获取URL参数]]></title>
    <url>%2Fjavascript%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96url%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[通过 JavaScript 来获取 url 上携带的参数 假设 url=”http://xxx.com.cn?name=webkong&amp;age=23&amp;sex=男“ 第一种，直接 js 函数，截取 url，拼装成对象 12345678910111213141516171819202122function GET()&#123; var url = window.document.location.href.toString(); var u = url.split("?"); if(typeof(u[1]) == "string")&#123; u = u[1].split("&amp;"); var get = &#123;&#125;; for(var i in u)&#123; var j = u[i].split("="); get[j[0]] = j[1]; &#125; return get; &#125;else &#123; return &#123;&#125;; &#125;&#125;;var getParam = GET(); //通过变量保存参数对象//getParam:&#123; name:"webkong", age:"23", sex:"男"&#125; 和第一种逻辑过程一样，只是结果是对象本身 1234567891011121314151617var $_GET = (function()&#123; var url = window.document.location.href.toString(); var u = url.split("?"); if(typeof(u[1]) == "string")&#123; u = u[1].split("&amp;"); var get = &#123;&#125;; for(var i in u)&#123; var j = u[i].split("="); get[j[0]] = j[1]; &#125; return get; &#125; else &#123; return &#123;&#125;; &#125;&#125;)();// 使用时, 可以直接 $_GET['name'], 就直接获得name值 第二种，通过正则来匹配 12345678//通过传递参数来获取url上的某一个参数值function GET(name)&#123; var reg = new RegExp("(^|&amp;)"+ name +"=([^&amp;]*)(&amp;|$)"); //构造一个含有目标参数的正则表达式对象 var r = window.location.search.substr(1).match(reg); //匹配目标参数 if (r!=null) return unescape(r[2]); return null; //返回参数值&#125;//调用 GET('name'); 或者扩展成 jQuery 12345678(function($)&#123; $.getUrlParam= function(name)&#123; var reg = new RegExp("(^|&amp;)"+name +"=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if (r!=null) return unescape(r[2]); return null; &#125;&#125;)(jQuery); 大概有这 4 种封装方式，可以任意搭配封装方式和逻辑代码]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>URL参数</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的删除操作]]></title>
    <url>%2Fgit%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[记录一下 git 的删除回滚类操作 本地库操作 场景： 已经 commit 但是没有 push 12345git log//查看上次提交的commit-id (hash值)git reset --soft commit-id//撤销commit操作，保留commit时候改的的代码。 强制回滚 12git reset --hard commit-id//回退到某个版本，并且删除修改的文件 场景： 没有 commit，而且是新建的文件或者文件夹，抛弃所有这些修改 12git clean//clean 用来 抛弃所有untracked 状态的文件 tips: git 文件的三种状态 untracked 未被 git 跟踪的文件 (新增文件，未加入到暂存区) new files(Changes to be committed) 文件被 commit 到了暂存区 modified (Changes not staged for commit) 已经提交过的文件被修改，还未提交到暂存区 场景： 抛弃所有 modified 状态的 文件 1234567git checkout . //一定要带点（.）git checkout -- ''*.js'//如果是删除某类文件可以用git checkout -- 1.js//删除某个文件 如果要删除工作区的修改可以连用 git checkout . &amp;&amp; git clean -xdf 场景： 提交信息写错，或者遗漏提交 12345//如果有遗漏，先addgit add//然后再次提交git commit -m "some message" --amend]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript定义类(class)的三种方法]]></title>
    <url>%2Fjavascript%E5%AE%9A%E4%B9%89%E7%B1%BB-class-%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[作者：阮一峰原文地址 在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。 一、构造函数法这是经典方法，也是教科书必教的方法。它用构造函数模拟”类”，在其内部用this关键字指代实例对象。123function Cat()&#123; this.name = '大毛'&#125; 生成实例的时候用new关键字12var cat1 = new Cat();alert(cat1.name); //大毛 类的属性和方法，还可以定义在构造函数的prototype对象之上。123Cat.prototype.makeSound = function()&#123; alert('喵喵');&#125; 关于这种方法的详细介绍，请看我写的系列文章《Javascript 面向对象编程》，这里就不多说了。它的主要缺点是，比较复杂，用到了this和prototype，编写和阅读都很费力。 二、Object.create()法为了解决”构造函数法”的缺点，更方便地生成对象，Javascript的国际标准ECMAScript第五版（目前通行的是第三版），提出了一个新的方法Object.create()。用这个方法，”类”就是一个对象，不是函数。123456var Cat = &#123; name:"大毛", makeSound:function()&#123; alert("喵喵喵"); &#125;&#125; 然后，直接用Object.create()生成实例，不需要用到new。123var cat1 = Object.creat(Cat);alert(cat1.name); //大毛cat1.makeSound(); //喵喵喵 目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署。1234567if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;; &#125; 这种方法比”构造函数法”简单，但是不能实现私有属性和私有方法，实例对象之间也不能共享数据，对”类”的模拟不够全面。 三、极简主义法荷兰程序员Gabor de Mooij提出了一种比Object.create()更好的新方法，他称这种方法为”极简主义法”（minimalist approach）。这也是我推荐的方法。 1.封装这种方法不使用this和prototype，代码部署起来非常简单，这大概也是它被叫做”极简主义法”的原因。首先，它也是用一个对象模拟”类”。在这个类里面，定义一个构造函数createNew()，用来生成实例。12345var Cat = &#123; createNew: function()&#123; // some code here &#125;&#125; 然后，在createNew()里面，定义一个实例对象，把这个实例对象作为返回值。 12345678var Cat = &#123; createNew: function()&#123; var cat = &#123;&#125;; cat.name = "大毛"; cat.makeSound = function()&#123;alert('miaomiaomiao')&#125;; return cat; &#125;&#125; 使用的时候，调用createNew()方法，就可以得到实例对象。12var cat1 = Cat.createNew(); cat1.makeSound(); // 喵喵喵 这种方法的好处是，容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造，因此可以方便地部署下面的特性。 2.继承让一个类继承另一个类，实现起来很方便。只要在前者的createNew()方法中，调用后者的createNew()方法即可。先定义一个Animal类。1234567var Animal = &#123; createNew: function()&#123; var animal = &#123;&#125;; animal.sleep = function()&#123;alert("睡懒觉")&#125;; return animal; &#125;&#125;; 然后，在Cat的createNew()方法中，调用Animal的createNew()方法。 12345678var Cat = &#123; createNew:function()&#123; var cat = Animal.createNew(); cat.name = "damao"; cat.makeSound = function ()&#123;alert('miaomiaomiao')&#125; return cat; &#125;;&#125;; 这样得到的Cat实例，就会同时继承Cat类和Animal类。12var cat1 = Cat.createNew(); cat1.sleep(); // 睡懒觉 3.私有属性和私有方法在createNew()方法中，只要不是定义在cat对象上的方法和属性，都是私有的。12345678var Cat = &#123; createNew: function()&#123; var cat = &#123;&#125;; var sound = "喵喵喵"; cat.makeSound = function()&#123; alert(sound); &#125;; return cat; &#125; &#125;; 上例的内部变量sound，外部无法读取，只有通过cat的公有方法makeSound()来读取。12var cat1 = Cat.createNew(); alert(cat1.sound); // undefined 4.数据共享有时候，我们需要所有实例对象，能够读写同一项内部数据。这个时候，只要把这个内部数据，封装在类对象的里面、createNew()方法的外面即可。123456789var Cat = &#123; sound : "喵喵喵", createNew: function()&#123; var cat = &#123;&#125;; cat.makeSound = function()&#123; alert(Cat.sound); &#125;; cat.changeSound = function(x)&#123; Cat.sound = x; &#125;; return cat; &#125; &#125;; 然后，生成两个实例对象：123var cat1 = Cat.createNew();var cat2 = Cat.createNew();cat1.makeSound(); // 喵喵喵 这时，如果有一个实例对象，修改了共享的数据，另一个实例对象也会受到影响。 12cat2.changeSound("啦啦啦");cat1.makeSound(); // 啦啦啦]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>类型转换</tag>
        <tag>类class</tag>
        <tag>类、对象、继承</tag>
      </tags>
  </entry>
</search>
